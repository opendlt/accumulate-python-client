{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accumulate Python Client","text":"<p>Welcome to the Accumulate Python Client documentation!</p> <p>This client library provides easy access to the Accumulate blockchain network, enabling seamless interaction with Accumulate's decentralized identity and ledger system</p> <p>With this library, developers can easily: - Create and manage Accumulate accounts - Submit transactions - Query blockchain data - And more!</p>"},{"location":"#key-sections","title":"Key Sections","text":"<ul> <li>Getting Started: Quick start guide for installation and setup</li> <li>API Reference: Detailed reference of all available modules, classes, and methods</li> <li>Examples: Practical examples and common usage patterns</li> <li>Contributing: How to contribute to the project</li> <li>Changelog: Version history and notable updates</li> </ul> <p>Note: This client is actively maintained. Contributions are welcome!</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>Detailed auto-generated reference for Accumulate Python Client.</p>"},{"location":"api_reference/#client","title":"Client","text":""},{"location":"api_reference/#accumulate.api.client","title":"<code>client</code>","text":""},{"location":"api_reference/#accumulate.api.client.AccumulateClient","title":"<code>AccumulateClient</code>","text":"<p>Client for interacting with the Accumulate JSON-RPC API with a persistent auto-incrementing request ID.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>class AccumulateClient:\n    \"\"\"Client for interacting with the Accumulate JSON-RPC API with a persistent auto-incrementing request ID.\"\"\"\n\n    def __init__(self, base_url: str = None):\n        self.base_url = base_url or get_accumulate_rpc_url()\n        self.transport = RoutedTransport(self.base_url)\n        self._id_counter = load_counter()  # Load last used ID\n\n    async def json_rpc_request(self, method: str, params: Optional[Dict[str, Any]] = None) -&gt; Dict[str, Any]:\n        \"\"\"Send a JSON-RPC request with an auto-incrementing ID stored persistently.\"\"\"\n        rpc_id = self._id_counter\n        self._id_counter += 1\n        save_counter(self._id_counter)  # Save new counter value\n\n        json_rpc_payload = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": params or {},\n            \"id\": rpc_id,\n        }\n\n        logger.info(f\"RPC Request: {json_rpc_payload}\")\n\n        try:\n            response = await self.transport.send_request(endpoint=\"v3\", method=\"POST\", data=json_rpc_payload)\n\n            logger.info(f\"RPC Response: {response}\")\n\n            if \"error\" in response:\n                raise AccumulateError(f\"JSON-RPC request failed ({method}): {response['error'].get('message', 'Unknown error')}\")\n\n            return response.get(\"result\", {})\n\n        except Exception as e:\n            logger.error(f\"JSON-RPC request failed ({method}): {e}\")\n            raise AccumulateError(f\"JSON-RPC request failed ({method}): {e}\")\n\n\n    async def submit(self, envelope: Dict[str, Any], verify: bool = True, wait: bool = True) -&gt; Dict[str, Any]:\n        \"\"\"\n        Submit a transaction to the Accumulate network.\n\n        Args:\n            envelope (Dict[str, Any]): The transaction envelope containing transactions and signatures.\n            verify (bool, optional): If True, verifies the envelope before submission. Defaults to True.\n            wait (bool, optional): If True, blocks until submission is confirmed or rejected. Defaults to True.\n\n        Returns:\n            Dict[str, Any]: The API response containing transaction details.\n        \"\"\"\n        if not isinstance(envelope, dict):\n            raise ValueError(\"Envelope must be a dictionary.\")\n\n        #  Ensure the envelope has \"signatures\" (FIRST in order)\n        if \"signatures\" not in envelope or not isinstance(envelope[\"signatures\"], list) or not envelope[\"signatures\"]:\n            raise ValueError(\"Envelope must contain at least one signature in a list.\")\n\n        #  Ensure \"transaction\" is correctly structured (SECOND in order)\n        if \"transaction\" not in envelope or not isinstance(envelope[\"transaction\"], list) or not envelope[\"transaction\"]:\n            raise ValueError(\"Envelope must contain at least one transaction in a list.\")\n\n        #  Validate transaction structure\n        for txn in envelope[\"transaction\"]:\n            if not isinstance(txn, dict):\n                raise ValueError(\"Each transaction must be a dictionary.\")\n\n            if \"header\" not in txn or not isinstance(txn[\"header\"], dict):\n                raise ValueError(\"Each transaction must contain a 'header' as a dictionary.\")\n\n            if \"body\" not in txn or not isinstance(txn[\"body\"], dict):\n                raise ValueError(\"Each transaction must contain a 'body' as a dictionary.\")\n\n            #  Ensure transactionHash (if exists) is properly formatted\n            if \"transactionHash\" in txn and not isinstance(txn[\"transactionHash\"], str):\n                raise ValueError(\"Transaction hash must be a raw hex string.\")\n\n        #  Order envelope fields correctly\n        ordered_envelope = {\n            \"signatures\": envelope[\"signatures\"],  # Signatures First\n            \"transaction\": envelope[\"transaction\"],  # Transactions Second\n        }\n\n        #  Include messages if they exist (LAST in order)\n        if \"messages\" in envelope and isinstance(envelope[\"messages\"], list):\n            ordered_envelope[\"messages\"] = envelope[\"messages\"]\n\n        params = {\n            \"envelope\": ordered_envelope,\n            \"verify\": verify,\n            \"wait\": wait,\n        }\n\n        #  Debugging Before JSON Serialization\n        for sig in envelope[\"signatures\"]:\n            if inspect.iscoroutine(sig):\n                raise RuntimeError(f\" Signature contains an unawaited coroutine: {sig}\")\n\n        json_params = json.dumps(params)  # Convert Python dict to JSON string\n        formatted_params = json.loads(json_params)  # Convert JSON string back to dict (ensures double quotes)\n\n        #  Log the final envelope before submission\n        logger.info(\" Debug: Final Submission Payload\")\n        logger.info(json.dumps(formatted_params, indent=2))\n\n        return await self.json_rpc_request(\"submit\", formatted_params)\n\n\n    async def validate(self, envelope: Dict[str, Any], full: bool = False) -&gt; Dict[str, Any]:\n        \"\"\"Validate a transaction envelope against the Accumulate network using JSON-RPC\"\"\"\n        params = {\"envelope\": envelope, \"full\": full}\n        return await self.json_rpc_request(\"validate\", params)\n\n\n    async def query_block(self, block_type: str, index: Optional[int] = None, start: Optional[int] = None, count: Optional[int] = None) -&gt; dict:\n        \"\"\"\n        Query a minor or major block.\n\n        Args:\n            block_type (str): Either \"minor\" or \"major\"\n            index (Optional[int]): Block index (if querying a specific block)\n            start (Optional[int]): Start index for range queries\n            count (Optional[int]): Number of blocks to retrieve in range queries\n\n        Returns:\n            dict: JSON response from the API\n        \"\"\"\n        if block_type not in [\"minor\", \"major\"]:\n            raise ValueError(\"Invalid block type. Must be 'minor' or 'major'.\")\n\n        params = {}\n\n        if index is not None:\n            #  Query a specific minor or major block\n            url = f\"{self.transport.base_url}/block/{block_type}/{index}\"\n\n            if block_type == \"major\":\n                #  Fetch the first 3 minor blocks within the major block\n                params[\"minor_start\"] = 0\n                params[\"minor_count\"] = 3\n                params[\"omit_empty\"] = True  # Exclude empty minor blocks\n\n        else:\n            #  Query a block range\n            url = f\"{self.transport.base_url}/block/{block_type}\"\n            if start is not None:\n                params[\"start\"] = start\n            if count is not None:\n                params[\"count\"] = count\n\n        logger.info(f\" HTTP Request: GET {url} with params {params}\")\n\n        response = await self.transport.send_request(endpoint=url, method=\"GET\", params=params)\n\n        if not response:\n            logger.error(f\" API request returned no response.\")\n            raise AccumulateError(f\"Block query failed: No response received.\")\n\n        if response.get(\"error\"):\n            logger.error(f\" API request failed: {response['error']}\")\n            raise AccumulateError(f\"Block query failed: {response['error']['message']}\")\n\n        return response\n\n\n    async def query(self, scope: str, query: Query) -&gt; Record:\n        \"\"\"Submit a query to the Accumulate network using JSON-RPC.\"\"\"\n        if not query.is_valid():\n            raise ValueError(\"Invalid query.\")\n\n        # Convert query to dictionary\n        query_dict = query.to_dict()\n        query_dict[\"queryType\"] = query.query_type.to_rpc_format()\n\n        params = {\"scope\": scope, \"query\": query_dict}\n\n        #  DEBUG: Log raw API request\n        logger.debug(f\" Sending Query Request: {params}\")\n\n        response = await self.json_rpc_request(\"query\", params)\n\n        #  DEBUG: Log raw API response\n        logger.debug(f\" Raw API Response: {response} (Type: {type(response)})\")\n\n        #  If response is a string, try parsing it as JSON\n        if isinstance(response, str):\n            try:\n                response = json.loads(response)\n                logger.debug(f\" Decoded String Response: {response}\")\n            except json.JSONDecodeError:\n                raise AccumulateError(f\"API returned an invalid JSON string: {response}\")\n\n        # Ensure response is a dictionary\n        if not isinstance(response, dict):\n            raise AccumulateError(f\"Unexpected API response format: {response} (type: {type(response)})\")\n\n        #  Convert API response keys from camelCase to snake_case\n        response = {camel_to_snake(k): v for k, v in response.items()}\n\n        if \"record_type\" not in response:\n            raise AccumulateError(f\"Unexpected response format: {response}\")\n\n        record_type = response[\"record_type\"]\n\n        #  Ensure consistency with RecordType enum\n        record_mapping = {\n            RecordType.ACCOUNT.name.lower(): AccountRecord,\n            RecordType.CHAIN.name.lower(): ChainRecord,\n            RecordType.MESSAGE.name.lower(): MessageRecord,\n            RecordType.CHAIN_ENTRY.name.lower(): ChainEntryRecord,\n            RecordType.KEY.name.lower(): KeyRecord,\n            RecordType.SIGNATURE_SET.name.lower(): SignatureSetRecord,\n            RecordType.URL.name.lower(): UrlRecord,\n            RecordType.TX_ID.name.lower(): TxIDRecord,\n            RecordType.RANGE.name.lower(): RecordRange,\n            \"directory\": RecordRange,  # Some APIs might return this as 'directory'\n        }\n\n        record_cls = record_mapping.get(record_type, Record)  # Default to Record if unknown\n\n        #  Ensure return type is correct\n        record_obj = record_cls.from_dict(response)\n        logger.debug(f\" Processed Query Response: {record_obj} (Type: {type(record_obj)})\")\n\n        return record_obj  # This should return an object with is_valid()\n\n\n    async def search(self, account_id: str, search_type: str, value: str, extra_params: Optional[Dict[str, Any]] = None) -&gt; dict:\n        \"\"\"\n        Search an account for an anchor, public key, or delegate using JSON-RPC.\n\n        Args:\n            account_id (str): The account ID to search within.\n            search_type (str): The type of search. Must be 'anchor', 'publicKey', or 'delegate'.\n            value (str): The value to search for (anchor hash, public key, or delegate URL).\n            extra_params (Optional[Dict[str, Any]]): Additional query parameters.\n\n        Returns:\n            dict: JSON response from the API.\n        \"\"\"\n        if search_type not in [\"anchor\", \"publicKey\", \"delegate\"]:\n            raise ValueError(\"Invalid search type. Must be 'anchor', 'publicKey', or 'delegate'.\")\n\n        #  Ensure correct JSON-RPC format\n        params = {\n            \"scope\": account_id,\n            \"query\": {\n                \"queryType\": search_type,\n                \"value\": value\n            }\n        }\n\n        #  Merge optional parameters if provided\n        if extra_params:\n            params[\"query\"].update(extra_params)\n\n        logger.info(f\" RPC Request: {params}\")\n\n        response = await self.json_rpc_request(\"search\", params)\n\n        if not response:\n            logger.error(f\" API request returned no response.\")\n            raise AccumulateError(f\"Search query failed: No response received.\")\n\n        return response\n\n\n    async def network_status(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Fetch the current network status from the Accumulate blockchain.\n\n        Returns:\n            Dict[str, Any]: JSON response containing network status details.\n        \"\"\"\n        try:\n            response = await self.json_rpc_request(\"network-status\")\n\n            if not response:\n                logger.error(\"Network status query returned no response.\")\n                raise AccumulateError(\"Network status query failed: No response received.\")\n\n            logger.info(f\"Network Status Response: {response}\")\n            return response\n\n        except Exception as e:\n            logger.error(f\"Failed to fetch network status: {e}\")\n            raise AccumulateError(f\"Network status query failed: {e}\")\n\n\n    async def faucet(self, account: str, token_url: Optional[str] = None) -&gt; Submission:\n        \"\"\"Request tokens from the Accumulate faucet using JSON-RPC\"\"\"\n        if not account:\n            raise ValueError(\"Account URL must be provided\")\n\n        params = {\"account\": account}\n        if token_url:\n            params[\"token\"] = token_url\n\n        response = await self.json_rpc_request(\"faucet\", params)\n        return Submission(**response)\n\n    async def find_service(self, options: FindServiceOptions) -&gt; List[FindServiceResult]:\n        \"\"\"Find available services on the Accumulate network using JSON-RPC\"\"\"\n        params = options.to_dict()  # Converts to correct JSON-RPC format\n        response = await self.json_rpc_request(\"find-service\", params)\n\n        return [FindServiceResult(\n            peer_id=res.get(\"peer_id\", \"\"),\n            status=res.get(\"status\", \"\"),\n            addresses=res.get(\"addresses\", [])\n        ) for res in response]\n\n    async def metrics(self) -&gt; Dict[str, Any]:\n        \"\"\"Retrieve network metrics such as transactions per second using JSON-RPC\"\"\"\n        return await self.json_rpc_request(\"metrics\")\n\n    async def list_snapshots(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"List available blockchain snapshots using JSON-RPC\"\"\"\n        return await self.json_rpc_request(\"list-snapshots\")\n\n    async def close(self):\n        \"\"\"Close the transport connection\"\"\"\n        logger.debug(\"\ud83d\udd0c Closing AccumulateClient transport connection\")\n        await self.transport.close()\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the transport connection</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def close(self):\n    \"\"\"Close the transport connection\"\"\"\n    logger.debug(\"\ud83d\udd0c Closing AccumulateClient transport connection\")\n    await self.transport.close()\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.faucet","title":"<code>faucet(account, token_url=None)</code>  <code>async</code>","text":"<p>Request tokens from the Accumulate faucet using JSON-RPC</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def faucet(self, account: str, token_url: Optional[str] = None) -&gt; Submission:\n    \"\"\"Request tokens from the Accumulate faucet using JSON-RPC\"\"\"\n    if not account:\n        raise ValueError(\"Account URL must be provided\")\n\n    params = {\"account\": account}\n    if token_url:\n        params[\"token\"] = token_url\n\n    response = await self.json_rpc_request(\"faucet\", params)\n    return Submission(**response)\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.find_service","title":"<code>find_service(options)</code>  <code>async</code>","text":"<p>Find available services on the Accumulate network using JSON-RPC</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def find_service(self, options: FindServiceOptions) -&gt; List[FindServiceResult]:\n    \"\"\"Find available services on the Accumulate network using JSON-RPC\"\"\"\n    params = options.to_dict()  # Converts to correct JSON-RPC format\n    response = await self.json_rpc_request(\"find-service\", params)\n\n    return [FindServiceResult(\n        peer_id=res.get(\"peer_id\", \"\"),\n        status=res.get(\"status\", \"\"),\n        addresses=res.get(\"addresses\", [])\n    ) for res in response]\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.json_rpc_request","title":"<code>json_rpc_request(method, params=None)</code>  <code>async</code>","text":"<p>Send a JSON-RPC request with an auto-incrementing ID stored persistently.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def json_rpc_request(self, method: str, params: Optional[Dict[str, Any]] = None) -&gt; Dict[str, Any]:\n    \"\"\"Send a JSON-RPC request with an auto-incrementing ID stored persistently.\"\"\"\n    rpc_id = self._id_counter\n    self._id_counter += 1\n    save_counter(self._id_counter)  # Save new counter value\n\n    json_rpc_payload = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": method,\n        \"params\": params or {},\n        \"id\": rpc_id,\n    }\n\n    logger.info(f\"RPC Request: {json_rpc_payload}\")\n\n    try:\n        response = await self.transport.send_request(endpoint=\"v3\", method=\"POST\", data=json_rpc_payload)\n\n        logger.info(f\"RPC Response: {response}\")\n\n        if \"error\" in response:\n            raise AccumulateError(f\"JSON-RPC request failed ({method}): {response['error'].get('message', 'Unknown error')}\")\n\n        return response.get(\"result\", {})\n\n    except Exception as e:\n        logger.error(f\"JSON-RPC request failed ({method}): {e}\")\n        raise AccumulateError(f\"JSON-RPC request failed ({method}): {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.list_snapshots","title":"<code>list_snapshots()</code>  <code>async</code>","text":"<p>List available blockchain snapshots using JSON-RPC</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def list_snapshots(self) -&gt; List[Dict[str, Any]]:\n    \"\"\"List available blockchain snapshots using JSON-RPC\"\"\"\n    return await self.json_rpc_request(\"list-snapshots\")\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.metrics","title":"<code>metrics()</code>  <code>async</code>","text":"<p>Retrieve network metrics such as transactions per second using JSON-RPC</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def metrics(self) -&gt; Dict[str, Any]:\n    \"\"\"Retrieve network metrics such as transactions per second using JSON-RPC\"\"\"\n    return await self.json_rpc_request(\"metrics\")\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.network_status","title":"<code>network_status()</code>  <code>async</code>","text":"<p>Fetch the current network status from the Accumulate blockchain.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: JSON response containing network status details.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def network_status(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetch the current network status from the Accumulate blockchain.\n\n    Returns:\n        Dict[str, Any]: JSON response containing network status details.\n    \"\"\"\n    try:\n        response = await self.json_rpc_request(\"network-status\")\n\n        if not response:\n            logger.error(\"Network status query returned no response.\")\n            raise AccumulateError(\"Network status query failed: No response received.\")\n\n        logger.info(f\"Network Status Response: {response}\")\n        return response\n\n    except Exception as e:\n        logger.error(f\"Failed to fetch network status: {e}\")\n        raise AccumulateError(f\"Network status query failed: {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.query","title":"<code>query(scope, query)</code>  <code>async</code>","text":"<p>Submit a query to the Accumulate network using JSON-RPC.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def query(self, scope: str, query: Query) -&gt; Record:\n    \"\"\"Submit a query to the Accumulate network using JSON-RPC.\"\"\"\n    if not query.is_valid():\n        raise ValueError(\"Invalid query.\")\n\n    # Convert query to dictionary\n    query_dict = query.to_dict()\n    query_dict[\"queryType\"] = query.query_type.to_rpc_format()\n\n    params = {\"scope\": scope, \"query\": query_dict}\n\n    #  DEBUG: Log raw API request\n    logger.debug(f\" Sending Query Request: {params}\")\n\n    response = await self.json_rpc_request(\"query\", params)\n\n    #  DEBUG: Log raw API response\n    logger.debug(f\" Raw API Response: {response} (Type: {type(response)})\")\n\n    #  If response is a string, try parsing it as JSON\n    if isinstance(response, str):\n        try:\n            response = json.loads(response)\n            logger.debug(f\" Decoded String Response: {response}\")\n        except json.JSONDecodeError:\n            raise AccumulateError(f\"API returned an invalid JSON string: {response}\")\n\n    # Ensure response is a dictionary\n    if not isinstance(response, dict):\n        raise AccumulateError(f\"Unexpected API response format: {response} (type: {type(response)})\")\n\n    #  Convert API response keys from camelCase to snake_case\n    response = {camel_to_snake(k): v for k, v in response.items()}\n\n    if \"record_type\" not in response:\n        raise AccumulateError(f\"Unexpected response format: {response}\")\n\n    record_type = response[\"record_type\"]\n\n    #  Ensure consistency with RecordType enum\n    record_mapping = {\n        RecordType.ACCOUNT.name.lower(): AccountRecord,\n        RecordType.CHAIN.name.lower(): ChainRecord,\n        RecordType.MESSAGE.name.lower(): MessageRecord,\n        RecordType.CHAIN_ENTRY.name.lower(): ChainEntryRecord,\n        RecordType.KEY.name.lower(): KeyRecord,\n        RecordType.SIGNATURE_SET.name.lower(): SignatureSetRecord,\n        RecordType.URL.name.lower(): UrlRecord,\n        RecordType.TX_ID.name.lower(): TxIDRecord,\n        RecordType.RANGE.name.lower(): RecordRange,\n        \"directory\": RecordRange,  # Some APIs might return this as 'directory'\n    }\n\n    record_cls = record_mapping.get(record_type, Record)  # Default to Record if unknown\n\n    #  Ensure return type is correct\n    record_obj = record_cls.from_dict(response)\n    logger.debug(f\" Processed Query Response: {record_obj} (Type: {type(record_obj)})\")\n\n    return record_obj  # This should return an object with is_valid()\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.query_block","title":"<code>query_block(block_type, index=None, start=None, count=None)</code>  <code>async</code>","text":"<p>Query a minor or major block.</p> <p>Parameters:</p> Name Type Description Default <code>block_type</code> <code>str</code> <p>Either \"minor\" or \"major\"</p> required <code>index</code> <code>Optional[int]</code> <p>Block index (if querying a specific block)</p> <code>None</code> <code>start</code> <code>Optional[int]</code> <p>Start index for range queries</p> <code>None</code> <code>count</code> <code>Optional[int]</code> <p>Number of blocks to retrieve in range queries</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>JSON response from the API</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def query_block(self, block_type: str, index: Optional[int] = None, start: Optional[int] = None, count: Optional[int] = None) -&gt; dict:\n    \"\"\"\n    Query a minor or major block.\n\n    Args:\n        block_type (str): Either \"minor\" or \"major\"\n        index (Optional[int]): Block index (if querying a specific block)\n        start (Optional[int]): Start index for range queries\n        count (Optional[int]): Number of blocks to retrieve in range queries\n\n    Returns:\n        dict: JSON response from the API\n    \"\"\"\n    if block_type not in [\"minor\", \"major\"]:\n        raise ValueError(\"Invalid block type. Must be 'minor' or 'major'.\")\n\n    params = {}\n\n    if index is not None:\n        #  Query a specific minor or major block\n        url = f\"{self.transport.base_url}/block/{block_type}/{index}\"\n\n        if block_type == \"major\":\n            #  Fetch the first 3 minor blocks within the major block\n            params[\"minor_start\"] = 0\n            params[\"minor_count\"] = 3\n            params[\"omit_empty\"] = True  # Exclude empty minor blocks\n\n    else:\n        #  Query a block range\n        url = f\"{self.transport.base_url}/block/{block_type}\"\n        if start is not None:\n            params[\"start\"] = start\n        if count is not None:\n            params[\"count\"] = count\n\n    logger.info(f\" HTTP Request: GET {url} with params {params}\")\n\n    response = await self.transport.send_request(endpoint=url, method=\"GET\", params=params)\n\n    if not response:\n        logger.error(f\" API request returned no response.\")\n        raise AccumulateError(f\"Block query failed: No response received.\")\n\n    if response.get(\"error\"):\n        logger.error(f\" API request failed: {response['error']}\")\n        raise AccumulateError(f\"Block query failed: {response['error']['message']}\")\n\n    return response\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.search","title":"<code>search(account_id, search_type, value, extra_params=None)</code>  <code>async</code>","text":"<p>Search an account for an anchor, public key, or delegate using JSON-RPC.</p> <p>Parameters:</p> Name Type Description Default <code>account_id</code> <code>str</code> <p>The account ID to search within.</p> required <code>search_type</code> <code>str</code> <p>The type of search. Must be 'anchor', 'publicKey', or 'delegate'.</p> required <code>value</code> <code>str</code> <p>The value to search for (anchor hash, public key, or delegate URL).</p> required <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>Additional query parameters.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>JSON response from the API.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def search(self, account_id: str, search_type: str, value: str, extra_params: Optional[Dict[str, Any]] = None) -&gt; dict:\n    \"\"\"\n    Search an account for an anchor, public key, or delegate using JSON-RPC.\n\n    Args:\n        account_id (str): The account ID to search within.\n        search_type (str): The type of search. Must be 'anchor', 'publicKey', or 'delegate'.\n        value (str): The value to search for (anchor hash, public key, or delegate URL).\n        extra_params (Optional[Dict[str, Any]]): Additional query parameters.\n\n    Returns:\n        dict: JSON response from the API.\n    \"\"\"\n    if search_type not in [\"anchor\", \"publicKey\", \"delegate\"]:\n        raise ValueError(\"Invalid search type. Must be 'anchor', 'publicKey', or 'delegate'.\")\n\n    #  Ensure correct JSON-RPC format\n    params = {\n        \"scope\": account_id,\n        \"query\": {\n            \"queryType\": search_type,\n            \"value\": value\n        }\n    }\n\n    #  Merge optional parameters if provided\n    if extra_params:\n        params[\"query\"].update(extra_params)\n\n    logger.info(f\" RPC Request: {params}\")\n\n    response = await self.json_rpc_request(\"search\", params)\n\n    if not response:\n        logger.error(f\" API request returned no response.\")\n        raise AccumulateError(f\"Search query failed: No response received.\")\n\n    return response\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.submit","title":"<code>submit(envelope, verify=True, wait=True)</code>  <code>async</code>","text":"<p>Submit a transaction to the Accumulate network.</p> <p>Parameters:</p> Name Type Description Default <code>envelope</code> <code>Dict[str, Any]</code> <p>The transaction envelope containing transactions and signatures.</p> required <code>verify</code> <code>bool</code> <p>If True, verifies the envelope before submission. Defaults to True.</p> <code>True</code> <code>wait</code> <code>bool</code> <p>If True, blocks until submission is confirmed or rejected. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The API response containing transaction details.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def submit(self, envelope: Dict[str, Any], verify: bool = True, wait: bool = True) -&gt; Dict[str, Any]:\n    \"\"\"\n    Submit a transaction to the Accumulate network.\n\n    Args:\n        envelope (Dict[str, Any]): The transaction envelope containing transactions and signatures.\n        verify (bool, optional): If True, verifies the envelope before submission. Defaults to True.\n        wait (bool, optional): If True, blocks until submission is confirmed or rejected. Defaults to True.\n\n    Returns:\n        Dict[str, Any]: The API response containing transaction details.\n    \"\"\"\n    if not isinstance(envelope, dict):\n        raise ValueError(\"Envelope must be a dictionary.\")\n\n    #  Ensure the envelope has \"signatures\" (FIRST in order)\n    if \"signatures\" not in envelope or not isinstance(envelope[\"signatures\"], list) or not envelope[\"signatures\"]:\n        raise ValueError(\"Envelope must contain at least one signature in a list.\")\n\n    #  Ensure \"transaction\" is correctly structured (SECOND in order)\n    if \"transaction\" not in envelope or not isinstance(envelope[\"transaction\"], list) or not envelope[\"transaction\"]:\n        raise ValueError(\"Envelope must contain at least one transaction in a list.\")\n\n    #  Validate transaction structure\n    for txn in envelope[\"transaction\"]:\n        if not isinstance(txn, dict):\n            raise ValueError(\"Each transaction must be a dictionary.\")\n\n        if \"header\" not in txn or not isinstance(txn[\"header\"], dict):\n            raise ValueError(\"Each transaction must contain a 'header' as a dictionary.\")\n\n        if \"body\" not in txn or not isinstance(txn[\"body\"], dict):\n            raise ValueError(\"Each transaction must contain a 'body' as a dictionary.\")\n\n        #  Ensure transactionHash (if exists) is properly formatted\n        if \"transactionHash\" in txn and not isinstance(txn[\"transactionHash\"], str):\n            raise ValueError(\"Transaction hash must be a raw hex string.\")\n\n    #  Order envelope fields correctly\n    ordered_envelope = {\n        \"signatures\": envelope[\"signatures\"],  # Signatures First\n        \"transaction\": envelope[\"transaction\"],  # Transactions Second\n    }\n\n    #  Include messages if they exist (LAST in order)\n    if \"messages\" in envelope and isinstance(envelope[\"messages\"], list):\n        ordered_envelope[\"messages\"] = envelope[\"messages\"]\n\n    params = {\n        \"envelope\": ordered_envelope,\n        \"verify\": verify,\n        \"wait\": wait,\n    }\n\n    #  Debugging Before JSON Serialization\n    for sig in envelope[\"signatures\"]:\n        if inspect.iscoroutine(sig):\n            raise RuntimeError(f\" Signature contains an unawaited coroutine: {sig}\")\n\n    json_params = json.dumps(params)  # Convert Python dict to JSON string\n    formatted_params = json.loads(json_params)  # Convert JSON string back to dict (ensures double quotes)\n\n    #  Log the final envelope before submission\n    logger.info(\" Debug: Final Submission Payload\")\n    logger.info(json.dumps(formatted_params, indent=2))\n\n    return await self.json_rpc_request(\"submit\", formatted_params)\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.AccumulateClient.validate","title":"<code>validate(envelope, full=False)</code>  <code>async</code>","text":"<p>Validate a transaction envelope against the Accumulate network using JSON-RPC</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>async def validate(self, envelope: Dict[str, Any], full: bool = False) -&gt; Dict[str, Any]:\n    \"\"\"Validate a transaction envelope against the Accumulate network using JSON-RPC\"\"\"\n    params = {\"envelope\": envelope, \"full\": full}\n    return await self.json_rpc_request(\"validate\", params)\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.load_counter","title":"<code>load_counter()</code>","text":"<p>Load the last used request ID from file or start at 1 if missing.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>def load_counter() -&gt; int:\n    \"\"\"Load the last used request ID from file or start at 1 if missing.\"\"\"\n    if os.path.exists(ID_COUNTER_FILE):\n        with open(ID_COUNTER_FILE, \"r\") as f:\n            return json.load(f).get(\"id\", 1)\n    return 1\n</code></pre>"},{"location":"api_reference/#accumulate.api.client.save_counter","title":"<code>save_counter(counter)</code>","text":"<p>Save the current counter value to the file.</p> Source code in <code>accumulate\\api\\client.py</code> <pre><code>def save_counter(counter: int):\n    \"\"\"Save the current counter value to the file.\"\"\"\n    with open(ID_COUNTER_FILE, \"w\") as f:\n        json.dump({\"id\": counter}, f)\n</code></pre>"},{"location":"api_reference/#api-core-context-transport-querier-exceptions","title":"API Core (Context, Transport, Querier, Exceptions)","text":""},{"location":"api_reference/#accumulate.api.context","title":"<code>context</code>","text":""},{"location":"api_reference/#accumulate.api.context.RequestContext","title":"<code>RequestContext</code>","text":"<p>Represents the context for a request, including metadata and optional cancellation tokens.</p> Source code in <code>accumulate\\api\\context.py</code> <pre><code>class RequestContext:\n    \"\"\"\n    Represents the context for a request, including metadata and optional cancellation tokens.\n    \"\"\"\n\n    def __init__(self, metadata: Dict[str, Any] = None):\n        \"\"\"\n        Initialize the RequestContext with optional metadata.\n        :param metadata: A dictionary containing request-specific metadata.\n        \"\"\"\n        self.metadata = metadata or {}\n\n    def get_metadata(self, key: str) -&gt; Any:\n        \"\"\"\n        Retrieve a value from the context metadata.\n        :param key: Metadata key.\n        :return: Metadata value or None if the key does not exist.\n        \"\"\"\n        return self.metadata.get(key)\n\n    def set_metadata(self, key: str, value: Any):\n        \"\"\"\n        Set a value in the context metadata.\n        :param key: Metadata key.\n        :param value: Metadata value.\n        \"\"\"\n        self.metadata[key] = value\n</code></pre>"},{"location":"api_reference/#accumulate.api.context.RequestContext.__init__","title":"<code>__init__(metadata=None)</code>","text":"<p>Initialize the RequestContext with optional metadata. :param metadata: A dictionary containing request-specific metadata.</p> Source code in <code>accumulate\\api\\context.py</code> <pre><code>def __init__(self, metadata: Dict[str, Any] = None):\n    \"\"\"\n    Initialize the RequestContext with optional metadata.\n    :param metadata: A dictionary containing request-specific metadata.\n    \"\"\"\n    self.metadata = metadata or {}\n</code></pre>"},{"location":"api_reference/#accumulate.api.context.RequestContext.get_metadata","title":"<code>get_metadata(key)</code>","text":"<p>Retrieve a value from the context metadata. :param key: Metadata key. :return: Metadata value or None if the key does not exist.</p> Source code in <code>accumulate\\api\\context.py</code> <pre><code>def get_metadata(self, key: str) -&gt; Any:\n    \"\"\"\n    Retrieve a value from the context metadata.\n    :param key: Metadata key.\n    :return: Metadata value or None if the key does not exist.\n    \"\"\"\n    return self.metadata.get(key)\n</code></pre>"},{"location":"api_reference/#accumulate.api.context.RequestContext.set_metadata","title":"<code>set_metadata(key, value)</code>","text":"<p>Set a value in the context metadata. :param key: Metadata key. :param value: Metadata value.</p> Source code in <code>accumulate\\api\\context.py</code> <pre><code>def set_metadata(self, key: str, value: Any):\n    \"\"\"\n    Set a value in the context metadata.\n    :param key: Metadata key.\n    :param value: Metadata value.\n    \"\"\"\n    self.metadata[key] = value\n</code></pre>"},{"location":"api_reference/#accumulate.api.transport","title":"<code>transport</code>","text":""},{"location":"api_reference/#accumulate.api.transport.RoutedTransport","title":"<code>RoutedTransport</code>","text":"<p>Handles HTTP transport for the Accumulate RPC API.</p> Source code in <code>accumulate\\api\\transport.py</code> <pre><code>class RoutedTransport:\n    \"\"\"Handles HTTP transport for the Accumulate RPC API.\"\"\"\n\n    def __init__(self, base_url: str, timeout: int = 15):\n        \"\"\"\n        Initialize the transport layer.\n\n        Args:\n            base_url (str): The base URL of the Accumulate network (e.g., mainnet or testnet).\n            timeout (int): Request timeout in seconds.\n        \"\"\"\n        self.base_url = base_url\n        self.client = httpx.AsyncClient(base_url=base_url, timeout=timeout)\n\n    async def send_request(\n        self, endpoint: str, method: str = \"GET\", params: Dict[str, Any] = None, data: Dict[str, Any] = None, debug: bool = False\n    ) -&gt; Dict[str, Any]:\n        \"\"\"\n        Print the exact JSON-RPC request without sending it if debug mode is enabled.\n\n        Args:\n            endpoint (str): The API endpoint (e.g., \"query/{scope}\").\n            method (str): The HTTP method (e.g., \"GET\", \"POST\").\n            params (Dict[str, Any], optional): Query parameters for the request.\n            data (Dict[str, Any], optional): JSON body for the request.\n            debug (bool): If True, print the JSON request instead of sending it.\n\n        Returns:\n            Dict[str, Any]: The printed request data as a dictionary.\n\n        Raises:\n            Exception: If the request fails or the response contains an error.\n        \"\"\"\n\n        # Construct the exact JSON-RPC request\n        rpc_request = {\n            \"method\": method,\n            \"url\": f\"{self.base_url}/{endpoint}\",\n            \"params\": params,\n            \"json\": data\n        }\n\n        # If debug mode is enabled, print the JSON and return without sending\n        if debug:\n            formatted_json = json.dumps(rpc_request, indent=4)  # Pretty-print JSON\n            logger.info(f\" RPC Request (Not Sent):\\n{formatted_json}\")\n            return rpc_request  # Return the request object instead of sending\n\n        try:\n            response = await self.client.request(\n                method=method,\n                url=endpoint,\n                params=params,\n                json=data,\n            )\n            response.raise_for_status()\n            return response.json()\n\n        except httpx.RequestError as e:\n            logger.error(f\" Request failed: {e}\")\n            raise Exception(f\"Request failed: {e}\")\n\n        except httpx.HTTPStatusError as e:\n            logger.error(f\" HTTP error {e.response.status_code}: {e.response.text}\")\n            raise Exception(f\"HTTP error: {e.response.status_code} - {e.response.text}\")\n\n        except ValueError as e:\n            logger.error(f\" Invalid JSON response: {e}\")\n            raise Exception(f\"Invalid JSON response: {e}\")\n\n    async def close(self):\n        \"\"\"Close the transport client.\"\"\"\n        await self.client.aclose()\n</code></pre>"},{"location":"api_reference/#accumulate.api.transport.RoutedTransport.__init__","title":"<code>__init__(base_url, timeout=15)</code>","text":"<p>Initialize the transport layer.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>str</code> <p>The base URL of the Accumulate network (e.g., mainnet or testnet).</p> required <code>timeout</code> <code>int</code> <p>Request timeout in seconds.</p> <code>15</code> Source code in <code>accumulate\\api\\transport.py</code> <pre><code>def __init__(self, base_url: str, timeout: int = 15):\n    \"\"\"\n    Initialize the transport layer.\n\n    Args:\n        base_url (str): The base URL of the Accumulate network (e.g., mainnet or testnet).\n        timeout (int): Request timeout in seconds.\n    \"\"\"\n    self.base_url = base_url\n    self.client = httpx.AsyncClient(base_url=base_url, timeout=timeout)\n</code></pre>"},{"location":"api_reference/#accumulate.api.transport.RoutedTransport.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the transport client.</p> Source code in <code>accumulate\\api\\transport.py</code> <pre><code>async def close(self):\n    \"\"\"Close the transport client.\"\"\"\n    await self.client.aclose()\n</code></pre>"},{"location":"api_reference/#accumulate.api.transport.RoutedTransport.send_request","title":"<code>send_request(endpoint, method='GET', params=None, data=None, debug=False)</code>  <code>async</code>","text":"<p>Print the exact JSON-RPC request without sending it if debug mode is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The API endpoint (e.g., \"query/{scope}\").</p> required <code>method</code> <code>str</code> <p>The HTTP method (e.g., \"GET\", \"POST\").</p> <code>'GET'</code> <code>params</code> <code>Dict[str, Any]</code> <p>Query parameters for the request.</p> <code>None</code> <code>data</code> <code>Dict[str, Any]</code> <p>JSON body for the request.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>If True, print the JSON request instead of sending it.</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: The printed request data as a dictionary.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the request fails or the response contains an error.</p> Source code in <code>accumulate\\api\\transport.py</code> <pre><code>async def send_request(\n    self, endpoint: str, method: str = \"GET\", params: Dict[str, Any] = None, data: Dict[str, Any] = None, debug: bool = False\n) -&gt; Dict[str, Any]:\n    \"\"\"\n    Print the exact JSON-RPC request without sending it if debug mode is enabled.\n\n    Args:\n        endpoint (str): The API endpoint (e.g., \"query/{scope}\").\n        method (str): The HTTP method (e.g., \"GET\", \"POST\").\n        params (Dict[str, Any], optional): Query parameters for the request.\n        data (Dict[str, Any], optional): JSON body for the request.\n        debug (bool): If True, print the JSON request instead of sending it.\n\n    Returns:\n        Dict[str, Any]: The printed request data as a dictionary.\n\n    Raises:\n        Exception: If the request fails or the response contains an error.\n    \"\"\"\n\n    # Construct the exact JSON-RPC request\n    rpc_request = {\n        \"method\": method,\n        \"url\": f\"{self.base_url}/{endpoint}\",\n        \"params\": params,\n        \"json\": data\n    }\n\n    # If debug mode is enabled, print the JSON and return without sending\n    if debug:\n        formatted_json = json.dumps(rpc_request, indent=4)  # Pretty-print JSON\n        logger.info(f\" RPC Request (Not Sent):\\n{formatted_json}\")\n        return rpc_request  # Return the request object instead of sending\n\n    try:\n        response = await self.client.request(\n            method=method,\n            url=endpoint,\n            params=params,\n            json=data,\n        )\n        response.raise_for_status()\n        return response.json()\n\n    except httpx.RequestError as e:\n        logger.error(f\" Request failed: {e}\")\n        raise Exception(f\"Request failed: {e}\")\n\n    except httpx.HTTPStatusError as e:\n        logger.error(f\" HTTP error {e.response.status_code}: {e.response.text}\")\n        raise Exception(f\"HTTP error: {e.response.status_code} - {e.response.text}\")\n\n    except ValueError as e:\n        logger.error(f\" Invalid JSON response: {e}\")\n        raise Exception(f\"Invalid JSON response: {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier","title":"<code>querier</code>","text":""},{"location":"api_reference/#accumulate.api.querier.Querier","title":"<code>Querier</code>","text":"<p>Handles queries related to accounts, transactions, records, and events.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>class Querier:\n    \"\"\"Handles queries related to accounts, transactions, records, and events.\"\"\"\n\n    def __init__(self, transport):\n        self.transport = transport\n        self.logger = logging.getLogger(__name__)\n        logging.basicConfig(level=logging.DEBUG)\n\n    async def query(self, ctx: RequestContext, scope: str, query: Query, result_type: Type[T]) -&gt; T:\n        \"\"\"Submit a generic query to the Accumulate network.\"\"\"\n        if not query.is_valid():\n            self.logger.error(\"Invalid query: %s\", query)\n            raise ValueError(\"Invalid query.\")\n\n        message = {\n            \"action\": \"Query\",\n            \"params\": {\"scope\": scope, \"type\": query.query_type.name, \"params\": query.to_dict()},\n        }\n\n        try:\n            self.logger.debug(\"Sending query: %s\", message)\n            response = await self.transport.send_message(ctx, message)\n            self.logger.debug(\"Query response: %s\", response)\n            return self._deserialize_response(response, result_type)\n        except Exception as e:\n            error_message = f\"Query failed: {e}\"\n            self.logger.error(error_message)\n            raise AccumulateError(error_message) from e\n\n    async def query_record(self, ctx: RequestContext, scope: URL, query: Query, result_type: Type[T]) -&gt; T:\n        \"\"\"Submit a query for a specific record type.\"\"\"\n        try:\n            self.logger.debug(\"Querying record for scope: %s, query: %s, result_type: %s\", scope, query, result_type)\n            response = await self.query(ctx, str(scope), query, result_type)  # Pass result_type here\n            self.logger.debug(\"Record query response: %s\", response)\n            return self._deserialize_response(response, result_type)\n        except Exception as e:\n            self.logger.error(\"Error in query_record: %s\", e)\n            raise\n\n    async def query_events(self, ctx: RequestContext, scope: URL, query: Query) -&gt; List[Record]:\n        \"\"\"Query for events.\"\"\"\n        try:\n            self.logger.debug(\"Querying events for scope: %s, query: %s\", scope, query)\n            response = await self.query(ctx, str(scope), query, RecordRange)\n            self.logger.debug(\"Event query response: %s\", response)\n\n            events = []\n            for record in response.records:\n                if not isinstance(record, Record):\n                    raise AccumulateError(f\"Unexpected record type in events: {type(record)}\")\n\n                event_type = record.record_type\n                event_class_path = EVENT_TYPE_MAPPING.get(event_type)\n                if not event_class_path:\n                    # Log and skip unknown event types\n                    self.logger.warning(f\"Skipping unknown event type: {event_type}\")\n                    continue\n\n                # Dynamically resolve the class\n                module_name, class_name = event_class_path.rsplit(\".\", 1)\n                module = importlib.import_module(module_name)\n                event_class = getattr(module, class_name)\n\n                events.append(event_class.from_dict(record.to_dict()))\n\n            return events\n        except Exception as e:\n            error_message = f\"Error in query_events: {e}\"\n            self.logger.error(error_message)\n            raise AccumulateError(error_message) from e\n\n\n    def _deserialize_response(self, data: Any, result_type: Type[T]) -&gt; T:\n        \"\"\"Deserialize a response into the expected result type.\"\"\"\n        try:\n            self.logger.debug(\"Deserializing response: %s into type: %s\", data, result_type)\n\n            if issubclass(result_type, RecordRange):\n                if not isinstance(data, RecordRange):\n                    raise AccumulateError(f\"Expected RecordRange, got {type(data)}\") #\n\n                # Use range_of for validation\n                return range_of(data, getattr(data, \"item_type\", Record))\n\n            if not isinstance(data, result_type):\n                raise AccumulateError(f\"Expected {result_type}, got {type(data)}\")\n            return data\n        except Exception as e:\n            self.logger.error(\"Deserialization failed: %s\", e)\n            raise AccumulateError(f\"Deserialization failed: {e}\")\n\n    async def query_generic(self, ctx: RequestContext, scope: URL, query: Query, result_type: Type[T]) -&gt; T:\n        \"\"\"Generic query handler.\"\"\"\n        response = await self.query(ctx, str(scope), query, result_type)  # Pass result_type here\n        return self._deserialize_response(response, result_type)\n\n    async def query_account(self, ctx: RequestContext, account: URL, query: Query) -&gt; AccountRecord:\n        \"\"\"Query account details.\"\"\"\n        result = await self.query_record(ctx, account, query, AccountRecord) #\n        if not isinstance(result, AccountRecord): #\n            raise AccumulateError(f\"Unexpected response type: {type(result)} (expected AccountRecord)\") #\n        return result #\n\n    async def query_chain(self, ctx: RequestContext, scope: URL, query: Query) -&gt; ChainRecord:\n        \"\"\"Query chain details.\"\"\"\n        result = await self.query_record(ctx, scope, query, ChainRecord)\n        if not isinstance(result, ChainRecord):\n            raise AccumulateError(f\"Unexpected response type: {type(result)} (expected ChainRecord)\") #\n        return result\n\n    async def query_chain_entries(self, ctx: RequestContext, scope: URL, query: Query) -&gt; RecordRange[ChainEntryRecord]:\n        \"\"\"Query chain entries.\"\"\"\n        result = await self.query_record(ctx, scope, query, RecordRange)\n        if not isinstance(result, RecordRange) or not all(isinstance(r, ChainEntryRecord) for r in result.records):\n            raise AccumulateError(f\"Unexpected response type: {type(result)} or invalid nested types\") #\n        return result\n\n    async def query_transaction(self, ctx: RequestContext, txid: URL, query: Query) -&gt; MessageRecord:\n        \"\"\"Query transaction details.\"\"\"\n        self.logger.debug(\"Querying transaction for: %s with query: %s\", txid, query) #\n        result = await self.query_record(ctx, txid, query, MessageRecord) #\n        if not isinstance(result, MessageRecord): #\n            raise AccumulateError(f\"Unexpected response type: {type(result)} (expected MessageRecord)\") #\n        return result #\n\n\n    async def query_block(self, ctx: RequestContext, scope: URL, query: Query) -&gt; RecordRange:\n        \"\"\"Query block details.\"\"\"\n        self.logger.debug(\"Querying block for: %s with query: %s\", scope, query) #\n        result = await self.query_record(ctx, scope, query, RecordRange) #\n        if not isinstance(result, RecordRange): #\n            raise AccumulateError(f\"Unexpected response type: {type(result)} (expected RecordRange)\") #\n        return result\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier._deserialize_response","title":"<code>_deserialize_response(data, result_type)</code>","text":"<p>Deserialize a response into the expected result type.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>def _deserialize_response(self, data: Any, result_type: Type[T]) -&gt; T:\n    \"\"\"Deserialize a response into the expected result type.\"\"\"\n    try:\n        self.logger.debug(\"Deserializing response: %s into type: %s\", data, result_type)\n\n        if issubclass(result_type, RecordRange):\n            if not isinstance(data, RecordRange):\n                raise AccumulateError(f\"Expected RecordRange, got {type(data)}\") #\n\n            # Use range_of for validation\n            return range_of(data, getattr(data, \"item_type\", Record))\n\n        if not isinstance(data, result_type):\n            raise AccumulateError(f\"Expected {result_type}, got {type(data)}\")\n        return data\n    except Exception as e:\n        self.logger.error(\"Deserialization failed: %s\", e)\n        raise AccumulateError(f\"Deserialization failed: {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query","title":"<code>query(ctx, scope, query, result_type)</code>  <code>async</code>","text":"<p>Submit a generic query to the Accumulate network.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query(self, ctx: RequestContext, scope: str, query: Query, result_type: Type[T]) -&gt; T:\n    \"\"\"Submit a generic query to the Accumulate network.\"\"\"\n    if not query.is_valid():\n        self.logger.error(\"Invalid query: %s\", query)\n        raise ValueError(\"Invalid query.\")\n\n    message = {\n        \"action\": \"Query\",\n        \"params\": {\"scope\": scope, \"type\": query.query_type.name, \"params\": query.to_dict()},\n    }\n\n    try:\n        self.logger.debug(\"Sending query: %s\", message)\n        response = await self.transport.send_message(ctx, message)\n        self.logger.debug(\"Query response: %s\", response)\n        return self._deserialize_response(response, result_type)\n    except Exception as e:\n        error_message = f\"Query failed: {e}\"\n        self.logger.error(error_message)\n        raise AccumulateError(error_message) from e\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_account","title":"<code>query_account(ctx, account, query)</code>  <code>async</code>","text":"<p>Query account details.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_account(self, ctx: RequestContext, account: URL, query: Query) -&gt; AccountRecord:\n    \"\"\"Query account details.\"\"\"\n    result = await self.query_record(ctx, account, query, AccountRecord) #\n    if not isinstance(result, AccountRecord): #\n        raise AccumulateError(f\"Unexpected response type: {type(result)} (expected AccountRecord)\") #\n    return result #\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_block","title":"<code>query_block(ctx, scope, query)</code>  <code>async</code>","text":"<p>Query block details.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_block(self, ctx: RequestContext, scope: URL, query: Query) -&gt; RecordRange:\n    \"\"\"Query block details.\"\"\"\n    self.logger.debug(\"Querying block for: %s with query: %s\", scope, query) #\n    result = await self.query_record(ctx, scope, query, RecordRange) #\n    if not isinstance(result, RecordRange): #\n        raise AccumulateError(f\"Unexpected response type: {type(result)} (expected RecordRange)\") #\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_chain","title":"<code>query_chain(ctx, scope, query)</code>  <code>async</code>","text":"<p>Query chain details.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_chain(self, ctx: RequestContext, scope: URL, query: Query) -&gt; ChainRecord:\n    \"\"\"Query chain details.\"\"\"\n    result = await self.query_record(ctx, scope, query, ChainRecord)\n    if not isinstance(result, ChainRecord):\n        raise AccumulateError(f\"Unexpected response type: {type(result)} (expected ChainRecord)\") #\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_chain_entries","title":"<code>query_chain_entries(ctx, scope, query)</code>  <code>async</code>","text":"<p>Query chain entries.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_chain_entries(self, ctx: RequestContext, scope: URL, query: Query) -&gt; RecordRange[ChainEntryRecord]:\n    \"\"\"Query chain entries.\"\"\"\n    result = await self.query_record(ctx, scope, query, RecordRange)\n    if not isinstance(result, RecordRange) or not all(isinstance(r, ChainEntryRecord) for r in result.records):\n        raise AccumulateError(f\"Unexpected response type: {type(result)} or invalid nested types\") #\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_events","title":"<code>query_events(ctx, scope, query)</code>  <code>async</code>","text":"<p>Query for events.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_events(self, ctx: RequestContext, scope: URL, query: Query) -&gt; List[Record]:\n    \"\"\"Query for events.\"\"\"\n    try:\n        self.logger.debug(\"Querying events for scope: %s, query: %s\", scope, query)\n        response = await self.query(ctx, str(scope), query, RecordRange)\n        self.logger.debug(\"Event query response: %s\", response)\n\n        events = []\n        for record in response.records:\n            if not isinstance(record, Record):\n                raise AccumulateError(f\"Unexpected record type in events: {type(record)}\")\n\n            event_type = record.record_type\n            event_class_path = EVENT_TYPE_MAPPING.get(event_type)\n            if not event_class_path:\n                # Log and skip unknown event types\n                self.logger.warning(f\"Skipping unknown event type: {event_type}\")\n                continue\n\n            # Dynamically resolve the class\n            module_name, class_name = event_class_path.rsplit(\".\", 1)\n            module = importlib.import_module(module_name)\n            event_class = getattr(module, class_name)\n\n            events.append(event_class.from_dict(record.to_dict()))\n\n        return events\n    except Exception as e:\n        error_message = f\"Error in query_events: {e}\"\n        self.logger.error(error_message)\n        raise AccumulateError(error_message) from e\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_generic","title":"<code>query_generic(ctx, scope, query, result_type)</code>  <code>async</code>","text":"<p>Generic query handler.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_generic(self, ctx: RequestContext, scope: URL, query: Query, result_type: Type[T]) -&gt; T:\n    \"\"\"Generic query handler.\"\"\"\n    response = await self.query(ctx, str(scope), query, result_type)  # Pass result_type here\n    return self._deserialize_response(response, result_type)\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_record","title":"<code>query_record(ctx, scope, query, result_type)</code>  <code>async</code>","text":"<p>Submit a query for a specific record type.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_record(self, ctx: RequestContext, scope: URL, query: Query, result_type: Type[T]) -&gt; T:\n    \"\"\"Submit a query for a specific record type.\"\"\"\n    try:\n        self.logger.debug(\"Querying record for scope: %s, query: %s, result_type: %s\", scope, query, result_type)\n        response = await self.query(ctx, str(scope), query, result_type)  # Pass result_type here\n        self.logger.debug(\"Record query response: %s\", response)\n        return self._deserialize_response(response, result_type)\n    except Exception as e:\n        self.logger.error(\"Error in query_record: %s\", e)\n        raise\n</code></pre>"},{"location":"api_reference/#accumulate.api.querier.Querier.query_transaction","title":"<code>query_transaction(ctx, txid, query)</code>  <code>async</code>","text":"<p>Query transaction details.</p> Source code in <code>accumulate\\api\\querier.py</code> <pre><code>async def query_transaction(self, ctx: RequestContext, txid: URL, query: Query) -&gt; MessageRecord:\n    \"\"\"Query transaction details.\"\"\"\n    self.logger.debug(\"Querying transaction for: %s with query: %s\", txid, query) #\n    result = await self.query_record(ctx, txid, query, MessageRecord) #\n    if not isinstance(result, MessageRecord): #\n        raise AccumulateError(f\"Unexpected response type: {type(result)} (expected MessageRecord)\") #\n    return result #\n</code></pre>"},{"location":"api_reference/#accumulate.api.exceptions","title":"<code>exceptions</code>","text":""},{"location":"api_reference/#accumulate.api.exceptions.AccumulateError","title":"<code>AccumulateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all custom exceptions in the Accumulate client.</p> Source code in <code>accumulate\\api\\exceptions.py</code> <pre><code>class AccumulateError(Exception):\n    \"\"\"Base class for all custom exceptions in the Accumulate client.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.api.exceptions.FaucetError","title":"<code>FaucetError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Raised when faucet token requests fail.</p> Source code in <code>accumulate\\api\\exceptions.py</code> <pre><code>class FaucetError(AccumulateError):\n    \"\"\"Raised when faucet token requests fail.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.api.exceptions.QueryError","title":"<code>QueryError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Raised when a query to the RPC API fails.</p> Source code in <code>accumulate\\api\\exceptions.py</code> <pre><code>class QueryError(AccumulateError):\n    \"\"\"Raised when a query to the RPC API fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.api.exceptions.SubmissionError","title":"<code>SubmissionError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Raised when a transaction submission fails.</p> Source code in <code>accumulate\\api\\exceptions.py</code> <pre><code>class SubmissionError(AccumulateError):\n    \"\"\"Raised when a transaction submission fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.api.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Raised when validation fails.</p> Source code in <code>accumulate\\api\\exceptions.py</code> <pre><code>class ValidationError(AccumulateError):\n    \"\"\"Raised when validation fails.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#transactions-models","title":"Transactions (Models)","text":""},{"location":"api_reference/#accumulate.models.transactions","title":"<code>transactions</code>","text":""},{"location":"api_reference/#accumulate.models.transactions.AddCredits","title":"<code>AddCredits</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents an AddCredits transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class AddCredits(TransactionBodyBase):\n    \"\"\"\n    Represents an AddCredits transaction.\n    \"\"\"\n\n    def __init__(self, client, recipient: Union[str, \"URL\"], amount: int):\n        \"\"\"\n        :param client: Instance of AccumulateClient (can be None when unmarshaling)\n        :param recipient: The URL of the account receiving the credits.\n        :param amount: The amount of credits to add (in whole credits; this will be multiplied by 1e6).\n        \"\"\"\n        self.client = client\n        self.oracle = None  # Oracle price will be fetched asynchronously\n        self.recipient = self._normalize_recipient(str(recipient))\n        self.amount = amount * 2_000_000  # Store amount in microcredits\n\n    async def initialize_oracle(self):\n        \"\"\"Fetch and set the oracle price asynchronously from network status.\"\"\"\n        try:\n            status = await self.client.network_status()\n            self.oracle = int(status.get(\"oracle\", {}).get(\"price\", 5000))\n        except Exception as e:\n            logger.error(f\"Failed to fetch oracle price: {e}\")\n            self.oracle = 5000 \n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.ADD_CREDITS\n\n    def fields_to_encode(self):\n        \"\"\"Returns the fields to be marshaled.\"\"\"\n        return [\n            (1, b'\\x0E', lambda x: x),  # Type marker\n            (2, self.recipient.encode(\"utf-8\"), lambda x: encode_uvarint(len(x)) + x),  # Recipient\n            (3, self.amount, encode_compact_int),  # Amount\n            (4, self.oracle if self.oracle is not None else 0, encode_uvarint),  # Oracle price\n        ]\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert AddCredits transaction to a dictionary.\"\"\"\n        return {\n            **super().to_dict(),\n            \"recipient\": self.recipient,\n            \"amount\": str(self.amount),\n            \"oracle\": self.oracle if self.oracle is not None else 0\n        }\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"AddCredits\":\n        \"\"\"Deserialize an AddCredits transaction from bytes.\"\"\"\n        reader = io.BytesIO(data)\n\n        # Field 1: Type marker\n        field_id = reader.read(1)\n        if field_id != b'\\x01':\n            raise ValueError(\"Expected field id 1 for type marker\")\n        type_marker = reader.read(1)\n        if type_marker != b'\\x0E':\n            raise ValueError(\"Invalid type marker for AddCredits\")\n\n        # Field 2: Recipient\n        field_id = reader.read(1)\n        if field_id != b'\\x02':\n            raise ValueError(\"Expected field id 2 for recipient\")\n        rec_length = read_uvarint(reader)\n        recipient_bytes = reader.read(rec_length)\n        recipient = recipient_bytes.decode(\"utf-8\")\n\n        # Field 3: Amount (compact int)\n        field_id = reader.read(1)\n        if field_id != b'\\x03':\n            raise ValueError(\"Expected field id 3 for amount\")\n        num_bytes_raw = reader.read(1)\n        if not num_bytes_raw:\n            raise ValueError(\"Missing compact int length for amount\")\n        num_bytes = num_bytes_raw[0]\n        amount_bytes = reader.read(num_bytes)\n        amount = int.from_bytes(amount_bytes, byteorder='big')\n\n        # Field 4: Oracle\n        field_id = reader.read(1)\n        if field_id != b'\\x04':\n            raise ValueError(\"Expected field id 4 for oracle\")\n        oracle_adjusted = read_uvarint(reader)\n        oracle = oracle_adjusted // 100\n\n        # Create instance; note that original amount was multiplied by 2e6\n        obj = cls(None, recipient, amount // 2_000_000)\n        obj.oracle = oracle\n        return obj\n\n    @staticmethod\n    def _normalize_recipient(recipient: str) -&gt; str:\n        \"\"\"\n        Ensure the recipient is formatted correctly.\n        It must start with \"acc://\", not include \".MAIN\", and end with \"/acme\" (all lowercase).\n        \"\"\"\n        recipient = recipient.lower().strip(\"/\")\n        if recipient.startswith(\"acc://\"):\n            recipient = recipient[6:]\n        if not recipient.endswith(\"/acme\"):\n            recipient += \"/acme\"\n        return f\"acc://{recipient}\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.AddCredits.__init__","title":"<code>__init__(client, recipient, amount)</code>","text":"<p>:param client: Instance of AccumulateClient (can be None when unmarshaling) :param recipient: The URL of the account receiving the credits. :param amount: The amount of credits to add (in whole credits; this will be multiplied by 1e6).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, client, recipient: Union[str, \"URL\"], amount: int):\n    \"\"\"\n    :param client: Instance of AccumulateClient (can be None when unmarshaling)\n    :param recipient: The URL of the account receiving the credits.\n    :param amount: The amount of credits to add (in whole credits; this will be multiplied by 1e6).\n    \"\"\"\n    self.client = client\n    self.oracle = None  # Oracle price will be fetched asynchronously\n    self.recipient = self._normalize_recipient(str(recipient))\n    self.amount = amount * 2_000_000  # Store amount in microcredits\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.AddCredits._normalize_recipient","title":"<code>_normalize_recipient(recipient)</code>  <code>staticmethod</code>","text":"<p>Ensure the recipient is formatted correctly. It must start with \"acc://\", not include \".MAIN\", and end with \"/acme\" (all lowercase).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef _normalize_recipient(recipient: str) -&gt; str:\n    \"\"\"\n    Ensure the recipient is formatted correctly.\n    It must start with \"acc://\", not include \".MAIN\", and end with \"/acme\" (all lowercase).\n    \"\"\"\n    recipient = recipient.lower().strip(\"/\")\n    if recipient.startswith(\"acc://\"):\n        recipient = recipient[6:]\n    if not recipient.endswith(\"/acme\"):\n        recipient += \"/acme\"\n    return f\"acc://{recipient}\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.AddCredits.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Returns the fields to be marshaled.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"Returns the fields to be marshaled.\"\"\"\n    return [\n        (1, b'\\x0E', lambda x: x),  # Type marker\n        (2, self.recipient.encode(\"utf-8\"), lambda x: encode_uvarint(len(x)) + x),  # Recipient\n        (3, self.amount, encode_compact_int),  # Amount\n        (4, self.oracle if self.oracle is not None else 0, encode_uvarint),  # Oracle price\n    ]\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.AddCredits.initialize_oracle","title":"<code>initialize_oracle()</code>  <code>async</code>","text":"<p>Fetch and set the oracle price asynchronously from network status.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>async def initialize_oracle(self):\n    \"\"\"Fetch and set the oracle price asynchronously from network status.\"\"\"\n    try:\n        status = await self.client.network_status()\n        self.oracle = int(status.get(\"oracle\", {}).get(\"price\", 5000))\n    except Exception as e:\n        logger.error(f\"Failed to fetch oracle price: {e}\")\n        self.oracle = 5000 \n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.AddCredits.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert AddCredits transaction to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert AddCredits transaction to a dictionary.\"\"\"\n    return {\n        **super().to_dict(),\n        \"recipient\": self.recipient,\n        \"amount\": str(self.amount),\n        \"oracle\": self.oracle if self.oracle is not None else 0\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.AddCredits.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize an AddCredits transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"AddCredits\":\n    \"\"\"Deserialize an AddCredits transaction from bytes.\"\"\"\n    reader = io.BytesIO(data)\n\n    # Field 1: Type marker\n    field_id = reader.read(1)\n    if field_id != b'\\x01':\n        raise ValueError(\"Expected field id 1 for type marker\")\n    type_marker = reader.read(1)\n    if type_marker != b'\\x0E':\n        raise ValueError(\"Invalid type marker for AddCredits\")\n\n    # Field 2: Recipient\n    field_id = reader.read(1)\n    if field_id != b'\\x02':\n        raise ValueError(\"Expected field id 2 for recipient\")\n    rec_length = read_uvarint(reader)\n    recipient_bytes = reader.read(rec_length)\n    recipient = recipient_bytes.decode(\"utf-8\")\n\n    # Field 3: Amount (compact int)\n    field_id = reader.read(1)\n    if field_id != b'\\x03':\n        raise ValueError(\"Expected field id 3 for amount\")\n    num_bytes_raw = reader.read(1)\n    if not num_bytes_raw:\n        raise ValueError(\"Missing compact int length for amount\")\n    num_bytes = num_bytes_raw[0]\n    amount_bytes = reader.read(num_bytes)\n    amount = int.from_bytes(amount_bytes, byteorder='big')\n\n    # Field 4: Oracle\n    field_id = reader.read(1)\n    if field_id != b'\\x04':\n        raise ValueError(\"Expected field id 4 for oracle\")\n    oracle_adjusted = read_uvarint(reader)\n    oracle = oracle_adjusted // 100\n\n    # Create instance; note that original amount was multiplied by 2e6\n    obj = cls(None, recipient, amount // 2_000_000)\n    obj.oracle = oracle\n    return obj\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens","title":"<code>BurnTokens</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Burn Tokens transaction. This class accepts a provided-readable burn amount and then dynamically queries the blockchain to obtain the token's precision. It then calculates the final on-chain amount to burn.</p> <p>The token account URL is provided, and from it the token issuer URL is obtained.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class BurnTokens(TransactionBodyBase):\n    \"\"\"\n    Represents a Burn Tokens transaction.\n    This class accepts a provided-readable burn amount and then dynamically queries\n    the blockchain to obtain the token's precision. It then calculates the final\n    on-chain amount to burn.\n\n    The token account URL is provided, and from it the token issuer URL is obtained.\n    \"\"\"\n\n    def __init__(self, token_account_url: URL, provided_amount: int):\n        \"\"\"\n        :param token_account_url: The URL of the token account (e.g., acc://.../CTACUST).\n        :param provided_amount: The provided-readable number of tokens to burn.\n        \"\"\"\n        if not isinstance(token_account_url, URL):\n            raise TypeError(\"token_account_url must be an instance of URL.\")\n        if not isinstance(provided_amount, int) or provided_amount &lt;= 0:\n            raise ValueError(\"provided_amount must be a positive integer.\")\n        self.token_account_url = token_account_url\n        self.provided_amount = provided_amount\n        # These will be set dynamically via initialize()\n        self.precision = None  \n        self.amount = None  # Final on-chain amount = provided_amount * (10 ** precision)\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.BURN_TOKENS\n\n    async def initialize(self, client):\n        \"\"\"\n        Dynamically query the token account and token issuer to obtain the token's precision,\n        then calculate the final on-chain burn amount.\n        \"\"\"\n        # Use the Query object as in your working example.\n        from accumulate.models.queries import Query\n        from accumulate.models.enums import QueryType\n        query = Query(query_type=QueryType.DEFAULT)\n\n        # Query the token account to get the token issuer URL.\n        token_account_response = await client.query(str(self.token_account_url), query)\n        token_issuer_url_str = token_account_response.account.get(\"tokenUrl\")\n        if not token_issuer_url_str:\n            raise ValueError(\"Token account did not return a tokenUrl\")\n        token_issuer_url = URL.parse(token_issuer_url_str)\n\n        # Query the token issuer to obtain the token's precision.\n        token_issuer_response = await client.query(str(token_issuer_url), query)\n        precision = token_issuer_response.account.get(\"precision\")\n        if precision is None:\n            raise ValueError(\"Token issuer did not return a precision value\")\n        self.precision = int(precision)\n\n        # Calculate the final on-chain amount.\n        self.amount = self.provided_amount * (10 ** self.precision)\n\n    def _encode_amount(self) -&gt; bytes:\n        \"\"\"\n        Encodes the final amount as a raw big-endian number.\n        For example, if the final amount is 110000, then:\n          big_number_marshal_binary(110000) should yield its minimal big-endian representation.\n        \"\"\"\n        if self.amount is None:\n            raise ValueError(\"BurnTokens instance is not initialized. Call initialize(client) first.\")\n        return big_number_marshal_binary(self.amount)\n\n    def fields_to_encode(self):\n        \"\"\"\n        Fields for BurnTokens:\n          - Field 1: Transaction type (encoded as varint)\n          - Field 2: Amount (encoded as a length-delimited big-endian number)\n\n         NOTE: The token URL is NOT included in the encoded body.\n        \"\"\"\n        return [\n            (1, encode_uvarint(self.type().value), lambda x: x),\n            (2, self._encode_amount(), lambda x: x),\n        ]\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"BurnTokens\":\n        \"\"\"\n        Deserialize BurnTokens transaction from bytes.\n        (Since precision is not encoded, the returned instance will have token_account_url set to None.)\n        \"\"\"\n        reader = io.BytesIO(data)\n        transaction_type, _ = decode_uvarint(reader.read())\n        if transaction_type != TransactionType.BURN_TOKENS.value:\n            raise ValueError(\"Unexpected transaction type\")\n        amount_bytes = unmarshal_bytes(reader)\n        final_amount = int.from_bytes(amount_bytes, byteorder='big')\n        instance = cls(None, final_amount)  # token_account_url is unknown from the body\n        instance.precision = 0  # unknown precision\n        instance.amount = final_amount\n        instance.provided_amount = final_amount  # fallback\n        return instance\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the BurnTokens transaction to a JSON-serializable dictionary.\n        (Note: the token URL is not included in the output JSON.)\n        \"\"\"\n        return {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"amount\": str(self.amount) if self.amount is not None else None,\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens.__init__","title":"<code>__init__(token_account_url, provided_amount)</code>","text":"<p>:param token_account_url: The URL of the token account (e.g., acc://.../CTACUST). :param provided_amount: The provided-readable number of tokens to burn.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, token_account_url: URL, provided_amount: int):\n    \"\"\"\n    :param token_account_url: The URL of the token account (e.g., acc://.../CTACUST).\n    :param provided_amount: The provided-readable number of tokens to burn.\n    \"\"\"\n    if not isinstance(token_account_url, URL):\n        raise TypeError(\"token_account_url must be an instance of URL.\")\n    if not isinstance(provided_amount, int) or provided_amount &lt;= 0:\n        raise ValueError(\"provided_amount must be a positive integer.\")\n    self.token_account_url = token_account_url\n    self.provided_amount = provided_amount\n    # These will be set dynamically via initialize()\n    self.precision = None  \n    self.amount = None  # Final on-chain amount = provided_amount * (10 ** precision)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens._encode_amount","title":"<code>_encode_amount()</code>","text":"<p>Encodes the final amount as a raw big-endian number. For example, if the final amount is 110000, then:   big_number_marshal_binary(110000) should yield its minimal big-endian representation.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def _encode_amount(self) -&gt; bytes:\n    \"\"\"\n    Encodes the final amount as a raw big-endian number.\n    For example, if the final amount is 110000, then:\n      big_number_marshal_binary(110000) should yield its minimal big-endian representation.\n    \"\"\"\n    if self.amount is None:\n        raise ValueError(\"BurnTokens instance is not initialized. Call initialize(client) first.\")\n    return big_number_marshal_binary(self.amount)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"Fields for BurnTokens <ul> <li>Field 1: Transaction type (encoded as varint)</li> <li>Field 2: Amount (encoded as a length-delimited big-endian number)</li> </ul> <p>NOTE: The token URL is NOT included in the encoded body.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Fields for BurnTokens:\n      - Field 1: Transaction type (encoded as varint)\n      - Field 2: Amount (encoded as a length-delimited big-endian number)\n\n     NOTE: The token URL is NOT included in the encoded body.\n    \"\"\"\n    return [\n        (1, encode_uvarint(self.type().value), lambda x: x),\n        (2, self._encode_amount(), lambda x: x),\n    ]\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens.initialize","title":"<code>initialize(client)</code>  <code>async</code>","text":"<p>Dynamically query the token account and token issuer to obtain the token's precision, then calculate the final on-chain burn amount.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>async def initialize(self, client):\n    \"\"\"\n    Dynamically query the token account and token issuer to obtain the token's precision,\n    then calculate the final on-chain burn amount.\n    \"\"\"\n    # Use the Query object as in your working example.\n    from accumulate.models.queries import Query\n    from accumulate.models.enums import QueryType\n    query = Query(query_type=QueryType.DEFAULT)\n\n    # Query the token account to get the token issuer URL.\n    token_account_response = await client.query(str(self.token_account_url), query)\n    token_issuer_url_str = token_account_response.account.get(\"tokenUrl\")\n    if not token_issuer_url_str:\n        raise ValueError(\"Token account did not return a tokenUrl\")\n    token_issuer_url = URL.parse(token_issuer_url_str)\n\n    # Query the token issuer to obtain the token's precision.\n    token_issuer_response = await client.query(str(token_issuer_url), query)\n    precision = token_issuer_response.account.get(\"precision\")\n    if precision is None:\n        raise ValueError(\"Token issuer did not return a precision value\")\n    self.precision = int(precision)\n\n    # Calculate the final on-chain amount.\n    self.amount = self.provided_amount * (10 ** self.precision)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the BurnTokens transaction to a JSON-serializable dictionary. (Note: the token URL is not included in the output JSON.)</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the BurnTokens transaction to a JSON-serializable dictionary.\n    (Note: the token URL is not included in the output JSON.)\n    \"\"\"\n    return {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"amount\": str(self.amount) if self.amount is not None else None,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.BurnTokens.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize BurnTokens transaction from bytes. (Since precision is not encoded, the returned instance will have token_account_url set to None.)</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"BurnTokens\":\n    \"\"\"\n    Deserialize BurnTokens transaction from bytes.\n    (Since precision is not encoded, the returned instance will have token_account_url set to None.)\n    \"\"\"\n    reader = io.BytesIO(data)\n    transaction_type, _ = decode_uvarint(reader.read())\n    if transaction_type != TransactionType.BURN_TOKENS.value:\n        raise ValueError(\"Unexpected transaction type\")\n    amount_bytes = unmarshal_bytes(reader)\n    final_amount = int.from_bytes(amount_bytes, byteorder='big')\n    instance = cls(None, final_amount)  # token_account_url is unknown from the body\n    instance.precision = 0  # unknown precision\n    instance.amount = final_amount\n    instance.provided_amount = final_amount  # fallback\n    return instance\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateDataAccount","title":"<code>CreateDataAccount</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Create Data Account transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class CreateDataAccount(TransactionBodyBase):\n    \"\"\"\n    Represents a Create Data Account transaction.\n    \"\"\"\n\n    def __init__(self, url: URL, authorities: Optional[List[URL]] = None, metadata: Optional[bytes] = None):\n        \"\"\"\n        :param url: The URL of the data account.\n        :param authorities: List of authority URLs (optional).\n        :param metadata: Optional metadata as bytes (optional).\n        \"\"\"\n        if not isinstance(url, URL):\n            raise TypeError(\"url must be an instance of URL.\")\n        if not url.authority or not url.path:\n            raise ValueError(f\"Invalid URL: {url}\")\n\n        #  Only set authorities if they exist\n        self.authorities = authorities if authorities else None  \n        self.url = url\n        self.metadata = metadata if metadata else None  #  Only set metadata if provided\n\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return transaction type.\"\"\"\n        return TransactionType.CREATE_DATA_ACCOUNT\n\n    def fields_to_encode(self):\n        \"\"\"\n        Returns the fields to encode as a list of (field_id, value, encoding_function).\n        \"\"\"\n        fields = [\n            #  encode type field first\n            (1, encode_uvarint(self.type().value), lambda x: x),  \n\n            #  encode URL without double length prefix\n            (2, string_marshal_binary(str(self.url)), lambda x: x),  \n        ]\n\n        #  Include authorities **only if they exist**\n        if self.authorities:\n            authorities_encoded = b\"\".join([\n                string_marshal_binary(str(auth))\n                for auth in self.authorities\n            ])\n            fields.append((3, encode_uvarint(len(self.authorities)) + authorities_encoded, lambda x: x))  \n\n        #  Include metadata **only if it exists**\n        if self.metadata:\n            fields.append((4, bytes_marshal_binary(self.metadata), lambda x: x))  \n\n        return fields\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreateDataAccount\":\n        \"\"\"Deserialize CreateDataAccount transaction from bytes.\"\"\"\n        print(f\"DEBUG: Unmarshaling CreateDataAccount\")\n\n        reader = io.BytesIO(data)\n\n        #  Step 1: Parse Type Field\n        type_value = read_uvarint(reader)\n\n        #  Step 2: Parse URL (Read as a string)\n        url = unmarshal_string(reader)\n\n        #  Step 3: Parse Authorities (If present)\n        authorities = []\n        if reader.peek(1)[:1] == b'\\x03':  # Check if Authorities field exists\n            reader.read(1)  # Consume field identifier\n            authorities_count = read_uvarint(reader)\n            for _ in range(authorities_count):\n                auth_str = unmarshal_string(reader)\n                authorities.append(URL.parse(auth_str))\n\n        #  Step 4: Parse Metadata (If present)\n        metadata = None\n        if reader.peek(1)[:1] == b'\\x04':  # Check if Metadata field exists\n            reader.read(1)  # Consume field identifier\n            metadata = unmarshal_bytes(reader)\n\n        print(f\"DEBUG: Parsed CreateDataAccount: Type={type_value}, URL={url}, Authorities={authorities}, Metadata={metadata}\")\n        return cls(URL.parse(url), authorities if authorities else None, metadata)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert CreateDataAccount transaction to a dictionary.\"\"\"\n        tx_dict = {\n            **super().to_dict(),\n            \"url\": str(self.url),\n        }\n\n        #  **Only add authorities if they exist**\n        if self.authorities:\n            tx_dict[\"authorities\"] = [str(auth) for auth in self.authorities]\n\n        #  **Only add metadata if it exists**\n        if self.metadata:\n            tx_dict[\"metadata\"] = self.metadata.hex()\n\n        return tx_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateDataAccount.__init__","title":"<code>__init__(url, authorities=None, metadata=None)</code>","text":"<p>:param url: The URL of the data account. :param authorities: List of authority URLs (optional). :param metadata: Optional metadata as bytes (optional).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, url: URL, authorities: Optional[List[URL]] = None, metadata: Optional[bytes] = None):\n    \"\"\"\n    :param url: The URL of the data account.\n    :param authorities: List of authority URLs (optional).\n    :param metadata: Optional metadata as bytes (optional).\n    \"\"\"\n    if not isinstance(url, URL):\n        raise TypeError(\"url must be an instance of URL.\")\n    if not url.authority or not url.path:\n        raise ValueError(f\"Invalid URL: {url}\")\n\n    #  Only set authorities if they exist\n    self.authorities = authorities if authorities else None  \n    self.url = url\n    self.metadata = metadata if metadata else None  #  Only set metadata if provided\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateDataAccount.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Returns the fields to encode as a list of (field_id, value, encoding_function).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Returns the fields to encode as a list of (field_id, value, encoding_function).\n    \"\"\"\n    fields = [\n        #  encode type field first\n        (1, encode_uvarint(self.type().value), lambda x: x),  \n\n        #  encode URL without double length prefix\n        (2, string_marshal_binary(str(self.url)), lambda x: x),  \n    ]\n\n    #  Include authorities **only if they exist**\n    if self.authorities:\n        authorities_encoded = b\"\".join([\n            string_marshal_binary(str(auth))\n            for auth in self.authorities\n        ])\n        fields.append((3, encode_uvarint(len(self.authorities)) + authorities_encoded, lambda x: x))  \n\n    #  Include metadata **only if it exists**\n    if self.metadata:\n        fields.append((4, bytes_marshal_binary(self.metadata), lambda x: x))  \n\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateDataAccount.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert CreateDataAccount transaction to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert CreateDataAccount transaction to a dictionary.\"\"\"\n    tx_dict = {\n        **super().to_dict(),\n        \"url\": str(self.url),\n    }\n\n    #  **Only add authorities if they exist**\n    if self.authorities:\n        tx_dict[\"authorities\"] = [str(auth) for auth in self.authorities]\n\n    #  **Only add metadata if it exists**\n    if self.metadata:\n        tx_dict[\"metadata\"] = self.metadata.hex()\n\n    return tx_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateDataAccount.type","title":"<code>type()</code>","text":"<p>Return transaction type.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def type(self) -&gt; TransactionType:\n    \"\"\"Return transaction type.\"\"\"\n    return TransactionType.CREATE_DATA_ACCOUNT\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateDataAccount.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize CreateDataAccount transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"CreateDataAccount\":\n    \"\"\"Deserialize CreateDataAccount transaction from bytes.\"\"\"\n    print(f\"DEBUG: Unmarshaling CreateDataAccount\")\n\n    reader = io.BytesIO(data)\n\n    #  Step 1: Parse Type Field\n    type_value = read_uvarint(reader)\n\n    #  Step 2: Parse URL (Read as a string)\n    url = unmarshal_string(reader)\n\n    #  Step 3: Parse Authorities (If present)\n    authorities = []\n    if reader.peek(1)[:1] == b'\\x03':  # Check if Authorities field exists\n        reader.read(1)  # Consume field identifier\n        authorities_count = read_uvarint(reader)\n        for _ in range(authorities_count):\n            auth_str = unmarshal_string(reader)\n            authorities.append(URL.parse(auth_str))\n\n    #  Step 4: Parse Metadata (If present)\n    metadata = None\n    if reader.peek(1)[:1] == b'\\x04':  # Check if Metadata field exists\n        reader.read(1)  # Consume field identifier\n        metadata = unmarshal_bytes(reader)\n\n    print(f\"DEBUG: Parsed CreateDataAccount: Type={type_value}, URL={url}, Authorities={authorities}, Metadata={metadata}\")\n    return cls(URL.parse(url), authorities if authorities else None, metadata)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity","title":"<code>CreateIdentity</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a CreateIdentity transaction, where the key hash is automatically derived.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class CreateIdentity(TransactionBodyBase):\n    \"\"\"\n    Represents a CreateIdentity transaction, where the key hash is automatically derived.\n    \"\"\"\n\n    def __init__(self, url: URL, signer_public_key: bytes, key_book_url: Optional[URL] = None):\n        \"\"\"\n        :param url: The URL of the new identity.\n        :param signer_public_key: The public key of the principal (used to derive the key hash).\n        :param key_book_url: The key book URL (optional).\n        \"\"\"\n        if not isinstance(url, URL):\n            raise TypeError(\"url must be an instance of URL.\")\n        if not isinstance(signer_public_key, bytes) or len(signer_public_key) != 32:\n            raise TypeError(\"signer_public_key must be a 32-byte public key.\")\n        if key_book_url and not isinstance(key_book_url, URL):\n            raise TypeError(\"keyBookUrl must be an instance of URL if provided.\")\n\n        self.url = url\n        self.key_hash = hashlib.sha256(signer_public_key).digest()  #  Compute key hash from the public key\n        self.key_book_url = key_book_url\n\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return the transaction type in Accumulate's expected format.\"\"\"\n        return TransactionType.CREATE_IDENTITY\n\n    def fields_to_encode(self):\n        \"\"\"Returns the fields to be marshaled in Accumulate format.\"\"\"\n        fields = [\n            (1, self.type().value, encode_uvarint),  # Type field (0x01 = CreateIdentity)\n            (2, string_marshal_binary(str(self.url)), lambda x: x),  # URL (0x02)\n            (3, self.key_hash, bytes_marshal_binary),  # returns (field_num, value, encode_func)\n        ]\n\n        if self.key_book_url:\n            fields.append((4, string_marshal_binary(str(self.key_book_url)), lambda x: x))  # KeyBookUrl (0x04)\n\n        return fields\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"Encodes the transaction into bytes for submission.\"\"\"\n        serialized = b\"\"\n        for field_num, value, encode_func in self.fields_to_encode():\n            encoded_value = encode_func(value)\n            serialized += field_marshal_binary(field_num, encoded_value)\n\n        return serialized\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert CreateIdentity transaction to a dictionary.\"\"\"\n        return {\n            \"type\": \"createIdentity\",  #  lowerCamelCase format\n            \"url\": str(self.url),\n            \"keyHash\": self.key_hash.hex(),  #  encode as hex\n            \"keyBookUrl\": str(self.key_book_url) if self.key_book_url else None,\n        }\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreateIdentity\":\n        \"\"\"Deserialize a CreateIdentity transaction from bytes.\"\"\"\n        reader = io.BytesIO(data)\n\n        # Field 1: Type\n        field_id = reader.read(1)\n        if field_id != b'\\x01':\n            raise ValueError(\"Expected field id 1 for type\")\n        tx_type = int.from_bytes(reader.read(1), \"big\")\n        if tx_type != TransactionType.CREATE_IDENTITY.value:\n            raise ValueError(\"Invalid transaction type for CreateIdentity\")\n\n        # Field 2: URL\n        field_id = reader.read(1)\n        if field_id != b'\\x02':\n            raise ValueError(\"Expected field id 2 for URL\")\n        url = unmarshal_string(reader)\n\n        # Field 3: Key Hash (Public Key Hash)\n        field_id = reader.read(1)\n        if field_id != b'\\x03':\n            raise ValueError(\"Expected field id 3 for key_hash\")\n        key_hash = reader.read(32)  #  Read 32-byte key hash\n\n        # Field 4: Key Book URL (Optional)\n        key_book_url = None\n        if reader.peek(1)[:1] == b'\\x04':  #  Peek to check if KeyBookUrl field exists\n            reader.read(1)  # Consume field identifier\n            key_book_url = unmarshal_string(reader)\n\n        return cls(URL.parse(url), key_hash, URL.parse(key_book_url) if key_book_url else None)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity.__init__","title":"<code>__init__(url, signer_public_key, key_book_url=None)</code>","text":"<p>:param url: The URL of the new identity. :param signer_public_key: The public key of the principal (used to derive the key hash). :param key_book_url: The key book URL (optional).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, url: URL, signer_public_key: bytes, key_book_url: Optional[URL] = None):\n    \"\"\"\n    :param url: The URL of the new identity.\n    :param signer_public_key: The public key of the principal (used to derive the key hash).\n    :param key_book_url: The key book URL (optional).\n    \"\"\"\n    if not isinstance(url, URL):\n        raise TypeError(\"url must be an instance of URL.\")\n    if not isinstance(signer_public_key, bytes) or len(signer_public_key) != 32:\n        raise TypeError(\"signer_public_key must be a 32-byte public key.\")\n    if key_book_url and not isinstance(key_book_url, URL):\n        raise TypeError(\"keyBookUrl must be an instance of URL if provided.\")\n\n    self.url = url\n    self.key_hash = hashlib.sha256(signer_public_key).digest()  #  Compute key hash from the public key\n    self.key_book_url = key_book_url\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Returns the fields to be marshaled in Accumulate format.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"Returns the fields to be marshaled in Accumulate format.\"\"\"\n    fields = [\n        (1, self.type().value, encode_uvarint),  # Type field (0x01 = CreateIdentity)\n        (2, string_marshal_binary(str(self.url)), lambda x: x),  # URL (0x02)\n        (3, self.key_hash, bytes_marshal_binary),  # returns (field_num, value, encode_func)\n    ]\n\n    if self.key_book_url:\n        fields.append((4, string_marshal_binary(str(self.key_book_url)), lambda x: x))  # KeyBookUrl (0x04)\n\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity.marshal","title":"<code>marshal()</code>","text":"<p>Encodes the transaction into bytes for submission.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"Encodes the transaction into bytes for submission.\"\"\"\n    serialized = b\"\"\n    for field_num, value, encode_func in self.fields_to_encode():\n        encoded_value = encode_func(value)\n        serialized += field_marshal_binary(field_num, encoded_value)\n\n    return serialized\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert CreateIdentity transaction to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert CreateIdentity transaction to a dictionary.\"\"\"\n    return {\n        \"type\": \"createIdentity\",  #  lowerCamelCase format\n        \"url\": str(self.url),\n        \"keyHash\": self.key_hash.hex(),  #  encode as hex\n        \"keyBookUrl\": str(self.key_book_url) if self.key_book_url else None,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity.type","title":"<code>type()</code>","text":"<p>Return the transaction type in Accumulate's expected format.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def type(self) -&gt; TransactionType:\n    \"\"\"Return the transaction type in Accumulate's expected format.\"\"\"\n    return TransactionType.CREATE_IDENTITY\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateIdentity.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a CreateIdentity transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"CreateIdentity\":\n    \"\"\"Deserialize a CreateIdentity transaction from bytes.\"\"\"\n    reader = io.BytesIO(data)\n\n    # Field 1: Type\n    field_id = reader.read(1)\n    if field_id != b'\\x01':\n        raise ValueError(\"Expected field id 1 for type\")\n    tx_type = int.from_bytes(reader.read(1), \"big\")\n    if tx_type != TransactionType.CREATE_IDENTITY.value:\n        raise ValueError(\"Invalid transaction type for CreateIdentity\")\n\n    # Field 2: URL\n    field_id = reader.read(1)\n    if field_id != b'\\x02':\n        raise ValueError(\"Expected field id 2 for URL\")\n    url = unmarshal_string(reader)\n\n    # Field 3: Key Hash (Public Key Hash)\n    field_id = reader.read(1)\n    if field_id != b'\\x03':\n        raise ValueError(\"Expected field id 3 for key_hash\")\n    key_hash = reader.read(32)  #  Read 32-byte key hash\n\n    # Field 4: Key Book URL (Optional)\n    key_book_url = None\n    if reader.peek(1)[:1] == b'\\x04':  #  Peek to check if KeyBookUrl field exists\n        reader.read(1)  # Consume field identifier\n        key_book_url = unmarshal_string(reader)\n\n    return cls(URL.parse(url), key_hash, URL.parse(key_book_url) if key_book_url else None)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateKeyBook","title":"<code>CreateKeyBook</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Create Key Book transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@dataclass\nclass CreateKeyBook(TransactionBodyBase):\n    \"\"\"\n    Represents a Create Key Book transaction.\n    \"\"\"\n    url: URL\n    public_key_hash: bytes  # Must be exactly 32 bytes\n    authorities: Optional[List[URL]] = None\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.CREATE_KEY_BOOK\n\n    def fields_to_encode(self):\n        \"\"\"\n        Build the fields as follows:\n          Field 1: Transaction type (as a varint)\n          Field 2: URL (with a length prefix added by string_marshal_binary)\n          Field 3: publicKeyHash (with a length prefix, which should be 0x20)\n          Optionally, if authorities are provided, include them as fields 4 and 5\n        \"\"\"\n        fields = [\n            # Field 1: Transaction type (e.g. 0x0d)\n            (1, encode_uvarint(self.type().value), lambda x: x),\n            # Field 2: URL \u2013 string_marshal_binary automatically prepends the length\n            (2, string_marshal_binary(str(self.url)), lambda x: x),\n            # Field 3: publicKeyHash \u2013 hash_marshal_binary checks length (must be 32)\n            (3, bytes_marshal_binary(self.public_key_hash), lambda x: x),\n        ]\n        if self.authorities:\n            # Authorities count\n            authorities_count = encode_uvarint(len(self.authorities))\n            # Encode each authority URL.\n            encoded_auths = b\"\".join([string_marshal_binary(str(auth)) for auth in self.authorities])\n            fields.append((4, authorities_count, lambda x: x))\n            fields.append((5, encoded_auths, lambda x: x))\n        return fields\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert transaction body to a JSON\u2011serializable dictionary\"\"\"\n        tx_dict = {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"url\": str(self.url),\n            \"publicKeyHash\": self.public_key_hash.hex(),\n        }\n        if self.authorities:\n            tx_dict[\"authorities\"] = [str(auth) for auth in self.authorities]\n        return tx_dict\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreateKeyBook\":\n        logger.debug(\" Unmarshaling CreateKeyBook\")\n        reader = io.BytesIO(data)\n        # Read URL field (field 2)\n        url = URL.parse(unmarshal_bytes(reader).decode(\"utf-8\"))\n        # Read publicKeyHash field (field 3)\n        public_key_hash = reader.read(32)\n        if len(public_key_hash) != 32:\n            raise ValueError(\"Invalid public key hash length (must be 32 bytes)\")\n        authorities = []\n        if reader.tell() &lt; len(data):\n            authorities_count = read_uvarint(reader)\n            for _ in range(authorities_count):\n                auth_url = unmarshal_bytes(reader).decode(\"utf-8\")\n                authorities.append(URL.parse(auth_url))\n        logger.debug(f\" Parsed CreateKeyBook: URL={url}, PublicKeyHash={public_key_hash.hex()}, Authorities={authorities}\")\n        return cls(url, public_key_hash, authorities)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateKeyBook.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"Build the fields as follows <p>Field 1: Transaction type (as a varint) Field 2: URL (with a length prefix added by string_marshal_binary) Field 3: publicKeyHash (with a length prefix, which should be 0x20) Optionally, if authorities are provided, include them as fields 4 and 5</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Build the fields as follows:\n      Field 1: Transaction type (as a varint)\n      Field 2: URL (with a length prefix added by string_marshal_binary)\n      Field 3: publicKeyHash (with a length prefix, which should be 0x20)\n      Optionally, if authorities are provided, include them as fields 4 and 5\n    \"\"\"\n    fields = [\n        # Field 1: Transaction type (e.g. 0x0d)\n        (1, encode_uvarint(self.type().value), lambda x: x),\n        # Field 2: URL \u2013 string_marshal_binary automatically prepends the length\n        (2, string_marshal_binary(str(self.url)), lambda x: x),\n        # Field 3: publicKeyHash \u2013 hash_marshal_binary checks length (must be 32)\n        (3, bytes_marshal_binary(self.public_key_hash), lambda x: x),\n    ]\n    if self.authorities:\n        # Authorities count\n        authorities_count = encode_uvarint(len(self.authorities))\n        # Encode each authority URL.\n        encoded_auths = b\"\".join([string_marshal_binary(str(auth)) for auth in self.authorities])\n        fields.append((4, authorities_count, lambda x: x))\n        fields.append((5, encoded_auths, lambda x: x))\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateKeyBook.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert transaction body to a JSON\u2011serializable dictionary</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert transaction body to a JSON\u2011serializable dictionary\"\"\"\n    tx_dict = {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"url\": str(self.url),\n        \"publicKeyHash\": self.public_key_hash.hex(),\n    }\n    if self.authorities:\n        tx_dict[\"authorities\"] = [str(auth) for auth in self.authorities]\n    return tx_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateKeyPage","title":"<code>CreateKeyPage</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Create Key Page transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@dataclass\nclass CreateKeyPage(TransactionBodyBase):\n    \"\"\"\n    Represents a Create Key Page transaction.\n    \"\"\"\n    keys: List[KeySpecParams]\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.CREATE_KEY_PAGE\n\n    def fields_to_encode(self):\n        \"\"\"\n        Define the fields to encode, following structured encoding.\n        \"\"\"\n        # Marshal each key (each key's marshal() already adds its own field prefix)\n        encoded_keys = b\"\".join([key.marshal() for key in self.keys])\n        logger.debug(f\"Encoded keys (hex): {encoded_keys.hex()}\")\n        logger.debug(f\"Encoded keys length: {len(encoded_keys)} bytes\")\n\n        # Manually prepend the varint-encoded length of the concatenated keys\n        keys_value = encode_uvarint(len(encoded_keys)) + encoded_keys\n\n        # The generic marshal will wrap each value with its field number.\n        fields = [\n            (1, encode_uvarint(self.type().value), lambda x: x),  # Field 1: Transaction Type\n            (2, keys_value, lambda x: x),                         # Field 2: Keys (with length prefix)\n        ]\n        return fields\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert transaction to a dictionary with correct type formatting, including keys.\"\"\"\n        return {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"keys\": [{\"keyHash\": key.key_hash.hex()} for key in self.keys]\n        }\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreateKeyPage\":\n        logger.debug(f\" Unmarshaling CreateKeyPage\")\n        reader = io.BytesIO(data)\n        # Read the keys field: first, the varint length, then the concatenated key bytes\n        keys_length = read_uvarint(reader)\n        keys_data = reader.read(keys_length)\n\n        # To extract individual keys, we assume they were marshaled sequentially\n        # (If multiple keys were present, you might need to loop until keys_data is exhausted)\n        # For this example, we assume a single key or that you have a known count\n        # Here, we assume the count equals the number of keys concatenated\n        # (For a robust implementation, include a count field)\n        keys = []\n        sub_reader = io.BytesIO(keys_data)\n        while sub_reader.tell() &lt; len(keys_data):\n            key_bytes = unmarshal_bytes(sub_reader)\n            keys.append(KeySpecParams.unmarshal(key_bytes))\n\n        logger.debug(f\" Parsed CreateKeyPage: keys={keys}\")\n        return cls(keys)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateKeyPage.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Define the fields to encode, following structured encoding.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Define the fields to encode, following structured encoding.\n    \"\"\"\n    # Marshal each key (each key's marshal() already adds its own field prefix)\n    encoded_keys = b\"\".join([key.marshal() for key in self.keys])\n    logger.debug(f\"Encoded keys (hex): {encoded_keys.hex()}\")\n    logger.debug(f\"Encoded keys length: {len(encoded_keys)} bytes\")\n\n    # Manually prepend the varint-encoded length of the concatenated keys\n    keys_value = encode_uvarint(len(encoded_keys)) + encoded_keys\n\n    # The generic marshal will wrap each value with its field number.\n    fields = [\n        (1, encode_uvarint(self.type().value), lambda x: x),  # Field 1: Transaction Type\n        (2, keys_value, lambda x: x),                         # Field 2: Keys (with length prefix)\n    ]\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateKeyPage.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert transaction to a dictionary with correct type formatting, including keys.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert transaction to a dictionary with correct type formatting, including keys.\"\"\"\n    return {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"keys\": [{\"keyHash\": key.key_hash.hex()} for key in self.keys]\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateToken","title":"<code>CreateToken</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Create Token transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class CreateToken(TransactionBodyBase):\n    \"\"\"\n    Represents a Create Token transaction.\n    \"\"\"\n\n    def __init__(self, url: URL, symbol: str, precision: int, supply_limit: Optional[int] = None, authorities: Optional[List[URL]] = None):\n        if not isinstance(url, URL):\n            raise TypeError(\"url must be an instance of URL.\")\n        if not isinstance(symbol, str) or not symbol:\n            raise ValueError(\"symbol must be a non-empty string.\")\n        if not isinstance(precision, int) or not (0 &lt;= precision &lt;= 18):\n            raise ValueError(\"precision must be an integer between 0 and 18.\")\n        if supply_limit is not None and not isinstance(supply_limit, int):\n            raise ValueError(\"supplyLimit must be an integer or None.\")\n\n        self.url = url\n        self.symbol = symbol\n        self.precision = precision\n        self.supply_limit = supply_limit  # Original (provided-readable) supply limit\n        # Dynamically adjust the supplyLimit: multiply by 10^precision\n        self.adjusted_supply_limit = supply_limit * (10 ** precision) if supply_limit is not None else None\n        self.authorities = authorities or []\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.CREATE_TOKEN\n\n    def _encode_supply_limit(self) -&gt; bytes:\n        \"\"\"\n        Encode the adjusted supply limit using a variable-length encoding.\n        First, compute the minimal number of bytes needed to represent the adjusted value,\n        then prefix that with its length encoded as a varint.\n        \"\"\"\n        value = self.adjusted_supply_limit\n        # Determine the minimum number of bytes (at least 1)\n        num_bytes = (value.bit_length() + 7) // 8 or 1\n        supply_bytes = value.to_bytes(num_bytes, byteorder=\"big\")\n        return encode_uvarint(num_bytes) + supply_bytes\n\n    def fields_to_encode(self):\n        \"\"\"\n        Expected official encoding:\n          Field 1: Transaction Type (CREATE_TOKEN) -&gt; 01 08\n          Field 2: Token URL -&gt; 02 + length + url bytes\n          Field 4: Symbol -&gt; 04 + length + symbol bytes\n          Field 5: Precision -&gt; 05 + varint(precision)\n          Field 7: Supply Limit -&gt; 07 + (length varint + supply limit bytes) [variable length]\n          Field 9: Authorities -&gt; if provided.\n        \"\"\"\n        fields = [\n            (1, encode_uvarint(self.type().value), lambda x: x),  # Transaction Type\n            (2, string_marshal_binary(str(self.url)), lambda x: x),  # Token URL\n            (4, string_marshal_binary(self.symbol), lambda x: x),  # Symbol\n            (5, encode_uvarint(self.precision), lambda x: x),  # Precision\n            (7, self._encode_supply_limit(), lambda x: x) if self.adjusted_supply_limit is not None else None,\n            (9, b\"\".join([string_marshal_binary(str(auth)) for auth in self.authorities]), lambda x: x) if self.authorities else None,\n        ]\n        return [field for field in fields if field is not None]\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the transaction into a JSON-compatible dictionary.\n        Outputs the dynamically adjusted supply limit (the on-chain value).\n        \"\"\"\n        data = {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"url\": str(self.url),\n            \"symbol\": self.symbol,\n            \"precision\": self.precision\n        }\n        if self.adjusted_supply_limit is not None:\n            data[\"supplyLimit\"] = str(self.adjusted_supply_limit)\n        if self.authorities:\n            data[\"authorities\"] = [str(auth) for auth in self.authorities]\n        return data\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreateToken\":\n        \"\"\"\n        Deserialize CreateToken transaction from bytes.\n        \"\"\"\n        reader = io.BytesIO(data)\n\n        # Step 1: Parse Transaction Type (should be CREATE_TOKEN)\n        transaction_type, _ = decode_uvarint(reader.read())\n        if transaction_type != TransactionType.CREATE_TOKEN.value:\n            raise ValueError(f\"Unexpected transaction type: {transaction_type}\")\n\n        # Step 2: Parse Token URL\n        token_url = URL.parse(unmarshal_bytes(reader).decode(\"utf-8\"))\n\n        # Step 3: Parse Symbol\n        symbol = unmarshal_bytes(reader).decode(\"utf-8\")\n\n        # Step 4: Parse Precision\n        precision, _ = decode_uvarint(reader.read())\n\n        # Step 5: Parse Supply Limit (if available)\n        supply_limit = None\n        if reader.tell() &lt; len(data):\n            length, _ = decode_uvarint(reader.read())\n            # Read 'length' bytes for the adjusted supply limit\n            supply_bytes = reader.read(length)\n            adjusted_supply_limit = int.from_bytes(supply_bytes, byteorder=\"big\")\n            # Convert back to the original supply limit by dividing by 10^precision\n            supply_limit = adjusted_supply_limit // (10 ** precision)\n\n        # Step 6: Parse Authorities (if available)\n        authorities = []\n        while reader.tell() &lt; len(data):\n            authorities.append(URL.parse(unmarshal_bytes(reader).decode(\"utf-8\")))\n\n        return cls(token_url, symbol, precision, supply_limit, authorities)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateToken._encode_supply_limit","title":"<code>_encode_supply_limit()</code>","text":"<p>Encode the adjusted supply limit using a variable-length encoding. First, compute the minimal number of bytes needed to represent the adjusted value, then prefix that with its length encoded as a varint.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def _encode_supply_limit(self) -&gt; bytes:\n    \"\"\"\n    Encode the adjusted supply limit using a variable-length encoding.\n    First, compute the minimal number of bytes needed to represent the adjusted value,\n    then prefix that with its length encoded as a varint.\n    \"\"\"\n    value = self.adjusted_supply_limit\n    # Determine the minimum number of bytes (at least 1)\n    num_bytes = (value.bit_length() + 7) // 8 or 1\n    supply_bytes = value.to_bytes(num_bytes, byteorder=\"big\")\n    return encode_uvarint(num_bytes) + supply_bytes\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateToken.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"Expected official encoding <p>Field 1: Transaction Type (CREATE_TOKEN) -&gt; 01 08 Field 2: Token URL -&gt; 02 + length + url bytes Field 4: Symbol -&gt; 04 + length + symbol bytes Field 5: Precision -&gt; 05 + varint(precision) Field 7: Supply Limit -&gt; 07 + (length varint + supply limit bytes) [variable length] Field 9: Authorities -&gt; if provided.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Expected official encoding:\n      Field 1: Transaction Type (CREATE_TOKEN) -&gt; 01 08\n      Field 2: Token URL -&gt; 02 + length + url bytes\n      Field 4: Symbol -&gt; 04 + length + symbol bytes\n      Field 5: Precision -&gt; 05 + varint(precision)\n      Field 7: Supply Limit -&gt; 07 + (length varint + supply limit bytes) [variable length]\n      Field 9: Authorities -&gt; if provided.\n    \"\"\"\n    fields = [\n        (1, encode_uvarint(self.type().value), lambda x: x),  # Transaction Type\n        (2, string_marshal_binary(str(self.url)), lambda x: x),  # Token URL\n        (4, string_marshal_binary(self.symbol), lambda x: x),  # Symbol\n        (5, encode_uvarint(self.precision), lambda x: x),  # Precision\n        (7, self._encode_supply_limit(), lambda x: x) if self.adjusted_supply_limit is not None else None,\n        (9, b\"\".join([string_marshal_binary(str(auth)) for auth in self.authorities]), lambda x: x) if self.authorities else None,\n    ]\n    return [field for field in fields if field is not None]\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateToken.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the transaction into a JSON-compatible dictionary. Outputs the dynamically adjusted supply limit (the on-chain value).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the transaction into a JSON-compatible dictionary.\n    Outputs the dynamically adjusted supply limit (the on-chain value).\n    \"\"\"\n    data = {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"url\": str(self.url),\n        \"symbol\": self.symbol,\n        \"precision\": self.precision\n    }\n    if self.adjusted_supply_limit is not None:\n        data[\"supplyLimit\"] = str(self.adjusted_supply_limit)\n    if self.authorities:\n        data[\"authorities\"] = [str(auth) for auth in self.authorities]\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateToken.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize CreateToken transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"CreateToken\":\n    \"\"\"\n    Deserialize CreateToken transaction from bytes.\n    \"\"\"\n    reader = io.BytesIO(data)\n\n    # Step 1: Parse Transaction Type (should be CREATE_TOKEN)\n    transaction_type, _ = decode_uvarint(reader.read())\n    if transaction_type != TransactionType.CREATE_TOKEN.value:\n        raise ValueError(f\"Unexpected transaction type: {transaction_type}\")\n\n    # Step 2: Parse Token URL\n    token_url = URL.parse(unmarshal_bytes(reader).decode(\"utf-8\"))\n\n    # Step 3: Parse Symbol\n    symbol = unmarshal_bytes(reader).decode(\"utf-8\")\n\n    # Step 4: Parse Precision\n    precision, _ = decode_uvarint(reader.read())\n\n    # Step 5: Parse Supply Limit (if available)\n    supply_limit = None\n    if reader.tell() &lt; len(data):\n        length, _ = decode_uvarint(reader.read())\n        # Read 'length' bytes for the adjusted supply limit\n        supply_bytes = reader.read(length)\n        adjusted_supply_limit = int.from_bytes(supply_bytes, byteorder=\"big\")\n        # Convert back to the original supply limit by dividing by 10^precision\n        supply_limit = adjusted_supply_limit // (10 ** precision)\n\n    # Step 6: Parse Authorities (if available)\n    authorities = []\n    while reader.tell() &lt; len(data):\n        authorities.append(URL.parse(unmarshal_bytes(reader).decode(\"utf-8\")))\n\n    return cls(token_url, symbol, precision, supply_limit, authorities)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateTokenAccount","title":"<code>CreateTokenAccount</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Create Token Account transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class CreateTokenAccount(TransactionBodyBase):\n    \"\"\"\n    Represents a Create Token Account transaction.\n    \"\"\"\n\n    def __init__(self, url: URL, token_url: URL, authorities: Optional[List[URL]] = None):\n        \"\"\"\n        :param url: The URL of the token account.\n        :param token_url: The URL of the token issuer.\n        :param authorities: List of authorities for the token account (optional).\n        \"\"\"\n        if not isinstance(url, URL):\n            raise TypeError(\"url must be an instance of URL.\")\n        if not isinstance(token_url, URL):\n            raise TypeError(\"token_url must be an instance of URL.\")\n\n        self.url = url\n        self.token_url = token_url\n        self.authorities = authorities if authorities else None  # Set to None if empty\n\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return transaction type.\"\"\"\n        return TransactionType.CREATE_TOKEN_ACCOUNT\n\n    def fields_to_encode(self):\n        \"\"\"\n        Returns the fields to encode as a list of (field_id, value, encoding_function).\n        \"\"\"\n        fields = [\n            #  **encode Type Field (Field 1)**\n            (1, encode_uvarint(self.type().value), lambda x: x),  # Type (0x01)\n\n            #  **field order (URL first, then Token URL)**\n            (2, string_marshal_binary(str(self.url)), lambda x: x),  # URL (0x02)\n            (3, string_marshal_binary(str(self.token_url)), lambda x: x),  # Token URL (0x03)\n        ]\n\n        #  Only include authorities if provided\n        if self.authorities:\n            authorities_encoded = b\"\".join([\n                string_marshal_binary(str(auth)) for auth in self.authorities\n            ])\n            fields.append((4, encode_uvarint(len(self.authorities)) + authorities_encoded, lambda x: x))  # Authorities (0x04)\n\n        return fields\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreateTokenAccount\":\n        \"\"\"Deserialize CreateTokenAccount transaction from bytes.\"\"\"\n        reader = io.BytesIO(data)\n\n        #  Step 1: Parse Type Field (Required)\n        type_value = read_uvarint(reader)  # Read type value\n\n        #  Step 2: Parse URL\n        url_str = unmarshal_string(reader)\n        url = URL.parse(url_str)\n\n        #  Step 3: Parse Token URL\n        token_url_str = unmarshal_string(reader)\n        token_url = URL.parse(token_url_str)\n\n        #  Step 4: Parse Authorities (if present)\n        authorities = []\n        if reader.peek(1)[:1] == b'\\x04':  # Check if Authorities field exists\n            reader.read(1)  # Consume field identifier\n            authorities_count = read_uvarint(reader)  # Read count\n            for _ in range(authorities_count):\n                auth_str = unmarshal_string(reader)\n                authorities.append(URL.parse(auth_str))\n\n        return cls(url, token_url, authorities if authorities else None)  # Set to None if empty\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert CreateTokenAccount transaction to a dictionary.\"\"\"\n        tx_dict = {\n            **super().to_dict(),\n            \"url\": str(self.url),\n            \"tokenUrl\": str(self.token_url),\n        }\n\n        #  Only include authorities in dict if it's not empty\n        if self.authorities:\n            tx_dict[\"authorities\"] = [str(auth) for auth in self.authorities]\n\n        return tx_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateTokenAccount.__init__","title":"<code>__init__(url, token_url, authorities=None)</code>","text":"<p>:param url: The URL of the token account. :param token_url: The URL of the token issuer. :param authorities: List of authorities for the token account (optional).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, url: URL, token_url: URL, authorities: Optional[List[URL]] = None):\n    \"\"\"\n    :param url: The URL of the token account.\n    :param token_url: The URL of the token issuer.\n    :param authorities: List of authorities for the token account (optional).\n    \"\"\"\n    if not isinstance(url, URL):\n        raise TypeError(\"url must be an instance of URL.\")\n    if not isinstance(token_url, URL):\n        raise TypeError(\"token_url must be an instance of URL.\")\n\n    self.url = url\n    self.token_url = token_url\n    self.authorities = authorities if authorities else None  # Set to None if empty\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateTokenAccount.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Returns the fields to encode as a list of (field_id, value, encoding_function).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Returns the fields to encode as a list of (field_id, value, encoding_function).\n    \"\"\"\n    fields = [\n        #  **encode Type Field (Field 1)**\n        (1, encode_uvarint(self.type().value), lambda x: x),  # Type (0x01)\n\n        #  **field order (URL first, then Token URL)**\n        (2, string_marshal_binary(str(self.url)), lambda x: x),  # URL (0x02)\n        (3, string_marshal_binary(str(self.token_url)), lambda x: x),  # Token URL (0x03)\n    ]\n\n    #  Only include authorities if provided\n    if self.authorities:\n        authorities_encoded = b\"\".join([\n            string_marshal_binary(str(auth)) for auth in self.authorities\n        ])\n        fields.append((4, encode_uvarint(len(self.authorities)) + authorities_encoded, lambda x: x))  # Authorities (0x04)\n\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateTokenAccount.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert CreateTokenAccount transaction to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert CreateTokenAccount transaction to a dictionary.\"\"\"\n    tx_dict = {\n        **super().to_dict(),\n        \"url\": str(self.url),\n        \"tokenUrl\": str(self.token_url),\n    }\n\n    #  Only include authorities in dict if it's not empty\n    if self.authorities:\n        tx_dict[\"authorities\"] = [str(auth) for auth in self.authorities]\n\n    return tx_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateTokenAccount.type","title":"<code>type()</code>","text":"<p>Return transaction type.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def type(self) -&gt; TransactionType:\n    \"\"\"Return transaction type.\"\"\"\n    return TransactionType.CREATE_TOKEN_ACCOUNT\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.CreateTokenAccount.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize CreateTokenAccount transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"CreateTokenAccount\":\n    \"\"\"Deserialize CreateTokenAccount transaction from bytes.\"\"\"\n    reader = io.BytesIO(data)\n\n    #  Step 1: Parse Type Field (Required)\n    type_value = read_uvarint(reader)  # Read type value\n\n    #  Step 2: Parse URL\n    url_str = unmarshal_string(reader)\n    url = URL.parse(url_str)\n\n    #  Step 3: Parse Token URL\n    token_url_str = unmarshal_string(reader)\n    token_url = URL.parse(token_url_str)\n\n    #  Step 4: Parse Authorities (if present)\n    authorities = []\n    if reader.peek(1)[:1] == b'\\x04':  # Check if Authorities field exists\n        reader.read(1)  # Consume field identifier\n        authorities_count = read_uvarint(reader)  # Read count\n        for _ in range(authorities_count):\n            auth_str = unmarshal_string(reader)\n            authorities.append(URL.parse(auth_str))\n\n    return cls(url, token_url, authorities if authorities else None)  # Set to None if empty\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens","title":"<code>IssueTokens</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents an Issue Tokens transaction. This version includes only a list of token recipients.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class IssueTokens(TransactionBodyBase):\n    \"\"\"\n    Represents an Issue Tokens transaction.\n    This version includes only a list of token recipients.\n    \"\"\"\n\n    def __init__(self, recipients: List[\"TokenRecipient\"]):\n        \"\"\"\n        :param recipients: A list of TokenRecipient instances.\n        \"\"\"\n        if not isinstance(recipients, list) or not all(isinstance(recipient, TokenRecipient) for recipient in recipients):\n            raise TypeError(\"recipients must be a list of TokenRecipient instances.\")\n        self.recipients = recipients\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.ISSUE_TOKENS\n\n    def fields_to_encode(self):\n        \"\"\"\n        Fields for IssueTokens:\n          Field 1: Transaction type (encoded as varint).\n          Field 4: Recipients (as a length-prefixed list of recipient fields).\n        \"\"\"\n        fields = [\n            (1, encode_uvarint(self.type().value), lambda x: x),\n            (4, self._marshal_recipients(), lambda x: x),\n        ]\n        return fields\n\n    def _marshal_recipients(self) -&gt; bytes:\n        \"\"\"\n        Serialize recipients as a length-prefixed list.\n        Each recipient is encoded as:\n          - Field 1: URL (as a length-prefixed string)\n          - Field 2: Amount (as a big-number, using big_number_marshal_binary)\n        The recipient fields are concatenated (without an extra length wrapper per recipient)\n        and the entire recipients block is prefixed with a varint length.\n        \"\"\"\n        # Encode each recipient without extra wrapping:\n        recipient_entries = []\n        for recipient in self.recipients:\n            # Encode field 1: recipient URL\n            url_field = field_marshal_binary(1, string_marshal_binary(str(recipient.url)))\n            # Encode field 2: recipient amount\n            amount_field = field_marshal_binary(2, big_number_marshal_binary(recipient.amount))\n            recipient_entries.append(url_field + amount_field)\n        recipients_data = b\"\".join(recipient_entries)\n        length_prefix = encode_uvarint(len(recipients_data))\n        return length_prefix + recipients_data\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"IssueTokens\":\n        \"\"\"\n        Deserialize IssueTokens transaction from bytes.\n        \"\"\"\n        reader = io.BytesIO(data)\n        # Field 1: Transaction type\n        transaction_type, _ = decode_uvarint(reader.read())\n        if transaction_type != TransactionType.ISSUE_TOKENS.value:\n            raise ValueError(\"Unexpected transaction type\")\n        # Field 4: Recipients list\n        recipients_length, _ = decode_uvarint(reader.read())\n        recipients_data = reader.read(recipients_length)\n        recipients = cls._unmarshal_recipients(recipients_data)\n        return cls(recipients)\n\n    @staticmethod\n    def _unmarshal_recipients(data: bytes) -&gt; List[\"TokenRecipient\"]:\n        \"\"\"\n        Deserialize the recipients list from a byte stream.\n        Each recipient is encoded as:\n          - Field 1: URL (length-prefixed string)\n          - Field 2: Amount (big-number bytes)\n        \"\"\"\n        recipients = []\n        reader = io.BytesIO(data)\n        while reader.tell() &lt; len(data):\n            # Expect field id 1 for URL.\n            field_id = reader.read(1)\n            if field_id != b'\\x01':\n                raise ValueError(\"Expected field id 1 for recipient URL\")\n            recipient_url = unmarshal_string(reader)\n            # Expect field id 2 for amount.\n            field_id = reader.read(1)\n            if field_id != b'\\x02':\n                raise ValueError(\"Expected field id 2 for recipient amount\")\n            recipient_amount = int.from_bytes(unmarshal_bytes(reader), byteorder='big')\n            recipients.append(TokenRecipient(URL.parse(recipient_url), recipient_amount))\n        return recipients\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Convert the IssueTokens transaction to a JSON\u2011serializable dictionary.\n        The recipients are output under the key \"to\".\n        \"\"\"\n        return {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"to\": [recipient.to_dict() for recipient in self.recipients],\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens.__init__","title":"<code>__init__(recipients)</code>","text":"<p>:param recipients: A list of TokenRecipient instances.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, recipients: List[\"TokenRecipient\"]):\n    \"\"\"\n    :param recipients: A list of TokenRecipient instances.\n    \"\"\"\n    if not isinstance(recipients, list) or not all(isinstance(recipient, TokenRecipient) for recipient in recipients):\n        raise TypeError(\"recipients must be a list of TokenRecipient instances.\")\n    self.recipients = recipients\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens._marshal_recipients","title":"<code>_marshal_recipients()</code>","text":"<p>Serialize recipients as a length-prefixed list. Each recipient is encoded as:   - Field 1: URL (as a length-prefixed string)   - Field 2: Amount (as a big-number, using big_number_marshal_binary) The recipient fields are concatenated (without an extra length wrapper per recipient) and the entire recipients block is prefixed with a varint length.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def _marshal_recipients(self) -&gt; bytes:\n    \"\"\"\n    Serialize recipients as a length-prefixed list.\n    Each recipient is encoded as:\n      - Field 1: URL (as a length-prefixed string)\n      - Field 2: Amount (as a big-number, using big_number_marshal_binary)\n    The recipient fields are concatenated (without an extra length wrapper per recipient)\n    and the entire recipients block is prefixed with a varint length.\n    \"\"\"\n    # Encode each recipient without extra wrapping:\n    recipient_entries = []\n    for recipient in self.recipients:\n        # Encode field 1: recipient URL\n        url_field = field_marshal_binary(1, string_marshal_binary(str(recipient.url)))\n        # Encode field 2: recipient amount\n        amount_field = field_marshal_binary(2, big_number_marshal_binary(recipient.amount))\n        recipient_entries.append(url_field + amount_field)\n    recipients_data = b\"\".join(recipient_entries)\n    length_prefix = encode_uvarint(len(recipients_data))\n    return length_prefix + recipients_data\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens._unmarshal_recipients","title":"<code>_unmarshal_recipients(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize the recipients list from a byte stream. Each recipient is encoded as:   - Field 1: URL (length-prefixed string)   - Field 2: Amount (big-number bytes)</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef _unmarshal_recipients(data: bytes) -&gt; List[\"TokenRecipient\"]:\n    \"\"\"\n    Deserialize the recipients list from a byte stream.\n    Each recipient is encoded as:\n      - Field 1: URL (length-prefixed string)\n      - Field 2: Amount (big-number bytes)\n    \"\"\"\n    recipients = []\n    reader = io.BytesIO(data)\n    while reader.tell() &lt; len(data):\n        # Expect field id 1 for URL.\n        field_id = reader.read(1)\n        if field_id != b'\\x01':\n            raise ValueError(\"Expected field id 1 for recipient URL\")\n        recipient_url = unmarshal_string(reader)\n        # Expect field id 2 for amount.\n        field_id = reader.read(1)\n        if field_id != b'\\x02':\n            raise ValueError(\"Expected field id 2 for recipient amount\")\n        recipient_amount = int.from_bytes(unmarshal_bytes(reader), byteorder='big')\n        recipients.append(TokenRecipient(URL.parse(recipient_url), recipient_amount))\n    return recipients\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"Fields for IssueTokens <p>Field 1: Transaction type (encoded as varint). Field 4: Recipients (as a length-prefixed list of recipient fields).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Fields for IssueTokens:\n      Field 1: Transaction type (encoded as varint).\n      Field 4: Recipients (as a length-prefixed list of recipient fields).\n    \"\"\"\n    fields = [\n        (1, encode_uvarint(self.type().value), lambda x: x),\n        (4, self._marshal_recipients(), lambda x: x),\n    ]\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the IssueTokens transaction to a JSON\u2011serializable dictionary. The recipients are output under the key \"to\".</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Convert the IssueTokens transaction to a JSON\u2011serializable dictionary.\n    The recipients are output under the key \"to\".\n    \"\"\"\n    return {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"to\": [recipient.to_dict() for recipient in self.recipients],\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.IssueTokens.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize IssueTokens transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"IssueTokens\":\n    \"\"\"\n    Deserialize IssueTokens transaction from bytes.\n    \"\"\"\n    reader = io.BytesIO(data)\n    # Field 1: Transaction type\n    transaction_type, _ = decode_uvarint(reader.read())\n    if transaction_type != TransactionType.ISSUE_TOKENS.value:\n        raise ValueError(\"Unexpected transaction type\")\n    # Field 4: Recipients list\n    recipients_length, _ = decode_uvarint(reader.read())\n    recipients_data = reader.read(recipients_length)\n    recipients = cls._unmarshal_recipients(recipients_data)\n    return cls(recipients)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.RemoteTransaction","title":"<code>RemoteTransaction</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Remote Transaction, which references another transaction by its hash.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class RemoteTransaction(TransactionBodyBase):\n    \"\"\"\n    Represents a Remote Transaction, which references another transaction by its hash.\n    \"\"\"\n\n    def __init__(self, hash: bytes):\n        \"\"\"\n        :param hash: The 32-byte transaction hash being referenced.\n        \"\"\"\n        if not isinstance(hash, bytes) or len(hash) != 32:\n            raise ValueError(\"hash must be a 32-byte value.\")\n\n        self.hash = hash  # Store the transaction hash\n\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return the transaction type.\"\"\"\n        return TransactionType.REMOTE\n\n    def fields_to_encode(self):\n        \"\"\"\n        Fields to encode:\n          Field 1: Transaction Type (remoteTransaction)\n          Field 2: Transaction Hash (32-byte binary)\n        \"\"\"\n        return [\n            (1, self.type().value, bytes_marshal_binary),  # Transaction Type\n            (2, self.hash, bytes_marshal_binary),  # Transaction Hash\n        ]\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"RemoteTransaction\":\n        \"\"\"\n        Deserialize RemoteTransaction from bytes.\n        \"\"\"\n        reader = io.BytesIO(data)\n\n        # Read the type field\n        tx_type = reader.read(1)\n        if int.from_bytes(tx_type, \"big\") != TransactionType.REMOTE.value:\n            raise ValueError(\"Unexpected transaction type for RemoteTransaction\")\n\n        # Read the transaction hash\n        hash_bytes = reader.read(32)\n        if len(hash_bytes) != 32:\n            raise ValueError(\"Invalid hash length (must be 32 bytes).\")\n\n        return cls(hash_bytes)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert RemoteTransaction to a dictionary.\"\"\"\n        return {\n            \"type\": \"remoteTransaction\",\n            \"hash\": self.hash.hex(),  # Convert bytes to hex for JSON serialization\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.RemoteTransaction.__init__","title":"<code>__init__(hash)</code>","text":"<p>:param hash: The 32-byte transaction hash being referenced.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, hash: bytes):\n    \"\"\"\n    :param hash: The 32-byte transaction hash being referenced.\n    \"\"\"\n    if not isinstance(hash, bytes) or len(hash) != 32:\n        raise ValueError(\"hash must be a 32-byte value.\")\n\n    self.hash = hash  # Store the transaction hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.RemoteTransaction.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"Fields to encode <p>Field 1: Transaction Type (remoteTransaction) Field 2: Transaction Hash (32-byte binary)</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Fields to encode:\n      Field 1: Transaction Type (remoteTransaction)\n      Field 2: Transaction Hash (32-byte binary)\n    \"\"\"\n    return [\n        (1, self.type().value, bytes_marshal_binary),  # Transaction Type\n        (2, self.hash, bytes_marshal_binary),  # Transaction Hash\n    ]\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.RemoteTransaction.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert RemoteTransaction to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert RemoteTransaction to a dictionary.\"\"\"\n    return {\n        \"type\": \"remoteTransaction\",\n        \"hash\": self.hash.hex(),  # Convert bytes to hex for JSON serialization\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.RemoteTransaction.type","title":"<code>type()</code>","text":"<p>Return the transaction type.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def type(self) -&gt; TransactionType:\n    \"\"\"Return the transaction type.\"\"\"\n    return TransactionType.REMOTE\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.RemoteTransaction.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize RemoteTransaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"RemoteTransaction\":\n    \"\"\"\n    Deserialize RemoteTransaction from bytes.\n    \"\"\"\n    reader = io.BytesIO(data)\n\n    # Read the type field\n    tx_type = reader.read(1)\n    if int.from_bytes(tx_type, \"big\") != TransactionType.REMOTE.value:\n        raise ValueError(\"Unexpected transaction type for RemoteTransaction\")\n\n    # Read the transaction hash\n    hash_bytes = reader.read(32)\n    if len(hash_bytes) != 32:\n        raise ValueError(\"Invalid hash length (must be 32 bytes).\")\n\n    return cls(hash_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.SendTokens","title":"<code>SendTokens</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a SendTokens transaction, supporting multiple recipients.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class SendTokens(TransactionBodyBase):\n    \"\"\"\n    Represents a SendTokens transaction, supporting multiple recipients.\n    \"\"\"\n\n    MICRO_UNITS_PER_ACME = 10**8  # 1 ACME = 100,000,000 micro-units\n\n    def __init__(self, recipients: Optional[List[TokenRecipient]] = None):\n        self.recipients = recipients or []\n\n    def add_recipient(self, to: URL, amount: int) -&gt; None:\n        \"\"\"Add a recipient to the transaction, converting ACME to micro-units.\"\"\"\n        if amount &lt;= 0:\n            raise ValueError(\"Amount must be greater than zero\")\n\n        #  Convert ACME to micro-units before storing\n        micro_units = amount * self.MICRO_UNITS_PER_ACME  \n\n        recipient = TokenRecipient(to, micro_units)\n        self.recipients.append(recipient)\n\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return the transaction type.\"\"\"\n        return TransactionType.SEND_TOKENS\n\n    def fields_to_encode(self):\n        return [\n            (1, self.type().value, encode_uvarint),  # Type field\n            (4, self._marshal_recipients(), lambda x: x),  # \"to\" field (will be wrapped by the generic marshal loop)\n        ]\n\n    def _marshal_recipients(self) -&gt; bytes:\n        \"\"\"Encodes the list of TokenRecipients without an extra field wrapper.\n\n        Returns a varint length prefix followed by the concatenated recipient fields.\n        \"\"\"\n        recipients_encoded = b\"\".join([\n            field_marshal_binary(1, string_marshal_binary(str(recipient.url))) +\n            field_marshal_binary(2, big_number_marshal_binary(recipient.amount))  # Now stores micro-units\n            for recipient in self.recipients\n        ])\n        length_prefix = encode_uvarint(len(recipients_encoded))\n        return length_prefix + recipients_encoded\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert SendTokens transaction to a dictionary.\"\"\"\n        return {\n            **super().to_dict(),\n            \"to\": [recipient.to_dict() for recipient in self.recipients]\n        }\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"SendTokens\":\n        \"\"\"Deserialize a SendTokens transaction from bytes.\"\"\"\n        reader = io.BytesIO(data)\n        recipients = []\n\n        # Field 1: Type (should be \"sendTokens\")\n        field_id = reader.read(1)\n        if field_id != b'\\x01':\n            raise ValueError(\"Expected field id 1 for type\")\n        type_value = unmarshal_string(reader)\n        if type_value != \"sendTokens\":\n            raise ValueError(\"Invalid type marker for SendTokens\")\n\n        # Field 4: Recipients\n        while reader.read(1) == b'\\x04':  # Check if the next field is 'to'\n            # Field 1: URL\n            field_id = reader.read(1)\n            if field_id != b'\\x01':\n                raise ValueError(\"Expected field id 1 for recipient URL\")\n            recipient_url = unmarshal_string(reader)\n\n            # Field 2: Amount (micro-units)\n            field_id = reader.read(1)\n            if field_id != b'\\x02':\n                raise ValueError(\"Expected field id 2 for recipient amount\")\n            recipient_amount = int.from_bytes(unmarshal_bytes(reader), byteorder='big')\n\n            recipients.append(TokenRecipient(URL.parse(recipient_url), recipient_amount))\n\n        return cls(recipients)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.SendTokens._marshal_recipients","title":"<code>_marshal_recipients()</code>","text":"<p>Encodes the list of TokenRecipients without an extra field wrapper.</p> <p>Returns a varint length prefix followed by the concatenated recipient fields.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def _marshal_recipients(self) -&gt; bytes:\n    \"\"\"Encodes the list of TokenRecipients without an extra field wrapper.\n\n    Returns a varint length prefix followed by the concatenated recipient fields.\n    \"\"\"\n    recipients_encoded = b\"\".join([\n        field_marshal_binary(1, string_marshal_binary(str(recipient.url))) +\n        field_marshal_binary(2, big_number_marshal_binary(recipient.amount))  # Now stores micro-units\n        for recipient in self.recipients\n    ])\n    length_prefix = encode_uvarint(len(recipients_encoded))\n    return length_prefix + recipients_encoded\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.SendTokens.add_recipient","title":"<code>add_recipient(to, amount)</code>","text":"<p>Add a recipient to the transaction, converting ACME to micro-units.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def add_recipient(self, to: URL, amount: int) -&gt; None:\n    \"\"\"Add a recipient to the transaction, converting ACME to micro-units.\"\"\"\n    if amount &lt;= 0:\n        raise ValueError(\"Amount must be greater than zero\")\n\n    #  Convert ACME to micro-units before storing\n    micro_units = amount * self.MICRO_UNITS_PER_ACME  \n\n    recipient = TokenRecipient(to, micro_units)\n    self.recipients.append(recipient)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.SendTokens.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert SendTokens transaction to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert SendTokens transaction to a dictionary.\"\"\"\n    return {\n        **super().to_dict(),\n        \"to\": [recipient.to_dict() for recipient in self.recipients]\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.SendTokens.type","title":"<code>type()</code>","text":"<p>Return the transaction type.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def type(self) -&gt; TransactionType:\n    \"\"\"Return the transaction type.\"\"\"\n    return TransactionType.SEND_TOKENS\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.SendTokens.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a SendTokens transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"SendTokens\":\n    \"\"\"Deserialize a SendTokens transaction from bytes.\"\"\"\n    reader = io.BytesIO(data)\n    recipients = []\n\n    # Field 1: Type (should be \"sendTokens\")\n    field_id = reader.read(1)\n    if field_id != b'\\x01':\n        raise ValueError(\"Expected field id 1 for type\")\n    type_value = unmarshal_string(reader)\n    if type_value != \"sendTokens\":\n        raise ValueError(\"Invalid type marker for SendTokens\")\n\n    # Field 4: Recipients\n    while reader.read(1) == b'\\x04':  # Check if the next field is 'to'\n        # Field 1: URL\n        field_id = reader.read(1)\n        if field_id != b'\\x01':\n            raise ValueError(\"Expected field id 1 for recipient URL\")\n        recipient_url = unmarshal_string(reader)\n\n        # Field 2: Amount (micro-units)\n        field_id = reader.read(1)\n        if field_id != b'\\x02':\n            raise ValueError(\"Expected field id 2 for recipient amount\")\n        recipient_amount = int.from_bytes(unmarshal_bytes(reader), byteorder='big')\n\n        recipients.append(TokenRecipient(URL.parse(recipient_url), recipient_amount))\n\n    return cls(recipients)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction","title":"<code>Transaction</code>","text":"Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class Transaction:\n    def __init__(self, header: \"TransactionHeader\", body: Optional[\"TransactionBodyBase\"] = None):\n        self.header = header\n        self.body = body\n        self.hash: Optional[bytes] = None\n        self.signers: List[\"Signer\"] = []\n\n\n    def is_remote(self) -&gt; bool:\n        \"\"\"Check if this transaction is a RemoteTransaction.\"\"\"\n        return isinstance(self.body, RemoteTransaction)\n\n    @classmethod\n    async def create(cls, client, signer: \"Signer\", transaction_type: TransactionType, *args, **kwargs) -&gt; \"Transaction\":\n        \"\"\"\n        Fully constructs a transaction, including the header and body.\n\n        :param client: AccumulateClient instance\n        :param signer: Signer instance\n        :param transaction_type: The type of transaction to create\n        :param args: Additional arguments passed to the transaction body\n        :param kwargs: Additional keyword arguments for the transaction body\n        :return: A fully constructed Transaction instance\n        \"\"\"\n        # Extract public key from signer\n        public_key = signer.get_public_key()\n        recipient = kwargs.get(\"recipient\")\n\n        #  Create Transaction Header (handles initiator hash internally)\n        tx_header = await TransactionHeader.create(recipient, public_key, signer)\n\n        #  Create Transaction Body using the Factory\n        tx_body = await TransactionBodyFactory.create(client, transaction_type, *args, **kwargs)\n\n        return cls(header=tx_header, body=tx_body)\n\n\n    def add_signer(self, url: \"URL\", version: int) -&gt; None:\n        \"\"\"Add a signer dynamically.\"\"\"\n        signer = get_signer()(url, version)\n        self.signers.append(signer)\n\n    def get_signer(self, url: \"URL\") -&gt; Optional[\"Signer\"]:\n        \"\"\"Retrieve a signer dynamically.\"\"\"\n        return next((signer for signer in self.signers if signer.get_url() == url), None)\n\n    def is_user(self) -&gt; bool:\n        \"\"\"Check if the transaction is initiated by a user.\"\"\"\n        return self.body is not None and self.body.type().is_user()\n\n\n    def get_hash(self) -&gt; bytes:\n        \"\"\"Compute transaction hash ensuring Accumulate's hashing order.\"\"\"\n\n        #  If it's a Remote Transaction, return its referenced hash\n        if isinstance(self.body, RemoteTransaction):\n            logger.debug(\" Using referenced hash for RemoteTransaction\")\n            return self.body.hash  # Remote transactions use the referenced hash directly\n\n        #  Compute transaction hash if not already cached\n        if not self.hash:\n            logger.debug(\" Computing transaction hash...\")\n\n            #  Step 1: Hash the header\n            header_bytes = self.header.marshal_binary()\n            header_hash = hashlib.sha256(header_bytes).digest()\n            logger.info(f\" Hashed Header: {header_hash.hex()}\")  # Log Header Hash\n\n            #  Step 2: Special handling for WriteData transactions\n            if isinstance(self.body, WriteData):\n                logger.debug(\" Special WriteData hashing logic applied\")\n\n                #  Hash body WITHOUT the entry\n                body_without_entry = self.body.marshal_without_entry()\n                body_hash = hashlib.sha256(body_without_entry).digest()\n                logger.info(f\" Hashed Body (without entry): {body_hash.hex()}\")  # Log Body Hash (without entry)\n\n                #  Hash entry separately\n                entry_hash = self.body.hash_tree()\n                logger.info(f\" Hashed Entry (Merkle + SHA-256): {entry_hash.hex()}\")  # Log Entry Hash\n\n                #  Step 3: Combine and hash again\n                final_body_hash = hashlib.sha256(body_hash + entry_hash).digest()\n                logger.info(f\" Final Hashed Body: {final_body_hash.hex()}\")  # Log Final Body Hash\n            else:\n                #  Standard transactions\n                body_bytes = self.body.marshal() if self.body else b\"\"\n                final_body_hash = hashlib.sha256(body_bytes).digest()\n                logger.info(f\" Standard Hashed Body: {final_body_hash.hex()}\")  # Log Body Hash\n\n            #  Final hash: H(H(header) + H(body))\n            self.hash = hashlib.sha256(header_hash + final_body_hash).digest()\n            logger.info(f\" FINAL Transaction Hash: {self.hash.hex()}\")  # Log Final Transaction Hash\n\n        return self.hash\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert a Transaction into a dictionary format suitable for submission.\"\"\"\n        if not self.header or not self.body:\n            raise ValueError(\"Transaction must have both header and body set.\")\n\n        return {\n            \"header\": self.header.to_dict(),\n            \"body\": self.body.to_dict() if self.body else None,\n        }\n\n    def get_id(self) -&gt; TxID:\n        \"\"\"Get the transaction ID based on its hash and principal URL.\"\"\"\n        url = URL.parse(self.header.principal) if self.header.principal else URL(authority=\"unknown\", path=\"\")\n        return TxID(url=url, tx_hash=self.get_hash())\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"\n        Serialize the transaction to bytes.\n        Format:\n          [header length (varint)] + [header bytes]\n          [body length (varint)] + [body bytes]\n        \"\"\"\n        header_data = self.header.marshal_binary()\n        header_length = encode_uvarint(len(header_data))\n\n        body_data = self.body.marshal() if self.body else b\"\"\n        body_length = encode_uvarint(len(body_data))\n\n        return header_length + header_data + body_length + body_data\n\n    @staticmethod\n    def unmarshal(data: bytes) -&gt; \"Transaction\":\n        \"\"\"\n        Deserialize a Transaction from bytes.\n        Format:\n          [header length (varint)] + [header bytes]\n          [body length (varint)] + [body bytes]\n        \"\"\"\n        reader = io.BytesIO(data)\n\n        # Read header length\n        header_length = read_uvarint(reader)\n        header_data = reader.read(header_length)\n        header = TransactionHeader.unmarshal(header_data)\n\n        # Read body length\n        body_length = read_uvarint(reader)\n        body_data = reader.read(body_length) if body_length &gt; 0 else b\"\"\n        body = TransactionBodyBase.unmarshal(body_data) if body_data else None\n\n        return Transaction(header, body)\n\n    def get_body_hash(self) -&gt; bytes:\n        \"\"\"Compute the hash of the transaction body separately for debugging.\"\"\"\n        if not self.body:\n            return hashlib.sha256(b\"\").digest()\n\n        body_bytes = self.body.marshal()\n        return hashlib.sha256(body_bytes).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.add_signer","title":"<code>add_signer(url, version)</code>","text":"<p>Add a signer dynamically.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def add_signer(self, url: \"URL\", version: int) -&gt; None:\n    \"\"\"Add a signer dynamically.\"\"\"\n    signer = get_signer()(url, version)\n    self.signers.append(signer)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.create","title":"<code>create(client, signer, transaction_type, *args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Fully constructs a transaction, including the header and body.</p> <p>:param client: AccumulateClient instance :param signer: Signer instance :param transaction_type: The type of transaction to create :param args: Additional arguments passed to the transaction body :param kwargs: Additional keyword arguments for the transaction body :return: A fully constructed Transaction instance</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\nasync def create(cls, client, signer: \"Signer\", transaction_type: TransactionType, *args, **kwargs) -&gt; \"Transaction\":\n    \"\"\"\n    Fully constructs a transaction, including the header and body.\n\n    :param client: AccumulateClient instance\n    :param signer: Signer instance\n    :param transaction_type: The type of transaction to create\n    :param args: Additional arguments passed to the transaction body\n    :param kwargs: Additional keyword arguments for the transaction body\n    :return: A fully constructed Transaction instance\n    \"\"\"\n    # Extract public key from signer\n    public_key = signer.get_public_key()\n    recipient = kwargs.get(\"recipient\")\n\n    #  Create Transaction Header (handles initiator hash internally)\n    tx_header = await TransactionHeader.create(recipient, public_key, signer)\n\n    #  Create Transaction Body using the Factory\n    tx_body = await TransactionBodyFactory.create(client, transaction_type, *args, **kwargs)\n\n    return cls(header=tx_header, body=tx_body)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.get_body_hash","title":"<code>get_body_hash()</code>","text":"<p>Compute the hash of the transaction body separately for debugging.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def get_body_hash(self) -&gt; bytes:\n    \"\"\"Compute the hash of the transaction body separately for debugging.\"\"\"\n    if not self.body:\n        return hashlib.sha256(b\"\").digest()\n\n    body_bytes = self.body.marshal()\n    return hashlib.sha256(body_bytes).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.get_hash","title":"<code>get_hash()</code>","text":"<p>Compute transaction hash ensuring Accumulate's hashing order.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def get_hash(self) -&gt; bytes:\n    \"\"\"Compute transaction hash ensuring Accumulate's hashing order.\"\"\"\n\n    #  If it's a Remote Transaction, return its referenced hash\n    if isinstance(self.body, RemoteTransaction):\n        logger.debug(\" Using referenced hash for RemoteTransaction\")\n        return self.body.hash  # Remote transactions use the referenced hash directly\n\n    #  Compute transaction hash if not already cached\n    if not self.hash:\n        logger.debug(\" Computing transaction hash...\")\n\n        #  Step 1: Hash the header\n        header_bytes = self.header.marshal_binary()\n        header_hash = hashlib.sha256(header_bytes).digest()\n        logger.info(f\" Hashed Header: {header_hash.hex()}\")  # Log Header Hash\n\n        #  Step 2: Special handling for WriteData transactions\n        if isinstance(self.body, WriteData):\n            logger.debug(\" Special WriteData hashing logic applied\")\n\n            #  Hash body WITHOUT the entry\n            body_without_entry = self.body.marshal_without_entry()\n            body_hash = hashlib.sha256(body_without_entry).digest()\n            logger.info(f\" Hashed Body (without entry): {body_hash.hex()}\")  # Log Body Hash (without entry)\n\n            #  Hash entry separately\n            entry_hash = self.body.hash_tree()\n            logger.info(f\" Hashed Entry (Merkle + SHA-256): {entry_hash.hex()}\")  # Log Entry Hash\n\n            #  Step 3: Combine and hash again\n            final_body_hash = hashlib.sha256(body_hash + entry_hash).digest()\n            logger.info(f\" Final Hashed Body: {final_body_hash.hex()}\")  # Log Final Body Hash\n        else:\n            #  Standard transactions\n            body_bytes = self.body.marshal() if self.body else b\"\"\n            final_body_hash = hashlib.sha256(body_bytes).digest()\n            logger.info(f\" Standard Hashed Body: {final_body_hash.hex()}\")  # Log Body Hash\n\n        #  Final hash: H(H(header) + H(body))\n        self.hash = hashlib.sha256(header_hash + final_body_hash).digest()\n        logger.info(f\" FINAL Transaction Hash: {self.hash.hex()}\")  # Log Final Transaction Hash\n\n    return self.hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.get_id","title":"<code>get_id()</code>","text":"<p>Get the transaction ID based on its hash and principal URL.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def get_id(self) -&gt; TxID:\n    \"\"\"Get the transaction ID based on its hash and principal URL.\"\"\"\n    url = URL.parse(self.header.principal) if self.header.principal else URL(authority=\"unknown\", path=\"\")\n    return TxID(url=url, tx_hash=self.get_hash())\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.get_signer","title":"<code>get_signer(url)</code>","text":"<p>Retrieve a signer dynamically.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def get_signer(self, url: \"URL\") -&gt; Optional[\"Signer\"]:\n    \"\"\"Retrieve a signer dynamically.\"\"\"\n    return next((signer for signer in self.signers if signer.get_url() == url), None)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.is_remote","title":"<code>is_remote()</code>","text":"<p>Check if this transaction is a RemoteTransaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def is_remote(self) -&gt; bool:\n    \"\"\"Check if this transaction is a RemoteTransaction.\"\"\"\n    return isinstance(self.body, RemoteTransaction)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.is_user","title":"<code>is_user()</code>","text":"<p>Check if the transaction is initiated by a user.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def is_user(self) -&gt; bool:\n    \"\"\"Check if the transaction is initiated by a user.\"\"\"\n    return self.body is not None and self.body.type().is_user()\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.marshal","title":"<code>marshal()</code>","text":"<p>Serialize the transaction to bytes. Format:   [header length (varint)] + [header bytes]   [body length (varint)] + [body bytes]</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"\n    Serialize the transaction to bytes.\n    Format:\n      [header length (varint)] + [header bytes]\n      [body length (varint)] + [body bytes]\n    \"\"\"\n    header_data = self.header.marshal_binary()\n    header_length = encode_uvarint(len(header_data))\n\n    body_data = self.body.marshal() if self.body else b\"\"\n    body_length = encode_uvarint(len(body_data))\n\n    return header_length + header_data + body_length + body_data\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert a Transaction into a dictionary format suitable for submission.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert a Transaction into a dictionary format suitable for submission.\"\"\"\n    if not self.header or not self.body:\n        raise ValueError(\"Transaction must have both header and body set.\")\n\n    return {\n        \"header\": self.header.to_dict(),\n        \"body\": self.body.to_dict() if self.body else None,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.Transaction.unmarshal","title":"<code>unmarshal(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize a Transaction from bytes. Format:   [header length (varint)] + [header bytes]   [body length (varint)] + [body bytes]</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef unmarshal(data: bytes) -&gt; \"Transaction\":\n    \"\"\"\n    Deserialize a Transaction from bytes.\n    Format:\n      [header length (varint)] + [header bytes]\n      [body length (varint)] + [body bytes]\n    \"\"\"\n    reader = io.BytesIO(data)\n\n    # Read header length\n    header_length = read_uvarint(reader)\n    header_data = reader.read(header_length)\n    header = TransactionHeader.unmarshal(header_data)\n\n    # Read body length\n    body_length = read_uvarint(reader)\n    body_data = reader.read(body_length) if body_length &gt; 0 else b\"\"\n    body = TransactionBodyBase.unmarshal(body_data) if body_data else None\n\n    return Transaction(header, body)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus","title":"<code>TransactionStatus</code>","text":"Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class TransactionStatus:\n    def __init__(\n        self,\n        tx_id: Optional[str] = None,\n        code: int = 0,\n        error: Optional[\"AccumulateError\"] = None,\n        result: Optional[\"TransactionResult\"] = None,\n        received: Optional[int] = None,\n        initiator: Optional[\"URL\"] = None,\n    ):\n        self.tx_id = tx_id\n        self.code = code\n        self.error = error\n        self.result = result\n        self.received = received\n        self.initiator = initiator\n        self.signers: List[\"Signer\"] = []\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.TRANSACTION_STATUS\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serialize the TransactionStatus to a dictionary.\"\"\"\n        return {\n            \"tx_id\": self.tx_id,\n            \"code\": self.code,\n            \"error\": str(self.error) if self.error else None,\n            \"result\": self.result.to_dict() if self.result else None,\n            \"received\": self.received,\n            \"initiator\": str(self.initiator) if self.initiator else None,\n            \"signers\": [signer.to_dict() for signer in self.signers] if self.signers else [],\n        }\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"Serialize TransactionStatus to bytes using Accumulate encoding.\"\"\"\n        print(\"DEBUG: Marshaling TransactionStatus\")\n\n        # Serialize tx_id (string with length prefix)\n        tx_id_data = string_marshal_binary(self.tx_id) if self.tx_id else b\"\"\n\n        # Serialize code (varint)\n        code_data = encode_uvarint(self.code)\n\n        # Serialize error (string with length prefix)\n        error_data = string_marshal_binary(str(self.error)) if self.error else b\"\"\n\n        # Serialize result (JSON-like structure)\n        result_data = bytes_marshal_binary(json.dumps(self.result.to_dict()).encode()) if self.result else b\"\"\n\n        # Serialize received timestamp (varint)\n        received_data = encode_uvarint(self.received) if self.received else b\"\"\n\n        # Serialize initiator (URL as string)\n        initiator_data = string_marshal_binary(str(self.initiator)) if self.initiator else b\"\"\n\n        # Serialize signers (list of signers)\n        signers_data = b\"\".join([signer.marshal() for signer in self.signers])\n        signers_length = encode_uvarint(len(self.signers))  # Prefix with number of signers\n\n        # Combine all components\n        serialized = (\n            tx_id_data + code_data + error_data + result_data +\n            received_data + initiator_data + signers_length + signers_data\n        )\n\n        print(f\"DEBUG: Marshaled TransactionStatus: {serialized.hex()}\")\n        return serialized\n\n    @staticmethod\n    def unmarshal(data: bytes) -&gt; \"TransactionStatus\":\n        \"\"\"Deserialize TransactionStatus from bytes.\"\"\"\n        print(\"DEBUG: Unmarshaling TransactionStatus\")\n        reader = io.BytesIO(data)\n\n        # Read tx_id\n        tx_id = unmarshal_string(reader.read())\n\n        # Read code (varint)\n        code, _ = decode_uvarint(reader.read())\n\n        # Read error\n        error_str = unmarshal_string(reader.read())\n        error = AccumulateError(error_str) if error_str else None\n\n        # Read result\n        result_data = unmarshal_bytes(reader.read())\n        result = TransactionResult(json.loads(result_data.decode())) if result_data else None\n\n        # Read received timestamp\n        received, _ = decode_uvarint(reader.read())\n\n        # Read initiator\n        initiator_str = unmarshal_string(reader.read())\n        initiator = URL.parse(initiator_str) if initiator_str else None\n\n        # Read signers\n        signers_count, _ = decode_uvarint(reader.read())\n        signers = []\n        for _ in range(signers_count):\n            signer = \"Signer\".unmarshal(reader.read())\n            signers.append(signer)\n\n        print(f\"DEBUG: Parsed TransactionStatus: tx_id={tx_id}, code={code}, error={error}, \"\n              f\"result={result}, received={received}, initiator={initiator}, signers={signers}\")\n\n        return TransactionStatus(\n            tx_id=tx_id, code=code, error=error, result=result,\n            received=received, initiator=initiator, signers=signers\n        )\n\n    def delivered(self) -&gt; bool:\n        return self.code == ErrorCode.OK.value\n\n    def remote(self) -&gt; bool:\n        return self.code == ErrorCode.FAILED.value\n\n    def pending(self) -&gt; bool:\n        return self.code == ErrorCode.DID_PANIC.value\n\n    def failed(self) -&gt; bool:\n        return self.code != ErrorCode.OK.value\n\n    def set(self, error: Optional[AccumulateError]) -&gt; None:\n        \"\"\"Set the error and update the status code based on the provided error.\"\"\"\n        self.error = error\n        if error and error.code:\n            self.code = error.code.value\n        else:\n            self.code = ErrorCode.UNKNOWN_ERROR.value\n\n    def as_error(self) -&gt; Optional[Exception]:\n        return self.error if self.error else None\n\n    def add_signer(self, url: \"URL\", version: int) -&gt; None:\n        \"\"\"Add a signer dynamically.\"\"\"\n        signer = get_signer()(url, version)\n        existing = next((s for s in self.signers if s.get_url() == signer.get_url()), None)\n        if not existing or signer.get_version() &gt; existing.get_version():\n            self.signers.append(signer)\n\n    def get_signer(self, url: \"URL\") -&gt; Optional[\"Signer\"]:\n        \"\"\"Retrieve a signer dynamically\"\"\"\n        for signer in self.signers:\n            if signer.get_url() == url:\n                return signer\n        return None\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus.add_signer","title":"<code>add_signer(url, version)</code>","text":"<p>Add a signer dynamically.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def add_signer(self, url: \"URL\", version: int) -&gt; None:\n    \"\"\"Add a signer dynamically.\"\"\"\n    signer = get_signer()(url, version)\n    existing = next((s for s in self.signers if s.get_url() == signer.get_url()), None)\n    if not existing or signer.get_version() &gt; existing.get_version():\n        self.signers.append(signer)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus.get_signer","title":"<code>get_signer(url)</code>","text":"<p>Retrieve a signer dynamically</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def get_signer(self, url: \"URL\") -&gt; Optional[\"Signer\"]:\n    \"\"\"Retrieve a signer dynamically\"\"\"\n    for signer in self.signers:\n        if signer.get_url() == url:\n            return signer\n    return None\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus.marshal","title":"<code>marshal()</code>","text":"<p>Serialize TransactionStatus to bytes using Accumulate encoding.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"Serialize TransactionStatus to bytes using Accumulate encoding.\"\"\"\n    print(\"DEBUG: Marshaling TransactionStatus\")\n\n    # Serialize tx_id (string with length prefix)\n    tx_id_data = string_marshal_binary(self.tx_id) if self.tx_id else b\"\"\n\n    # Serialize code (varint)\n    code_data = encode_uvarint(self.code)\n\n    # Serialize error (string with length prefix)\n    error_data = string_marshal_binary(str(self.error)) if self.error else b\"\"\n\n    # Serialize result (JSON-like structure)\n    result_data = bytes_marshal_binary(json.dumps(self.result.to_dict()).encode()) if self.result else b\"\"\n\n    # Serialize received timestamp (varint)\n    received_data = encode_uvarint(self.received) if self.received else b\"\"\n\n    # Serialize initiator (URL as string)\n    initiator_data = string_marshal_binary(str(self.initiator)) if self.initiator else b\"\"\n\n    # Serialize signers (list of signers)\n    signers_data = b\"\".join([signer.marshal() for signer in self.signers])\n    signers_length = encode_uvarint(len(self.signers))  # Prefix with number of signers\n\n    # Combine all components\n    serialized = (\n        tx_id_data + code_data + error_data + result_data +\n        received_data + initiator_data + signers_length + signers_data\n    )\n\n    print(f\"DEBUG: Marshaled TransactionStatus: {serialized.hex()}\")\n    return serialized\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus.set","title":"<code>set(error)</code>","text":"<p>Set the error and update the status code based on the provided error.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def set(self, error: Optional[AccumulateError]) -&gt; None:\n    \"\"\"Set the error and update the status code based on the provided error.\"\"\"\n    self.error = error\n    if error and error.code:\n        self.code = error.code.value\n    else:\n        self.code = ErrorCode.UNKNOWN_ERROR.value\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the TransactionStatus to a dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serialize the TransactionStatus to a dictionary.\"\"\"\n    return {\n        \"tx_id\": self.tx_id,\n        \"code\": self.code,\n        \"error\": str(self.error) if self.error else None,\n        \"result\": self.result.to_dict() if self.result else None,\n        \"received\": self.received,\n        \"initiator\": str(self.initiator) if self.initiator else None,\n        \"signers\": [signer.to_dict() for signer in self.signers] if self.signers else [],\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransactionStatus.unmarshal","title":"<code>unmarshal(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize TransactionStatus from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef unmarshal(data: bytes) -&gt; \"TransactionStatus\":\n    \"\"\"Deserialize TransactionStatus from bytes.\"\"\"\n    print(\"DEBUG: Unmarshaling TransactionStatus\")\n    reader = io.BytesIO(data)\n\n    # Read tx_id\n    tx_id = unmarshal_string(reader.read())\n\n    # Read code (varint)\n    code, _ = decode_uvarint(reader.read())\n\n    # Read error\n    error_str = unmarshal_string(reader.read())\n    error = AccumulateError(error_str) if error_str else None\n\n    # Read result\n    result_data = unmarshal_bytes(reader.read())\n    result = TransactionResult(json.loads(result_data.decode())) if result_data else None\n\n    # Read received timestamp\n    received, _ = decode_uvarint(reader.read())\n\n    # Read initiator\n    initiator_str = unmarshal_string(reader.read())\n    initiator = URL.parse(initiator_str) if initiator_str else None\n\n    # Read signers\n    signers_count, _ = decode_uvarint(reader.read())\n    signers = []\n    for _ in range(signers_count):\n        signer = \"Signer\".unmarshal(reader.read())\n        signers.append(signer)\n\n    print(f\"DEBUG: Parsed TransactionStatus: tx_id={tx_id}, code={code}, error={error}, \"\n          f\"result={result}, received={received}, initiator={initiator}, signers={signers}\")\n\n    return TransactionStatus(\n        tx_id=tx_id, code=code, error=error, result=result,\n        received=received, initiator=initiator, signers=signers\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransferCredits","title":"<code>TransferCredits</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class TransferCredits(TransactionBodyBase):\n    def __init__(self, to: List[CreditRecipient]):\n        \"\"\"\n        Represents a Transfer Credits transaction.\n\n        :param to: A list of CreditRecipient objects.\n        \"\"\"\n        if not isinstance(to, list) or not all(isinstance(recipient, CreditRecipient) for recipient in to):\n            raise TypeError(\"to must be a list of CreditRecipient instances.\")\n        self.to = to\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.TRANSFER_CREDITS\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"Serialize TransferCredits transaction to bytes.\"\"\"\n        print(\"DEBUG: Marshaling TransferCredits\")\n\n        # Serialize number of recipients\n        recipients_count = encode_uvarint(len(self.to))\n\n        # Serialize each recipient\n        recipients_data = b\"\".join([bytes_marshal_binary(recipient.marshal()) for recipient in self.to])\n\n        # Combine all marshaled components\n        serialized = recipients_count + recipients_data\n        print(f\"DEBUG: Marshaled TransferCredits: {serialized.hex()}\")\n        return serialized\n\n    @staticmethod\n    def unmarshal(data: bytes) -&gt; \"TransferCredits\":\n        \"\"\"Deserialize TransferCredits transaction from bytes.\"\"\"\n        print(\"DEBUG: Unmarshaling TransferCredits\")\n\n        reader = io.BytesIO(data)\n\n        # Read number of recipients\n        recipients_count, _ = decode_uvarint(reader.read())\n\n        recipients = []\n        for _ in range(recipients_count):\n            recipient_length, _ = decode_uvarint(reader.read())  # Read recipient length\n            recipient_data = reader.read(recipient_length)  # Read recipient data\n            recipients.append(CreditRecipient.unmarshal(recipient_data))\n\n        print(f\"DEBUG: Parsed TransferCredits: recipients={recipients}\")\n        return TransferCredits(recipients)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransferCredits.__init__","title":"<code>__init__(to)</code>","text":"<p>Represents a Transfer Credits transaction.</p> <p>:param to: A list of CreditRecipient objects.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, to: List[CreditRecipient]):\n    \"\"\"\n    Represents a Transfer Credits transaction.\n\n    :param to: A list of CreditRecipient objects.\n    \"\"\"\n    if not isinstance(to, list) or not all(isinstance(recipient, CreditRecipient) for recipient in to):\n        raise TypeError(\"to must be a list of CreditRecipient instances.\")\n    self.to = to\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransferCredits.marshal","title":"<code>marshal()</code>","text":"<p>Serialize TransferCredits transaction to bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"Serialize TransferCredits transaction to bytes.\"\"\"\n    print(\"DEBUG: Marshaling TransferCredits\")\n\n    # Serialize number of recipients\n    recipients_count = encode_uvarint(len(self.to))\n\n    # Serialize each recipient\n    recipients_data = b\"\".join([bytes_marshal_binary(recipient.marshal()) for recipient in self.to])\n\n    # Combine all marshaled components\n    serialized = recipients_count + recipients_data\n    print(f\"DEBUG: Marshaled TransferCredits: {serialized.hex()}\")\n    return serialized\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.TransferCredits.unmarshal","title":"<code>unmarshal(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize TransferCredits transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef unmarshal(data: bytes) -&gt; \"TransferCredits\":\n    \"\"\"Deserialize TransferCredits transaction from bytes.\"\"\"\n    print(\"DEBUG: Unmarshaling TransferCredits\")\n\n    reader = io.BytesIO(data)\n\n    # Read number of recipients\n    recipients_count, _ = decode_uvarint(reader.read())\n\n    recipients = []\n    for _ in range(recipients_count):\n        recipient_length, _ = decode_uvarint(reader.read())  # Read recipient length\n        recipient_data = reader.read(recipient_length)  # Read recipient data\n        recipients.append(CreditRecipient.unmarshal(recipient_data))\n\n    print(f\"DEBUG: Parsed TransferCredits: recipients={recipients}\")\n    return TransferCredits(recipients)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth","title":"<code>UpdateAccountAuth</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents an Update Account Auth transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@dataclass\nclass UpdateAccountAuth(TransactionBodyBase):\n    \"\"\"\n    Represents an Update Account Auth transaction.\n    \"\"\"\n    account_url: URL\n    operations: List[Dict[str, str]]  # Each dict must have keys \"type\" and \"authority\"\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.UPDATE_ACCOUNT_AUTH\n\n    def fields_to_encode(self):\n        \"\"\"\n        Field 1: Transaction type as a varint.\n        Field 2: Operations as a length-prefixed list.\n        \"\"\"\n        fields = [\n            # Field 1: Transaction type (updateAccountAuth) encoded as a varint\n            (1, encode_uvarint(self.type().value), lambda x: x),\n            # Field 2: Operations\n            (2, self._marshal_operations(), lambda x: x) if self.operations else None,\n        ]\n        return [field for field in fields if field is not None]\n\n    def _marshal_operations(self) -&gt; bytes:\n        \"\"\"Serialize operations as a length-prefixed binary format.\"\"\"\n        if not self.operations:\n            return b\"\"\n        operations_data = b\"\".join([self._marshal_operation(op) for op in self.operations])\n        operations_length = encode_uvarint(len(operations_data))\n        return operations_length + operations_data\n\n    @staticmethod\n    def _marshal_operation(operation: Dict[str, str]) -&gt; bytes:\n        \"\"\"\n        Serialize a single operation into bytes.\n        Expected structure for addAuthority:\n          - Nested field 1 (tag 0x01): Operation type (varint).\n          - Nested field 2 (tag 0x02): Authority (length-prefixed string).\n        \"\"\"\n        if \"type\" not in operation or \"authority\" not in operation:\n            raise ValueError(f\"Invalid operation entry: missing 'type' or 'authority' field in {operation}\")\n\n        # Normalize and lookup the enum value.\n        normalized_type = normalize_operation_type(operation[\"type\"])\n        try:\n            operation_type_enum = AccountAuthOperationType[normalized_type]\n        except KeyError as e:\n            raise ValueError(f\"Operation type '{operation.get('type')}' is not valid: {e}\")\n\n        # Nested field 1: Operation type (tag 0x01)\n        op_type_field = b'\\x01' + encode_uvarint(operation_type_enum.value)\n        # Nested field 2: Authority (tag 0x02, using string_marshal_binary for proper length prefix)\n        auth_field = b'\\x02' + string_marshal_binary(operation[\"authority\"])\n        return op_type_field + auth_field\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert transaction body to a JSON\u2011serializable dictionary.\"\"\"\n        return {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"operations\": [\n                {\n                    \"type\": operation[\"type\"],\n                    \"authority\": operation[\"authority\"]\n                }\n                for operation in self.operations\n            ],\n        }\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"UpdateAccountAuth\":\n        \"\"\"Deserialize UpdateAccountAuth transaction from bytes.\"\"\"\n        logger.debug(f\" Unmarshaling UpdateAccountAuth: {data.hex()}\")\n        reader = io.BytesIO(data)\n\n        # Field 1: Transaction type (we ignore the value here)\n        _ = decode_uvarint(unmarshal_bytes(reader))\n        # Field 2: Operations\n        operations_length, _ = decode_uvarint(reader.read())\n        operations_data = reader.read(operations_length)\n        operations = cls._unmarshal_operations(operations_data)\n        logger.debug(f\" Parsed UpdateAccountAuth: Operations={operations}\")\n        # The account_url is not encoded in the body, it is typically set in the header\n        return cls(account_url=None, operations=operations)  # account_url may be set elsewhere\n\n    @staticmethod\n    def _unmarshal_operations(data: bytes) -&gt; List[Dict[str, str]]:\n        \"\"\"Deserialize operations from a byte stream.\"\"\"\n        operations = []\n        reader = io.BytesIO(data)\n        while reader.tell() &lt; len(data):\n            # Nested field 1: Operation type\n            op_type = decode_uvarint(reader.read())[0]\n            op_type_str = AccountAuthOperationType(op_type).name.lower()\n            # Nested field 2: Authority\n            authority = unmarshal_bytes(reader).decode(\"utf-8\")\n            operations.append({\"type\": op_type_str, \"authority\": authority})\n        return operations\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth._marshal_operation","title":"<code>_marshal_operation(operation)</code>  <code>staticmethod</code>","text":"<p>Serialize a single operation into bytes. Expected structure for addAuthority:   - Nested field 1 (tag 0x01): Operation type (varint).   - Nested field 2 (tag 0x02): Authority (length-prefixed string).</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef _marshal_operation(operation: Dict[str, str]) -&gt; bytes:\n    \"\"\"\n    Serialize a single operation into bytes.\n    Expected structure for addAuthority:\n      - Nested field 1 (tag 0x01): Operation type (varint).\n      - Nested field 2 (tag 0x02): Authority (length-prefixed string).\n    \"\"\"\n    if \"type\" not in operation or \"authority\" not in operation:\n        raise ValueError(f\"Invalid operation entry: missing 'type' or 'authority' field in {operation}\")\n\n    # Normalize and lookup the enum value.\n    normalized_type = normalize_operation_type(operation[\"type\"])\n    try:\n        operation_type_enum = AccountAuthOperationType[normalized_type]\n    except KeyError as e:\n        raise ValueError(f\"Operation type '{operation.get('type')}' is not valid: {e}\")\n\n    # Nested field 1: Operation type (tag 0x01)\n    op_type_field = b'\\x01' + encode_uvarint(operation_type_enum.value)\n    # Nested field 2: Authority (tag 0x02, using string_marshal_binary for proper length prefix)\n    auth_field = b'\\x02' + string_marshal_binary(operation[\"authority\"])\n    return op_type_field + auth_field\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth._marshal_operations","title":"<code>_marshal_operations()</code>","text":"<p>Serialize operations as a length-prefixed binary format.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def _marshal_operations(self) -&gt; bytes:\n    \"\"\"Serialize operations as a length-prefixed binary format.\"\"\"\n    if not self.operations:\n        return b\"\"\n    operations_data = b\"\".join([self._marshal_operation(op) for op in self.operations])\n    operations_length = encode_uvarint(len(operations_data))\n    return operations_length + operations_data\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth._unmarshal_operations","title":"<code>_unmarshal_operations(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize operations from a byte stream.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef _unmarshal_operations(data: bytes) -&gt; List[Dict[str, str]]:\n    \"\"\"Deserialize operations from a byte stream.\"\"\"\n    operations = []\n    reader = io.BytesIO(data)\n    while reader.tell() &lt; len(data):\n        # Nested field 1: Operation type\n        op_type = decode_uvarint(reader.read())[0]\n        op_type_str = AccountAuthOperationType(op_type).name.lower()\n        # Nested field 2: Authority\n        authority = unmarshal_bytes(reader).decode(\"utf-8\")\n        operations.append({\"type\": op_type_str, \"authority\": authority})\n    return operations\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Field 1: Transaction type as a varint. Field 2: Operations as a length-prefixed list.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Field 1: Transaction type as a varint.\n    Field 2: Operations as a length-prefixed list.\n    \"\"\"\n    fields = [\n        # Field 1: Transaction type (updateAccountAuth) encoded as a varint\n        (1, encode_uvarint(self.type().value), lambda x: x),\n        # Field 2: Operations\n        (2, self._marshal_operations(), lambda x: x) if self.operations else None,\n    ]\n    return [field for field in fields if field is not None]\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert transaction body to a JSON\u2011serializable dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert transaction body to a JSON\u2011serializable dictionary.\"\"\"\n    return {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"operations\": [\n            {\n                \"type\": operation[\"type\"],\n                \"authority\": operation[\"authority\"]\n            }\n            for operation in self.operations\n        ],\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateAccountAuth.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize UpdateAccountAuth transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"UpdateAccountAuth\":\n    \"\"\"Deserialize UpdateAccountAuth transaction from bytes.\"\"\"\n    logger.debug(f\" Unmarshaling UpdateAccountAuth: {data.hex()}\")\n    reader = io.BytesIO(data)\n\n    # Field 1: Transaction type (we ignore the value here)\n    _ = decode_uvarint(unmarshal_bytes(reader))\n    # Field 2: Operations\n    operations_length, _ = decode_uvarint(reader.read())\n    operations_data = reader.read(operations_length)\n    operations = cls._unmarshal_operations(operations_data)\n    logger.debug(f\" Parsed UpdateAccountAuth: Operations={operations}\")\n    # The account_url is not encoded in the body, it is typically set in the header\n    return cls(account_url=None, operations=operations)  # account_url may be set elsewhere\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateKeyPage","title":"<code>UpdateKeyPage</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents an Update Key Page transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@dataclass\nclass UpdateKeyPage(TransactionBodyBase):\n    \"\"\"\n    Represents an Update Key Page transaction.\n    \"\"\"\n    url: URL\n    operations: List[Dict[str, Dict[str, bytes]]]  #  encodes `entry` inside `operation`\n\n    def type(self) -&gt; TransactionType:\n        return TransactionType.UPDATE_KEY_PAGE\n\n    def fields_to_encode(self):\n        \"\"\"\n        Define the fields to encode for the transaction.\n        \"\"\"\n        fields = [\n            # Field 1: Transaction type (updateKeyPage) \u2013 encoded as a varint\n            (1, encode_uvarint(self.type().value), lambda x: x),\n            # Field 2: Operations \u2013 marshaled as a length-prefixed list\n            (2, self._marshal_operations(), lambda x: x),\n        ]\n        return fields\n\n    def _marshal_operations(self) -&gt; bytes:\n        ops = [self._marshal_operation(op) for op in self.operations]\n        operations_data = b\"\".join(ops)\n        operations_length = encode_uvarint(len(operations_data))\n        return operations_length + operations_data\n\n    @staticmethod\n    def _marshal_operation(operation: Dict[str, Any]) -&gt; bytes:\n        \"\"\"\n        Serialize an operation dictionary into bytes.\n        Handles standard operations (with keyHash or delegate), threshold operations \n        (setThreshold, setRejectThreshold, setResponseThreshold) and update operations.\n        \"\"\"\n        op_type_lower = operation[\"type\"].lower()\n\n        if op_type_lower in [\"setthreshold\", \"setrejectthreshold\", \"setresponsethreshold\"]:\n            # For threshold operations, return only the inner payload\n            numeric_value = operation.get(\"threshold\")\n            if numeric_value is None:\n                raise ValueError(\"Missing threshold value for threshold operation.\")\n            # payload: Tag 0x01, fixed length 0x04, then Tag 0x02 followed by encode_uvarint(numeric_value)\n            # For example, for numeric_value = 2 (and if encode_uvarint(2) returns b'\\x02')\n            # this produces: b'\\x01' + b'\\x04' + b'\\x02' + b'\\x02' \u2192 hex: 01 04 02 02\n            return b'\\x01' + b'\\x04' + b'\\x02' + encode_uvarint(numeric_value)\n\n        elif op_type_lower == \"update\":\n            # Handle update operations normally.\n            op_type = b'\\x01' + encode_uvarint(KeyPageOperationType[\"UPDATE\"].value)\n            old_entry = operation.get(\"oldEntry\")\n            new_entry = operation.get(\"newEntry\")\n            if not old_entry or not new_entry or \"keyHash\" not in old_entry or \"keyHash\" not in new_entry:\n                raise ValueError(\"Invalid update operation: must contain both 'oldEntry' and 'newEntry' with a 'keyHash'.\")\n            old_data = b'\\x01' + encode_uvarint(32) + old_entry[\"keyHash\"]\n            new_data = b'\\x01' + encode_uvarint(32) + new_entry[\"keyHash\"]\n            old_field = b'\\x02' + encode_uvarint(len(old_data)) + old_data\n            new_field = b'\\x03' + encode_uvarint(len(new_data)) + new_data\n            return op_type + old_field + new_field\n\n        else:\n            # For standard operations.\n            op_type = b'\\x01' + encode_uvarint(KeyPageOperationType[operation[\"type\"].upper()].value)\n            entry = operation.get(\"entry\", {})\n            if \"keyHash\" in entry:\n                key_data = b'\\x01' + encode_uvarint(32) + entry[\"keyHash\"]\n            elif \"delegate\" in entry:\n                delegate_data = string_marshal_binary(entry[\"delegate\"])\n                key_data = b'\\x02' + delegate_data\n            else:\n                raise ValueError(\"Invalid operation entry: must contain either 'keyHash' or 'delegate'.\")\n            entry_field = b'\\x02' + encode_uvarint(len(key_data)) + key_data\n            return op_type + entry_field\n\n\n\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert transaction body to a JSON\u2011serializable dictionary.\"\"\"\n        op_list = []\n        for operation in self.operations:\n            op_type = operation[\"type\"].lower()\n            if op_type == \"update\":\n                op_list.append({\n                    \"type\": \"update\",\n                    \"oldEntry\": {\"keyHash\": operation[\"oldEntry\"][\"keyHash\"].hex()},\n                    \"newEntry\": {\"keyHash\": operation[\"newEntry\"][\"keyHash\"].hex()}\n                })\n            elif op_type in [\"setthreshold\", \"setrejectthreshold\", \"setresponsethreshold\"]:\n                # For threshold operations, check top-level threshold.\n                numeric_value = operation.get(\"threshold\")\n                if numeric_value is None:\n                    numeric_value = operation.get(\"entry\", {}).get(\"threshold\")\n                if numeric_value is None:\n                    raise ValueError(\"Missing threshold value in operation.\")\n                if op_type == \"setthreshold\":\n                    op_name = \"setThreshold\"\n                elif op_type == \"setrejectthreshold\":\n                    op_name = \"setRejectThreshold\"\n                elif op_type == \"setresponsethreshold\":\n                    op_name = \"setResponseThreshold\"\n                op_list.append({\n                    \"type\": op_name,\n                    \"threshold\": numeric_value\n                })\n            else:\n                op_list.append({\n                    \"type\": operation[\"type\"],\n                    \"entry\": (\n                        {\"keyHash\": operation[\"entry\"][\"keyHash\"].hex()}\n                        if \"keyHash\" in operation[\"entry\"]\n                        else {\"delegate\": operation[\"entry\"][\"delegate\"]}\n                    ),\n                })\n        return {\n            \"type\": self._format_transaction_type(self.type().name),\n            \"operation\": op_list,\n        }\n\n\n\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"UpdateKeyPage\":\n        \"\"\"Deserialize UpdateKeyPage transaction from bytes.\"\"\"\n        logger.debug(f\" Unmarshaling UpdateKeyPage: {data.hex()}\")\n\n        reader = io.BytesIO(data)\n\n        # Step 1: Read URL\n        url = URL.parse(unmarshal_bytes(reader).decode(\"utf-8\"))\n\n        # Step 2: Read Operations\n        operations_length, _ = read_uvarint(reader)  # Read length prefix\n        operations_data = reader.read(operations_length)  # Read operations\n        operations = cls._unmarshal_operations(operations_data)\n\n        logger.debug(f\" Parsed UpdateKeyPage: URL={url}, Operations={operations}\")\n        return cls(url, operations)\n\n\n    @staticmethod\n    def _unmarshal_operations(data: bytes) -&gt; List[Dict[str, Dict[str, bytes]]]:\n        \"\"\"Deserialize operations from a byte stream.\"\"\"\n        operations = []\n        reader = io.BytesIO(data)\n\n        while reader.tell() &lt; len(data):\n            # Extract operation type (as an int)\n            operation_type, _ = read_uvarint(reader)\n\n            # Extract entry\n            entry = {}\n            # Peek at the next byte to determine the entry type\n            entry_type_byte, _ = read_uvarint(reader)\n            if entry_type_byte == 1:  # KeyHash\n                key_hash = reader.read(32)\n                if len(key_hash) != 32:\n                    raise ValueError(\"Invalid keyHash length (must be 32 bytes).\")\n                entry[\"keyHash\"] = key_hash\n            elif entry_type_byte == 2:  # Delegate\n                delegate_url = unmarshal_bytes(reader).decode(\"utf-8\")\n                entry[\"delegate\"] = delegate_url\n            elif entry_type_byte == 3:  # Numeric value (e.g., threshold)\n                # Decode numeric value (assuming uvarint)\n                numeric_value, _ = read_uvarint(reader)\n                # You will need to decide which numeric key to use based on the operation type\n                # For simplicity, we'll set \"threshold\". In a complete implementation, check operation type\n                entry[\"threshold\"] = numeric_value\n            else:\n                raise ValueError(\"Unknown entry type in UpdateKeyPage.\")\n\n            # Wrap the operation in a dictionary; here we assume non-update operations\n            # For update operations, you\u2019d handle them separately\n            operations.append({\n                \"type\": KeyPageOperationType(operation_type).name.lower(),\n                \"entry\": entry\n            })\n\n        return operations\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateKeyPage._marshal_operation","title":"<code>_marshal_operation(operation)</code>  <code>staticmethod</code>","text":"<p>Serialize an operation dictionary into bytes. Handles standard operations (with keyHash or delegate), threshold operations  (setThreshold, setRejectThreshold, setResponseThreshold) and update operations.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef _marshal_operation(operation: Dict[str, Any]) -&gt; bytes:\n    \"\"\"\n    Serialize an operation dictionary into bytes.\n    Handles standard operations (with keyHash or delegate), threshold operations \n    (setThreshold, setRejectThreshold, setResponseThreshold) and update operations.\n    \"\"\"\n    op_type_lower = operation[\"type\"].lower()\n\n    if op_type_lower in [\"setthreshold\", \"setrejectthreshold\", \"setresponsethreshold\"]:\n        # For threshold operations, return only the inner payload\n        numeric_value = operation.get(\"threshold\")\n        if numeric_value is None:\n            raise ValueError(\"Missing threshold value for threshold operation.\")\n        # payload: Tag 0x01, fixed length 0x04, then Tag 0x02 followed by encode_uvarint(numeric_value)\n        # For example, for numeric_value = 2 (and if encode_uvarint(2) returns b'\\x02')\n        # this produces: b'\\x01' + b'\\x04' + b'\\x02' + b'\\x02' \u2192 hex: 01 04 02 02\n        return b'\\x01' + b'\\x04' + b'\\x02' + encode_uvarint(numeric_value)\n\n    elif op_type_lower == \"update\":\n        # Handle update operations normally.\n        op_type = b'\\x01' + encode_uvarint(KeyPageOperationType[\"UPDATE\"].value)\n        old_entry = operation.get(\"oldEntry\")\n        new_entry = operation.get(\"newEntry\")\n        if not old_entry or not new_entry or \"keyHash\" not in old_entry or \"keyHash\" not in new_entry:\n            raise ValueError(\"Invalid update operation: must contain both 'oldEntry' and 'newEntry' with a 'keyHash'.\")\n        old_data = b'\\x01' + encode_uvarint(32) + old_entry[\"keyHash\"]\n        new_data = b'\\x01' + encode_uvarint(32) + new_entry[\"keyHash\"]\n        old_field = b'\\x02' + encode_uvarint(len(old_data)) + old_data\n        new_field = b'\\x03' + encode_uvarint(len(new_data)) + new_data\n        return op_type + old_field + new_field\n\n    else:\n        # For standard operations.\n        op_type = b'\\x01' + encode_uvarint(KeyPageOperationType[operation[\"type\"].upper()].value)\n        entry = operation.get(\"entry\", {})\n        if \"keyHash\" in entry:\n            key_data = b'\\x01' + encode_uvarint(32) + entry[\"keyHash\"]\n        elif \"delegate\" in entry:\n            delegate_data = string_marshal_binary(entry[\"delegate\"])\n            key_data = b'\\x02' + delegate_data\n        else:\n            raise ValueError(\"Invalid operation entry: must contain either 'keyHash' or 'delegate'.\")\n        entry_field = b'\\x02' + encode_uvarint(len(key_data)) + key_data\n        return op_type + entry_field\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateKeyPage._unmarshal_operations","title":"<code>_unmarshal_operations(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize operations from a byte stream.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@staticmethod\ndef _unmarshal_operations(data: bytes) -&gt; List[Dict[str, Dict[str, bytes]]]:\n    \"\"\"Deserialize operations from a byte stream.\"\"\"\n    operations = []\n    reader = io.BytesIO(data)\n\n    while reader.tell() &lt; len(data):\n        # Extract operation type (as an int)\n        operation_type, _ = read_uvarint(reader)\n\n        # Extract entry\n        entry = {}\n        # Peek at the next byte to determine the entry type\n        entry_type_byte, _ = read_uvarint(reader)\n        if entry_type_byte == 1:  # KeyHash\n            key_hash = reader.read(32)\n            if len(key_hash) != 32:\n                raise ValueError(\"Invalid keyHash length (must be 32 bytes).\")\n            entry[\"keyHash\"] = key_hash\n        elif entry_type_byte == 2:  # Delegate\n            delegate_url = unmarshal_bytes(reader).decode(\"utf-8\")\n            entry[\"delegate\"] = delegate_url\n        elif entry_type_byte == 3:  # Numeric value (e.g., threshold)\n            # Decode numeric value (assuming uvarint)\n            numeric_value, _ = read_uvarint(reader)\n            # You will need to decide which numeric key to use based on the operation type\n            # For simplicity, we'll set \"threshold\". In a complete implementation, check operation type\n            entry[\"threshold\"] = numeric_value\n        else:\n            raise ValueError(\"Unknown entry type in UpdateKeyPage.\")\n\n        # Wrap the operation in a dictionary; here we assume non-update operations\n        # For update operations, you\u2019d handle them separately\n        operations.append({\n            \"type\": KeyPageOperationType(operation_type).name.lower(),\n            \"entry\": entry\n        })\n\n    return operations\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateKeyPage.fields_to_encode","title":"<code>fields_to_encode()</code>","text":"<p>Define the fields to encode for the transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def fields_to_encode(self):\n    \"\"\"\n    Define the fields to encode for the transaction.\n    \"\"\"\n    fields = [\n        # Field 1: Transaction type (updateKeyPage) \u2013 encoded as a varint\n        (1, encode_uvarint(self.type().value), lambda x: x),\n        # Field 2: Operations \u2013 marshaled as a length-prefixed list\n        (2, self._marshal_operations(), lambda x: x),\n    ]\n    return fields\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateKeyPage.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert transaction body to a JSON\u2011serializable dictionary.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert transaction body to a JSON\u2011serializable dictionary.\"\"\"\n    op_list = []\n    for operation in self.operations:\n        op_type = operation[\"type\"].lower()\n        if op_type == \"update\":\n            op_list.append({\n                \"type\": \"update\",\n                \"oldEntry\": {\"keyHash\": operation[\"oldEntry\"][\"keyHash\"].hex()},\n                \"newEntry\": {\"keyHash\": operation[\"newEntry\"][\"keyHash\"].hex()}\n            })\n        elif op_type in [\"setthreshold\", \"setrejectthreshold\", \"setresponsethreshold\"]:\n            # For threshold operations, check top-level threshold.\n            numeric_value = operation.get(\"threshold\")\n            if numeric_value is None:\n                numeric_value = operation.get(\"entry\", {}).get(\"threshold\")\n            if numeric_value is None:\n                raise ValueError(\"Missing threshold value in operation.\")\n            if op_type == \"setthreshold\":\n                op_name = \"setThreshold\"\n            elif op_type == \"setrejectthreshold\":\n                op_name = \"setRejectThreshold\"\n            elif op_type == \"setresponsethreshold\":\n                op_name = \"setResponseThreshold\"\n            op_list.append({\n                \"type\": op_name,\n                \"threshold\": numeric_value\n            })\n        else:\n            op_list.append({\n                \"type\": operation[\"type\"],\n                \"entry\": (\n                    {\"keyHash\": operation[\"entry\"][\"keyHash\"].hex()}\n                    if \"keyHash\" in operation[\"entry\"]\n                    else {\"delegate\": operation[\"entry\"][\"delegate\"]}\n                ),\n            })\n    return {\n        \"type\": self._format_transaction_type(self.type().name),\n        \"operation\": op_list,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.UpdateKeyPage.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize UpdateKeyPage transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"UpdateKeyPage\":\n    \"\"\"Deserialize UpdateKeyPage transaction from bytes.\"\"\"\n    logger.debug(f\" Unmarshaling UpdateKeyPage: {data.hex()}\")\n\n    reader = io.BytesIO(data)\n\n    # Step 1: Read URL\n    url = URL.parse(unmarshal_bytes(reader).decode(\"utf-8\"))\n\n    # Step 2: Read Operations\n    operations_length, _ = read_uvarint(reader)  # Read length prefix\n    operations_data = reader.read(operations_length)  # Read operations\n    operations = cls._unmarshal_operations(operations_data)\n\n    logger.debug(f\" Parsed UpdateKeyPage: URL={url}, Operations={operations}\")\n    return cls(url, operations)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData","title":"<code>WriteData</code>","text":"<p>               Bases: <code>TransactionBodyBase</code></p> <p>Represents a Write Data transaction.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>class WriteData(TransactionBodyBase):\n    \"\"\"\n    Represents a Write Data transaction.\n    \"\"\"\n\n    def __init__(self, entry: DataEntry, scratch: Optional[bool] = None, write_to_state: Optional[bool] = None):\n        \"\"\"\n        :param entry: The data entry (must be `AccumulateDataEntry` or `DoubleHashDataEntry`).\n        :param scratch: Flag indicating whether it's a scratch write.\n        :param write_to_state: Flag indicating whether it writes to state.\n        \"\"\"\n        if not isinstance(entry, (AccumulateDataEntry, DoubleHashDataEntry)):  #  Support multiple types\n            raise TypeError(\"entry must be an instance of AccumulateDataEntry or DoubleHashDataEntry.\")\n\n        self.entry = entry\n        self.scratch = scratch if scratch is not None else False\n        self.write_to_state = write_to_state if write_to_state is not None else False\n\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return transaction type.\"\"\"\n        return TransactionType.WRITE_DATA\n\n\n    def fields_to_encode(self):\n        #  Step 1: Marshal the entry as a length-prefixed structure\n        entry_marshal = self.entry.marshal()\n\n        #   Prefix the entry with total length (no extra `+ 1`)\n        entry_length = encode_uvarint(len(entry_marshal))  #  length prefix\n        entry_encoded = entry_length + entry_marshal  #  No extra nested field\n\n        fields = [\n            (1, encode_uvarint(self.type().value), lambda x: x),  #  Transaction Type\n            (2, entry_encoded, lambda x: x),  #  Marshal entire entry properly\n        ]\n\n        #  Only include scratch if True\n        if self.scratch:\n            fields.append((3, boolean_marshal_binary(self.scratch), lambda x: x))\n\n        #  Only include writeToState if False\n        if not self.write_to_state:\n            fields.append((4, boolean_marshal_binary(self.write_to_state), lambda x: x))\n\n        return fields\n\n\n    def marshal_without_entry(self) -&gt; bytes:\n        \"\"\"\n        Marshal WriteData without the `entry` field.\n        Needed to match Go SDK hashing logic.\n        \"\"\"\n        logger.debug(\" Marshaling WriteData WITHOUT Entry Field\")\n\n        serialized = b\"\"\n        fields = [\n            (1, encode_uvarint(self.type().value), lambda x: x),  #  Type field\n        ]\n\n        if self.scratch:\n            fields.append((3, boolean_marshal_binary(self.scratch), lambda x: x))\n\n        if not self.write_to_state:\n            fields.append((4, boolean_marshal_binary(self.write_to_state), lambda x: x))\n\n        #  Debugging: Log each field separately\n        for field_num, value, encode_func in fields:\n            encoded_value = encode_func(value)\n            logger.debug(f\" Encoding Field {field_num}: {encoded_value.hex() if isinstance(encoded_value, bytes) else encoded_value}\")\n            serialized += field_marshal_binary(field_num, encoded_value)\n\n        logger.debug(f\" FINAL Marshaled WriteData WITHOUT Entry (HEX): {serialized.hex()}\")\n\n        return serialized\n\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"WriteData\":\n        \"\"\"Deserialize WriteData transaction from bytes.\"\"\"\n        logger.debug(f\" Unmarshaling WriteData\")\n\n        reader = io.BytesIO(data)\n\n        #  Step 1: Read Type Field\n        type_value = read_uvarint(reader)\n\n        #  Step 2: Read and Unmarshal Data Entry\n        entry_data = unmarshal_bytes(reader)\n        entry = DataEntry.unmarshal(entry_data)  #  Use DataEntry unmarshal to detect type\n\n        #  Step 3: Read Boolean Flags\n        scratch_flag = bool(reader.read(1)[0])  # Read single byte for scratch flag\n        state_flag = bool(reader.read(1)[0])  # Read single byte for write_to_state flag\n\n        logger.debug(f\" Parsed WriteData: type={type_value}, scratch={scratch_flag}, write_to_state={state_flag}, entry={entry}\")\n        return cls(entry, scratch_flag, state_flag)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n         Convert WriteData transaction to a dictionary, ensuring that default values (scratch=False, writeToState=True) are omitted.\n        \"\"\"\n        data = {\n            **super().to_dict(),\n            \"entry\": self.entry.to_dict(),\n        }\n\n        #  Only include `scratch` if True\n        if self.scratch:\n            data[\"scratch\"] = self.scratch\n\n        #  Only include `writeToState` if False\n        if not self.write_to_state:\n            data[\"writeToState\"] = self.write_to_state\n\n        return data\n\n\n    def hash_tree(self) -&gt; bytes:\n        \"\"\"\n        Compute the Merkle tree hash of the data entry.\n        Go SDK uses `sha256(sha256(MerkleRoot(entry_data)))`\n        \"\"\"\n        logger.debug(\" Computing Merkle Tree Hash for Entry Data\")\n\n        #  Compute initial SHA-256 hashes of each chunk\n        data_hashes = [hashlib.sha256(chunk).digest() for chunk in self.entry.get_data()]\n\n        #  Compute the Merkle root\n        if len(data_hashes) == 1:\n            merkle_root = data_hashes[0]\n        else:\n            while len(data_hashes) &gt; 1:\n                temp_hashes = []\n                for i in range(0, len(data_hashes), 2):\n                    if i + 1 &lt; len(data_hashes):\n                        combined = data_hashes[i] + data_hashes[i + 1]\n                    else:\n                        combined = data_hashes[i]  # Handle odd number of elements\n                    temp_hashes.append(hashlib.sha256(combined).digest())\n                data_hashes = temp_hashes\n            merkle_root = data_hashes[0]\n\n        #  Double-hash the Merkle root for `DoubleHashDataEntry`\n        final_hash = hashlib.sha256(merkle_root).digest()\n        logger.debug(f\" Merkle Root SHA-256 Hash: {merkle_root.hex()}\")\n        logger.debug(f\" FINAL Double Hash (SHA-256): {final_hash.hex()}\")\n\n        return final_hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData.__init__","title":"<code>__init__(entry, scratch=None, write_to_state=None)</code>","text":"<p>:param entry: The data entry (must be <code>AccumulateDataEntry</code> or <code>DoubleHashDataEntry</code>). :param scratch: Flag indicating whether it's a scratch write. :param write_to_state: Flag indicating whether it writes to state.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def __init__(self, entry: DataEntry, scratch: Optional[bool] = None, write_to_state: Optional[bool] = None):\n    \"\"\"\n    :param entry: The data entry (must be `AccumulateDataEntry` or `DoubleHashDataEntry`).\n    :param scratch: Flag indicating whether it's a scratch write.\n    :param write_to_state: Flag indicating whether it writes to state.\n    \"\"\"\n    if not isinstance(entry, (AccumulateDataEntry, DoubleHashDataEntry)):  #  Support multiple types\n        raise TypeError(\"entry must be an instance of AccumulateDataEntry or DoubleHashDataEntry.\")\n\n    self.entry = entry\n    self.scratch = scratch if scratch is not None else False\n    self.write_to_state = write_to_state if write_to_state is not None else False\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData.hash_tree","title":"<code>hash_tree()</code>","text":"<p>Compute the Merkle tree hash of the data entry. Go SDK uses <code>sha256(sha256(MerkleRoot(entry_data)))</code></p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def hash_tree(self) -&gt; bytes:\n    \"\"\"\n    Compute the Merkle tree hash of the data entry.\n    Go SDK uses `sha256(sha256(MerkleRoot(entry_data)))`\n    \"\"\"\n    logger.debug(\" Computing Merkle Tree Hash for Entry Data\")\n\n    #  Compute initial SHA-256 hashes of each chunk\n    data_hashes = [hashlib.sha256(chunk).digest() for chunk in self.entry.get_data()]\n\n    #  Compute the Merkle root\n    if len(data_hashes) == 1:\n        merkle_root = data_hashes[0]\n    else:\n        while len(data_hashes) &gt; 1:\n            temp_hashes = []\n            for i in range(0, len(data_hashes), 2):\n                if i + 1 &lt; len(data_hashes):\n                    combined = data_hashes[i] + data_hashes[i + 1]\n                else:\n                    combined = data_hashes[i]  # Handle odd number of elements\n                temp_hashes.append(hashlib.sha256(combined).digest())\n            data_hashes = temp_hashes\n        merkle_root = data_hashes[0]\n\n    #  Double-hash the Merkle root for `DoubleHashDataEntry`\n    final_hash = hashlib.sha256(merkle_root).digest()\n    logger.debug(f\" Merkle Root SHA-256 Hash: {merkle_root.hex()}\")\n    logger.debug(f\" FINAL Double Hash (SHA-256): {final_hash.hex()}\")\n\n    return final_hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData.marshal_without_entry","title":"<code>marshal_without_entry()</code>","text":"<p>Marshal WriteData without the <code>entry</code> field. Needed to match Go SDK hashing logic.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def marshal_without_entry(self) -&gt; bytes:\n    \"\"\"\n    Marshal WriteData without the `entry` field.\n    Needed to match Go SDK hashing logic.\n    \"\"\"\n    logger.debug(\" Marshaling WriteData WITHOUT Entry Field\")\n\n    serialized = b\"\"\n    fields = [\n        (1, encode_uvarint(self.type().value), lambda x: x),  #  Type field\n    ]\n\n    if self.scratch:\n        fields.append((3, boolean_marshal_binary(self.scratch), lambda x: x))\n\n    if not self.write_to_state:\n        fields.append((4, boolean_marshal_binary(self.write_to_state), lambda x: x))\n\n    #  Debugging: Log each field separately\n    for field_num, value, encode_func in fields:\n        encoded_value = encode_func(value)\n        logger.debug(f\" Encoding Field {field_num}: {encoded_value.hex() if isinstance(encoded_value, bytes) else encoded_value}\")\n        serialized += field_marshal_binary(field_num, encoded_value)\n\n    logger.debug(f\" FINAL Marshaled WriteData WITHOUT Entry (HEX): {serialized.hex()}\")\n\n    return serialized\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert WriteData transaction to a dictionary, ensuring that default values (scratch=False, writeToState=True) are omitted.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n     Convert WriteData transaction to a dictionary, ensuring that default values (scratch=False, writeToState=True) are omitted.\n    \"\"\"\n    data = {\n        **super().to_dict(),\n        \"entry\": self.entry.to_dict(),\n    }\n\n    #  Only include `scratch` if True\n    if self.scratch:\n        data[\"scratch\"] = self.scratch\n\n    #  Only include `writeToState` if False\n    if not self.write_to_state:\n        data[\"writeToState\"] = self.write_to_state\n\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData.type","title":"<code>type()</code>","text":"<p>Return transaction type.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>def type(self) -&gt; TransactionType:\n    \"\"\"Return transaction type.\"\"\"\n    return TransactionType.WRITE_DATA\n</code></pre>"},{"location":"api_reference/#accumulate.models.transactions.WriteData.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize WriteData transaction from bytes.</p> Source code in <code>accumulate\\models\\transactions.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"WriteData\":\n    \"\"\"Deserialize WriteData transaction from bytes.\"\"\"\n    logger.debug(f\" Unmarshaling WriteData\")\n\n    reader = io.BytesIO(data)\n\n    #  Step 1: Read Type Field\n    type_value = read_uvarint(reader)\n\n    #  Step 2: Read and Unmarshal Data Entry\n    entry_data = unmarshal_bytes(reader)\n    entry = DataEntry.unmarshal(entry_data)  #  Use DataEntry unmarshal to detect type\n\n    #  Step 3: Read Boolean Flags\n    scratch_flag = bool(reader.read(1)[0])  # Read single byte for scratch flag\n    state_flag = bool(reader.read(1)[0])  # Read single byte for write_to_state flag\n\n    logger.debug(f\" Parsed WriteData: type={type_value}, scratch={scratch_flag}, write_to_state={state_flag}, entry={entry}\")\n    return cls(entry, scratch_flag, state_flag)\n</code></pre>"},{"location":"api_reference/#queries-models","title":"Queries (Models)","text":""},{"location":"api_reference/#accumulate.models.queries","title":"<code>queries</code>","text":""},{"location":"api_reference/#accumulate.models.queries.AccumulateError","title":"<code>AccumulateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all custom exceptions in the Accumulate client.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class AccumulateError(Exception):\n    \"\"\"Base class for all custom exceptions in the Accumulate client.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.AnchorSearchQuery","title":"<code>AnchorSearchQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents an anchor search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class AnchorSearchQuery(Query):\n    \"\"\"Represents an anchor search query.\"\"\"\n\n    def __init__(self, anchor: bytes, include_receipt: Optional[ReceiptOptions] = None):\n        super().__init__(QueryType.ANCHOR_SEARCH)\n        self.anchor = anchor\n        self.include_receipt = include_receipt\n\n    def is_valid(self):\n        \"\"\"Validate the anchor search query.\"\"\"\n        if not self.anchor:\n            raise AccumulateError(\"Anchor is required for an anchor search query.\") #\n        if self.include_receipt and not (\n            self.include_receipt.for_any or self.include_receipt.for_height is not None\n        ):\n            raise AccumulateError(\"Invalid ReceiptOptions: Must specify `for_any` or `for_height`.\") #\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n        data.update({\n            \"anchor\": self.anchor.hex() if self.anchor else None,\n            \"include_receipt\": self.include_receipt.to_dict() if self.include_receipt else None,\n        })\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.AnchorSearchQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the anchor search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the anchor search query.\"\"\"\n    if not self.anchor:\n        raise AccumulateError(\"Anchor is required for an anchor search query.\") #\n    if self.include_receipt and not (\n        self.include_receipt.for_any or self.include_receipt.for_height is not None\n    ):\n        raise AccumulateError(\"Invalid ReceiptOptions: Must specify `for_any` or `for_height`.\") #\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.BlockQuery","title":"<code>BlockQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a block query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class BlockQuery(Query):\n    \"\"\"Represents a block query.\"\"\"\n\n    def __init__(\n        self,\n        minor: Optional[int] = None,\n        major: Optional[int] = None,\n        minor_range: Optional[RangeOptions] = None,\n        major_range: Optional[RangeOptions] = None,\n        entry_range: Optional[RangeOptions] = None,\n        omit_empty: Optional[bool] = None,\n    ):\n        super().__init__(QueryType.BLOCK)\n        self.minor = minor\n        self.major = major\n        self.minor_range = minor_range\n        self.major_range = major_range\n        self.entry_range = entry_range\n        self.omit_empty = omit_empty\n\n    def is_valid(self):\n        \"\"\"Validate the block query. Ensure at least one required field is set.\"\"\"\n        if not (self.minor or self.major or self.minor_range or self.major_range):\n            raise AccumulateError(\n                \"BlockQuery must specify at least one of: minor, major, minor_range, or major_range.\"\n            )\n        if self.minor and self.minor_range:\n            raise AccumulateError(\"Cannot specify both minor and minor_range.\")\n        if self.major and self.major_range:\n            raise AccumulateError(\"Cannot specify both major and major_range.\")\n        if self.entry_range and (self.minor_range or self.major_range):\n            raise AccumulateError(\"EntryRange cannot be used with minor/major ranges.\")\n        if self.entry_range and not (self.entry_range.start or self.entry_range.count):\n            raise AccumulateError(\"EntryRange must specify `start` or `count`.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert BlockQuery to the API-compatible format.\"\"\"\n        data = super().to_dict()\n        query_params = {}\n\n        if self.minor is not None:\n            query_params[\"minor\"] = self.minor\n        if self.major is not None:\n            query_params[\"major\"] = self.major\n        if self.minor_range:\n            query_params[\"minor_range\"] = self.minor_range.to_dict()\n        if self.major_range:\n            query_params[\"major_range\"] = self.major_range.to_dict()\n        if self.entry_range:\n            query_params[\"entry_range\"] = self.entry_range.to_dict()\n        if self.omit_empty is not None:\n            query_params[\"omit_empty\"] = self.omit_empty  # True/False\n\n        data.update(query_params)\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.BlockQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the block query. Ensure at least one required field is set.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the block query. Ensure at least one required field is set.\"\"\"\n    if not (self.minor or self.major or self.minor_range or self.major_range):\n        raise AccumulateError(\n            \"BlockQuery must specify at least one of: minor, major, minor_range, or major_range.\"\n        )\n    if self.minor and self.minor_range:\n        raise AccumulateError(\"Cannot specify both minor and minor_range.\")\n    if self.major and self.major_range:\n        raise AccumulateError(\"Cannot specify both major and major_range.\")\n    if self.entry_range and (self.minor_range or self.major_range):\n        raise AccumulateError(\"EntryRange cannot be used with minor/major ranges.\")\n    if self.entry_range and not (self.entry_range.start or self.entry_range.count):\n        raise AccumulateError(\"EntryRange must specify `start` or `count`.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.BlockQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert BlockQuery to the API-compatible format.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert BlockQuery to the API-compatible format.\"\"\"\n    data = super().to_dict()\n    query_params = {}\n\n    if self.minor is not None:\n        query_params[\"minor\"] = self.minor\n    if self.major is not None:\n        query_params[\"major\"] = self.major\n    if self.minor_range:\n        query_params[\"minor_range\"] = self.minor_range.to_dict()\n    if self.major_range:\n        query_params[\"major_range\"] = self.major_range.to_dict()\n    if self.entry_range:\n        query_params[\"entry_range\"] = self.entry_range.to_dict()\n    if self.omit_empty is not None:\n        query_params[\"omit_empty\"] = self.omit_empty  # True/False\n\n    data.update(query_params)\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.ChainQuery","title":"<code>ChainQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a chain query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class ChainQuery(Query):\n    \"\"\"Represents a chain query.\"\"\"\n\n    def __init__(\n        self,\n        name: Optional[str] = None,\n        index: Optional[int] = None,\n        entry: Optional[bytes] = None,\n        range: Optional[RangeOptions] = None,\n        include_receipt: Optional[ReceiptOptions] = None,\n    ):\n        super().__init__(QueryType.CHAIN)\n        self.name = name\n        self.index = index\n        self.entry = entry\n        self.range = range\n        self.include_receipt = include_receipt\n\n    def is_valid(self):\n        \"\"\"Validate the chain query.\"\"\"\n        if self.range and (self.index or self.entry):\n            raise AccumulateError(\"Range is mutually exclusive with index and entry.\")\n        if not self.name and (self.index or self.entry or self.range):\n            raise AccumulateError(\"Name is required when querying by index, entry, or range.\")\n        if self.include_receipt and not self.include_receipt.is_valid():\n            raise AccumulateError(\"Invalid ReceiptOptions.\")\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Ensure `name` is always included in the query.\"\"\"\n        data = super().to_dict()\n        data.update({\n            \"name\": self.name if self.name else \"main\",\n            \"index\": self.index,\n            \"entry\": self.entry,\n            \"range\": self.range.to_dict() if self.range else None,\n            \"include_receipt\": self.include_receipt.to_dict() if self.include_receipt else None,\n        })\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.ChainQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the chain query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the chain query.\"\"\"\n    if self.range and (self.index or self.entry):\n        raise AccumulateError(\"Range is mutually exclusive with index and entry.\")\n    if not self.name and (self.index or self.entry or self.range):\n        raise AccumulateError(\"Name is required when querying by index, entry, or range.\")\n    if self.include_receipt and not self.include_receipt.is_valid():\n        raise AccumulateError(\"Invalid ReceiptOptions.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.ChainQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Ensure <code>name</code> is always included in the query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Ensure `name` is always included in the query.\"\"\"\n    data = super().to_dict()\n    data.update({\n        \"name\": self.name if self.name else \"main\",\n        \"index\": self.index,\n        \"entry\": self.entry,\n        \"range\": self.range.to_dict() if self.range else None,\n        \"include_receipt\": self.include_receipt.to_dict() if self.include_receipt else None,\n    })\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DataQuery","title":"<code>DataQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a data query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class DataQuery(Query):\n    \"\"\"Represents a data query.\"\"\"\n\n    def __init__(\n        self,\n        index: Optional[int] = None,\n        entry: Optional[bytes] = None,\n        range: Optional[RangeOptions] = None,\n    ):\n        super().__init__(QueryType.DATA)\n        self.index = index\n        self.entry = entry\n        self.range = range\n\n    def is_valid(self):\n        \"\"\"Validate the data query.\"\"\"\n        if self.range and (self.index or self.entry):\n            raise AccumulateError(\"Range is mutually exclusive with index and entry.\")\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n        data.update({\n            \"index\": self.index,\n            \"entry\": self.entry,\n            \"range\": self.range.to_dict() if self.range else None,\n        })\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DataQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the data query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the data query.\"\"\"\n    if self.range and (self.index or self.entry):\n        raise AccumulateError(\"Range is mutually exclusive with index and entry.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DefaultQuery","title":"<code>DefaultQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents the default query type.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class DefaultQuery(Query):\n    \"\"\"Represents the default query type.\"\"\"\n\n    def __init__(self, include_receipt: Optional[ReceiptOptions] = None):\n        super().__init__(QueryType.DEFAULT)\n        self.include_receipt = include_receipt\n\n    def is_valid(self):\n        \"\"\"Validate the default query.\"\"\"\n        if self.include_receipt and not (\n            self.include_receipt.for_any or self.include_receipt.for_height is not None\n        ):\n            raise AccumulateError(\"Invalid ReceiptOptions: Must specify `for_any` or `for_height`.\")\n\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n        data.update({\n            \"include_receipt\": self.include_receipt.to_dict() if self.include_receipt else None,\n        })\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DefaultQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the default query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the default query.\"\"\"\n    if self.include_receipt and not (\n        self.include_receipt.for_any or self.include_receipt.for_height is not None\n    ):\n        raise AccumulateError(\"Invalid ReceiptOptions: Must specify `for_any` or `for_height`.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DelegateSearchQuery","title":"<code>DelegateSearchQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a delegate search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class DelegateSearchQuery(Query):\n    \"\"\"Represents a delegate search query.\"\"\"\n\n    def __init__(self, delegate: str):\n        super().__init__(QueryType.DELEGATE_SEARCH)\n        self.delegate = delegate\n\n    def is_valid(self):\n        \"\"\"Validate the delegate search query.\"\"\"\n        if not self.delegate:\n            raise AccumulateError(\"Delegate is required for a delegate search query.\") #\n        # Additional validation for delegate (e.g., valid URL format) could be added.\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n        data.update({\n            \"delegate\": self.delegate,\n        })\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DelegateSearchQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the delegate search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the delegate search query.\"\"\"\n    if not self.delegate:\n        raise AccumulateError(\"Delegate is required for a delegate search query.\") #\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DirectoryQuery","title":"<code>DirectoryQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a directory query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class DirectoryQuery(Query):\n    \"\"\"Represents a directory query.\"\"\"\n\n    def __init__(self, range: Optional[RangeOptions] = None):\n        super().__init__(QueryType.DIRECTORY)\n        self.range = range\n\n    def is_valid(self):\n        \"\"\"Validate the directory query.\"\"\"\n        if self.range and not (\n            self.range.start is not None or self.range.count is not None\n        ):\n            raise AccumulateError(\"Invalid RangeOptions: Must include `start` or `count`.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Ensure the query outputs correctly formatted range parameters.\"\"\"\n        data = super().to_dict()\n\n        #  Always include `range` (Fix for API error)\n        data[\"range\"] = {\n            \"start\": self.range.start if self.range and self.range.start is not None else 0,\n            \"count\": self.range.count if self.range and self.range.count is not None else 10,\n            \"from_end\": self.range.from_end if self.range and self.range.from_end is not None else False,\n            \"expand\": self.range.expand if self.range and self.range.expand is not None else False,\n        }\n\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DirectoryQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the directory query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the directory query.\"\"\"\n    if self.range and not (\n        self.range.start is not None or self.range.count is not None\n    ):\n        raise AccumulateError(\"Invalid RangeOptions: Must include `start` or `count`.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.DirectoryQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Ensure the query outputs correctly formatted range parameters.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Ensure the query outputs correctly formatted range parameters.\"\"\"\n    data = super().to_dict()\n\n    #  Always include `range` (Fix for API error)\n    data[\"range\"] = {\n        \"start\": self.range.start if self.range and self.range.start is not None else 0,\n        \"count\": self.range.count if self.range and self.range.count is not None else 10,\n        \"from_end\": self.range.from_end if self.range and self.range.from_end is not None else False,\n        \"expand\": self.range.expand if self.range and self.range.expand is not None else False,\n    }\n\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.MessageHashSearchQuery","title":"<code>MessageHashSearchQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a message hash search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class MessageHashSearchQuery(Query):\n    \"\"\"Represents a message hash search query.\"\"\"\n\n    def __init__(self, hash: bytes):\n        super().__init__(QueryType.MESSAGE_HASH_SEARCH)\n        self.hash = hash\n\n    def is_valid(self):\n        \"\"\"Validate the message hash search query.\"\"\"\n        if not self.hash:\n            raise AccumulateError(\"Hash is required for a message hash search query.\") #\n\n    def to_dict(self) -&gt; dict:\n        data = super().to_dict()\n        data.update({\n            \"hash\": self.hash.hex() if self.hash else None,\n        })\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.MessageHashSearchQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the message hash search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the message hash search query.\"\"\"\n    if not self.hash:\n        raise AccumulateError(\"Hash is required for a message hash search query.\") #\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PendingQuery","title":"<code>PendingQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a pending query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class PendingQuery(Query):\n    \"\"\"Represents a pending query.\"\"\"\n\n    def __init__(self, range: Optional[RangeOptions] = None):\n        super().__init__(QueryType.PENDING)\n        self.range = range\n\n    def is_valid(self):\n        \"\"\"Validate the pending query.\"\"\"\n        if self.range and not (\n            self.range.start is not None or self.range.count is not None\n        ):\n            raise AccumulateError(\"Invalid RangeOptions: Must include `start` or `count`.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Ensure the query outputs correctly formatted range parameters.\"\"\"\n        data = super().to_dict()\n\n        #  Always include `range` (Fix for API error)\n        data[\"range\"] = {\n            \"start\": self.range.start if self.range and self.range.start is not None else 0,\n            \"count\": self.range.count if self.range and self.range.count is not None else 10,\n            \"from_end\": self.range.from_end if self.range and self.range.from_end is not None else False,\n            \"expand\": self.range.expand if self.range and self.range.expand is not None else False,\n        }\n\n        return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PendingQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the pending query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the pending query.\"\"\"\n    if self.range and not (\n        self.range.start is not None or self.range.count is not None\n    ):\n        raise AccumulateError(\"Invalid RangeOptions: Must include `start` or `count`.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PendingQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Ensure the query outputs correctly formatted range parameters.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Ensure the query outputs correctly formatted range parameters.\"\"\"\n    data = super().to_dict()\n\n    #  Always include `range` (Fix for API error)\n    data[\"range\"] = {\n        \"start\": self.range.start if self.range and self.range.start is not None else 0,\n        \"count\": self.range.count if self.range and self.range.count is not None else 10,\n        \"from_end\": self.range.from_end if self.range and self.range.from_end is not None else False,\n        \"expand\": self.range.expand if self.range and self.range.expand is not None else False,\n    }\n\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeyHashSearchQuery","title":"<code>PublicKeyHashSearchQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a public key hash search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class PublicKeyHashSearchQuery(Query):\n    \"\"\"Represents a public key hash search query.\"\"\"\n\n    def __init__(self, public_key_hash: str):\n        super().__init__(QueryType.PUBLIC_KEY_HASH_SEARCH)\n        self.public_key_hash = public_key_hash\n\n    def is_valid(self):\n        \"\"\"Validate the public key hash search query.\"\"\"\n        if not self.public_key_hash:\n            raise AccumulateError(\"Public key hash is required for a public key hash search query.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the query to a dictionary ensuring correct JSON-RPC format.\"\"\"\n        return {\n            \"queryType\": self.query_type.to_rpc_format(),  #  Ensure camelCase format\n            \"publicKeyHash\": self.public_key_hash,  #  Ensure hex format (string)\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeyHashSearchQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the public key hash search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the public key hash search query.\"\"\"\n    if not self.public_key_hash:\n        raise AccumulateError(\"Public key hash is required for a public key hash search query.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeyHashSearchQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the query to a dictionary ensuring correct JSON-RPC format.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the query to a dictionary ensuring correct JSON-RPC format.\"\"\"\n    return {\n        \"queryType\": self.query_type.to_rpc_format(),  #  Ensure camelCase format\n        \"publicKeyHash\": self.public_key_hash,  #  Ensure hex format (string)\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeySearchQuery","title":"<code>PublicKeySearchQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Represents a public key search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class PublicKeySearchQuery(Query):\n    \"\"\"Represents a public key search query.\"\"\"\n\n    def __init__(self, public_key: str, signature_type: Optional[Union[int, SignatureType]] = SignatureType.ED25519):\n        super().__init__(QueryType.PUBLIC_KEY_SEARCH)\n\n        logger.debug(f\" Received Public Key: {public_key}\")\n\n        #  Auto-detect and convert the public key to HEX format\n        self.public_key = self._convert_to_hex(public_key)\n\n        #  Ensure signature_type is stored as a SignatureType enum and converted to RPC format\n        if isinstance(signature_type, int):\n            self.signature_type = SignatureType.from_value(signature_type)\n        elif isinstance(signature_type, SignatureType):\n            self.signature_type = signature_type\n        else:\n            raise ValueError(f\"Invalid signature type: {signature_type}\")\n\n    def _convert_to_hex(self, public_key: str) -&gt; bytes:\n        \"\"\"Detect and convert the provided public key to HEX.\"\"\"\n        if public_key.startswith(\"MH\"):  \n            parsed = parse_mh_address(public_key)\n            if not isinstance(parsed.hash, bytes):\n                raise ValueError(f\" Invalid MH address: {public_key}\")\n            logger.debug(f\" Parsed MH public key: {parsed.hash.hex()}\")\n            return parsed.hash\n\n        elif public_key.startswith(\"0x\"):  \n            logger.debug(f\" Parsed hex address: {public_key[2:]}\")\n            return bytes.fromhex(public_key[2:])  #  Remove '0x' and convert hex\n\n        elif re.fullmatch(r\"[0-9a-fA-F]+\", public_key):  \n            logger.debug(f\" Parsed raw hex: {public_key}\")\n            return bytes.fromhex(public_key)  #  Convert raw hex\n\n        else:\n            try:\n                #  Convert Base58 public key to HEX\n                decoded_bytes = base58.b58decode(public_key)  \n                logger.debug(f\" Parsed Base58 public key (converted to HEX): {decoded_bytes.hex()}\")\n                return decoded_bytes  # Store as bytes\n            except Exception as e:\n                logger.error(f\" Invalid public key format: {public_key}, Error: {e}\")\n                raise ValueError(f\"Invalid public key format: {public_key}\")\n\n    def is_valid(self):\n        \"\"\"Validate the public key search query.\"\"\"\n        if not self.public_key:\n            logger.error(\" Public key is required for a public key search query.\")\n            raise AccumulateError(\"Public key is required for a public key search query.\")\n        if not isinstance(self.signature_type, SignatureType):\n            logger.error(\" Signature type must be a valid SignatureType enum.\")\n            raise AccumulateError(\"Signature type must be a valid SignatureType enum.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Ensure the query outputs HEX for `publicKey` and correctly formatted `Type` field.\"\"\"\n        public_key_hex = self.public_key.hex()  #  Convert bytes to HEX\n        signature_type_rpc = self.signature_type.to_rpc_format()  #  Convert signature type to expected RPC format\n\n        logger.debug(f\" FINAL HEX public key before sending: {public_key_hex}\")  \n        logger.debug(f\" FINAL SignatureType before sending: {signature_type_rpc}\")  \n\n        return {\n            \"queryType\": \"publicKeySearch\",  #  Explicit string\n            \"publicKey\": public_key_hex,  #  Send HEX, NOT Base58\n            \"Type\": signature_type_rpc,  #  Send SignatureType as a string\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeySearchQuery._convert_to_hex","title":"<code>_convert_to_hex(public_key)</code>","text":"<p>Detect and convert the provided public key to HEX.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def _convert_to_hex(self, public_key: str) -&gt; bytes:\n    \"\"\"Detect and convert the provided public key to HEX.\"\"\"\n    if public_key.startswith(\"MH\"):  \n        parsed = parse_mh_address(public_key)\n        if not isinstance(parsed.hash, bytes):\n            raise ValueError(f\" Invalid MH address: {public_key}\")\n        logger.debug(f\" Parsed MH public key: {parsed.hash.hex()}\")\n        return parsed.hash\n\n    elif public_key.startswith(\"0x\"):  \n        logger.debug(f\" Parsed hex address: {public_key[2:]}\")\n        return bytes.fromhex(public_key[2:])  #  Remove '0x' and convert hex\n\n    elif re.fullmatch(r\"[0-9a-fA-F]+\", public_key):  \n        logger.debug(f\" Parsed raw hex: {public_key}\")\n        return bytes.fromhex(public_key)  #  Convert raw hex\n\n    else:\n        try:\n            #  Convert Base58 public key to HEX\n            decoded_bytes = base58.b58decode(public_key)  \n            logger.debug(f\" Parsed Base58 public key (converted to HEX): {decoded_bytes.hex()}\")\n            return decoded_bytes  # Store as bytes\n        except Exception as e:\n            logger.error(f\" Invalid public key format: {public_key}, Error: {e}\")\n            raise ValueError(f\"Invalid public key format: {public_key}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeySearchQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the public key search query.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the public key search query.\"\"\"\n    if not self.public_key:\n        logger.error(\" Public key is required for a public key search query.\")\n        raise AccumulateError(\"Public key is required for a public key search query.\")\n    if not isinstance(self.signature_type, SignatureType):\n        logger.error(\" Signature type must be a valid SignatureType enum.\")\n        raise AccumulateError(\"Signature type must be a valid SignatureType enum.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.PublicKeySearchQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Ensure the query outputs HEX for <code>publicKey</code> and correctly formatted <code>Type</code> field.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Ensure the query outputs HEX for `publicKey` and correctly formatted `Type` field.\"\"\"\n    public_key_hex = self.public_key.hex()  #  Convert bytes to HEX\n    signature_type_rpc = self.signature_type.to_rpc_format()  #  Convert signature type to expected RPC format\n\n    logger.debug(f\" FINAL HEX public key before sending: {public_key_hex}\")  \n    logger.debug(f\" FINAL SignatureType before sending: {signature_type_rpc}\")  \n\n    return {\n        \"queryType\": \"publicKeySearch\",  #  Explicit string\n        \"publicKey\": public_key_hex,  #  Send HEX, NOT Base58\n        \"Type\": signature_type_rpc,  #  Send SignatureType as a string\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.Query","title":"<code>Query</code>","text":"<p>Base class for all query types.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>class Query:\n    \"\"\"Base class for all query types.\"\"\"\n\n    def __init__(self, query_type: QueryType, params: Optional[dict] = None):\n        self.query_type = query_type\n        self.params = params or {}\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Validate the query parameters.\"\"\"\n        return bool(self.query_type)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the query to a dictionary ensuring queryType is formatted correctly.\"\"\"\n        query_dict = {\n            \"queryType\": self.query_type.to_rpc_format(),  # Convert to lowercase string\n        }\n        query_dict.update(self.params)  # Merge additional parameters\n        return query_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.Query.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the query parameters.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Validate the query parameters.\"\"\"\n    return bool(self.query_type)\n</code></pre>"},{"location":"api_reference/#accumulate.models.queries.Query.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the query to a dictionary ensuring queryType is formatted correctly.</p> Source code in <code>accumulate\\models\\queries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the query to a dictionary ensuring queryType is formatted correctly.\"\"\"\n    query_dict = {\n        \"queryType\": self.query_type.to_rpc_format(),  # Convert to lowercase string\n    }\n    query_dict.update(self.params)  # Merge additional parameters\n    return query_dict\n</code></pre>"},{"location":"api_reference/#models-schemas","title":"Models &amp; Schemas","text":""},{"location":"api_reference/#accumulate.models.records","title":"<code>records</code>","text":""},{"location":"api_reference/#accumulate.models.records.AccountRecord","title":"<code>AccountRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents an account record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass AccountRecord(Record):\n    \"\"\"Represents an account record.\"\"\"\n    account: Dict[str, Any] = field(default_factory=dict)\n    directory: Optional[RecordRange[UrlRecord]] = field(default=None)\n    pending: Optional[RecordRange[TxIDRecord]] = field(default=None)\n    receipt: Optional[Dict[str, Any]] = field(default_factory=dict)\n    last_block_time: Optional[datetime] = field(default=None)\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"account\": self.account,\n            \"directory\": self.directory.to_dict() if self.directory else None,\n            \"pending\": self.pending.to_dict() if self.pending else None,\n            \"receipt\": self.receipt,\n            \"last_block_time\": self.last_block_time.isoformat() if self.last_block_time else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"AccountRecord\":\n        return cls(\n            account=data[\"account\"],\n            directory=RecordRange.from_dict(data[\"directory\"], UrlRecord) if data.get(\"directory\") else None,\n            pending=RecordRange.from_dict(data[\"records\"], TxIDRecord) if data.get(\"records\") else None,\n            receipt=data.get(\"receipt\", {}),\n            last_block_time=datetime.fromisoformat(data[\"last_block_time\"]) if data.get(\"last_block_time\") else None,\n        )\n\n    @property\n    def balance(self) -&gt; float:\n        \"\"\"Convert raw balance (stored in micro-ACME) to actual ACME tokens.\"\"\"\n        raw_balance = int(self.account.get(\"balance\", 0))  # Get the raw integer balance\n        return raw_balance / 1e8  # Convert micro-ACME (1 ACME = 100,000,000 units)\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.AccountRecord.balance","title":"<code>balance</code>  <code>property</code>","text":"<p>Convert raw balance (stored in micro-ACME) to actual ACME tokens.</p>"},{"location":"api_reference/#accumulate.models.records.AccumulateError","title":"<code>AccumulateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all custom exceptions in the Accumulate client.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>class AccumulateError(Exception):\n    \"\"\"Base class for all custom exceptions in the Accumulate client.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.ChainEntryRecord","title":"<code>ChainEntryRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a chain entry record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass ChainEntryRecord(Record):\n    \"\"\"Represents a chain entry record.\"\"\"\n    name: Optional[str] = None\n    type: Optional[str] = None\n    count: Optional[int] = None\n    state: List[bytes] = field(default_factory=list)\n    account: Optional[str] = None\n    index: Optional[int] = None\n    entry: Optional[str] = None\n    receipt: Optional[Dict[str, Any]] = field(default_factory=dict)\n    last_block_time: Optional[datetime] = None\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"name\": self.name,\n            \"type\": self.type,\n            \"count\": self.count,\n            \"state\": self.state,\n            \"account\": self.account,\n            \"index\": self.index,\n            \"entry\": self.entry,\n            \"receipt\": self.receipt,\n            \"last_block_time\": self.last_block_time.isoformat() if self.last_block_time else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"ChainEntryRecord\":\n        return cls(\n            name=data.get(\"name\"),\n            type=data.get(\"type\"),\n            count=data.get(\"count\"),\n            state=data.get(\"state\", []),\n            account=data.get(\"account\"),\n            index=data.get(\"index\"),\n            entry=data.get(\"entry\"),\n            receipt=data.get(\"receipt\", {}),\n            last_block_time=datetime.fromisoformat(data[\"last_block_time\"]) if data.get(\"last_block_time\") else None,\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.ChainRecord","title":"<code>ChainRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a chain record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass ChainRecord(Record):\n    \"\"\"Represents a chain record.\"\"\"\n    name: Optional[str] = None  # Optional to resolve field ordering\n    type: Optional[str] = None  # Optional to resolve field ordering\n    count: Optional[int] = None  # Optional to resolve field ordering\n    state: List[bytes] = field(default_factory=list)  # Optional with a default factory\n    last_block_time: Optional[datetime] = None  # Optional field\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Converts the ChainRecord to a dictionary.\"\"\"\n        return {\n            \"name\": self.name,\n            \"type\": self.type,\n            \"count\": self.count,\n            \"state\": self.state,\n            \"last_block_time\": self.last_block_time.isoformat() if self.last_block_time else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"ChainRecord\":\n        \"\"\"Creates a ChainRecord instance from a dictionary.\"\"\"\n        return cls(\n            name=data.get(\"name\"),\n            type=data.get(\"type\"),\n            count=data.get(\"count\"),\n            state=data.get(\"state\", []),  # Defaults to an empty list if not provided\n            last_block_time=datetime.fromisoformat(data[\"last_block_time\"]) if data.get(\"last_block_time\") else None,\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.ChainRecord.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Creates a ChainRecord instance from a dictionary.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"ChainRecord\":\n    \"\"\"Creates a ChainRecord instance from a dictionary.\"\"\"\n    return cls(\n        name=data.get(\"name\"),\n        type=data.get(\"type\"),\n        count=data.get(\"count\"),\n        state=data.get(\"state\", []),  # Defaults to an empty list if not provided\n        last_block_time=datetime.fromisoformat(data[\"last_block_time\"]) if data.get(\"last_block_time\") else None,\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.ChainRecord.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the ChainRecord to a dictionary.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Converts the ChainRecord to a dictionary.\"\"\"\n    return {\n        \"name\": self.name,\n        \"type\": self.type,\n        \"count\": self.count,\n        \"state\": self.state,\n        \"last_block_time\": self.last_block_time.isoformat() if self.last_block_time else None,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.KeyRecord","title":"<code>KeyRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a key record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass KeyRecord(Record):\n    \"\"\"Represents a key record.\"\"\"\n    authority: Optional[str] = None\n    signer: Optional[str] = None\n    version: Optional[int] = None\n    index: Optional[int] = None\n    entry: Optional[Dict[str, Any]] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"authority\": self.authority,\n            \"signer\": self.signer,\n            \"version\": self.version,\n            \"index\": self.index,\n            \"entry\": self.entry,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"KeyRecord\":\n        return cls(\n            authority=data.get(\"authority\"),\n            signer=data.get(\"signer\"),\n            version=data.get(\"version\"),\n            index=data.get(\"index\"),\n            entry=data.get(\"entry\"),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.MessageRecord","title":"<code>MessageRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a message record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass MessageRecord(Record):\n    \"\"\"Represents a message record.\"\"\"\n    id: Optional[str] = None\n    message: Optional[dict] = field(default_factory=dict)\n    status: Optional[str] = None\n    result: Optional[dict] = field(default_factory=dict)\n    received: Optional[int] = None\n    produced: Optional[RecordRange[TxIDRecord]] = field(default=None)\n    cause: Optional[RecordRange[TxIDRecord]] = field(default=None)\n    signatures: Optional[RecordRange[\"SignatureSetRecord\"]] = field(default=None)\n    historical: Optional[bool] = None\n    last_block_time: Optional[datetime] = None\n\n    def to_dict(self) -&gt; dict:\n        result = {\n            \"id\": self.id,\n            \"message\": self.message or {},\n            \"status\": self.status,\n            \"result\": self.result or {},\n            \"received\": self.received,\n            \"produced\": self.produced.to_dict() if self.produced else None,\n            \"cause\": self.cause.to_dict() if self.cause else None,\n            \"signatures\": self.signatures.to_dict() if self.signatures else None,\n            \"historical\": self.historical,\n            \"last_block_time\": self.last_block_time.isoformat() if self.last_block_time else None,\n        }\n        # Remove fields with None values\n        return {key: value for key, value in result.items() if value is not None}\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"MessageRecord\":\n        return cls(\n            id=data.get(\"id\"),\n            message=data.get(\"message\", {}),\n            status=data.get(\"status\"),\n            result=data.get(\"result\", {}),\n            received=data.get(\"received\"),\n            produced=RecordRange.from_dict(data[\"produced\"], TxIDRecord) if \"produced\" in data else None,\n            cause=RecordRange.from_dict(data[\"cause\"], TxIDRecord) if \"cause\" in data else None,\n            signatures=RecordRange.from_dict(data[\"signatures\"], SignatureSetRecord) if \"signatures\" in data else None,\n            historical=data.get(\"historical\"),\n            last_block_time=datetime.fromisoformat(data[\"last_block_time\"]) if data.get(\"last_block_time\") else None,\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.Record","title":"<code>Record</code>  <code>dataclass</code>","text":"<p>Base class for records in the Accumulate blockchain.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass Record:\n    \"\"\"Base class for records in the Accumulate blockchain.\"\"\"\n    record_type: str = \"UNKNOWN\"\n    data: Dict[str, Any] = field(default_factory=dict)\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        return {\n            \"record_type\": self.record_type,\n            \"data\": self.data,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; \"Record\":\n        # Lazy import to resolve circular dependency\n        RecordType = __import__(\"accumulate.models.enums\").models.enums.RecordType\n        return cls(\n            record_type=data.get(\"record_type\", \"UNKNOWN\"),\n            data=data.get(\"data\", {}),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.RecordRange","title":"<code>RecordRange</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Represents a range of records.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass RecordRange(Generic[T]):\n    \"\"\"Represents a range of records.\"\"\"\n    records: List[T] = field(default_factory=list)\n    start: Optional[int] = None\n    total: Optional[int] = None\n    last_block_time: Optional[datetime] = None\n    item_type: Type[T] = Record  # Add this field to define the type explicitly\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"records\": [record.to_dict() for record in self.records],\n            \"start\": self.start,\n            \"total\": self.total,\n            \"last_block_time\": self.last_block_time.isoformat() if self.last_block_time else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: Optional[dict], record_cls: Type[T]) -&gt; \"RecordRange[T]\":\n        if data is None:  # Handle None gracefully\n            return cls(records=[], start=None, total=None, last_block_time=None, item_type=record_cls)\n        return cls(\n            records=[record_cls.from_dict(record) for record in data.get(\"records\", [])],\n            start=data.get(\"start\"),\n            total=data.get(\"total\"),\n            last_block_time=datetime.fromisoformat(data[\"last_block_time\"]) if data.get(\"last_block_time\") else None,\n            item_type=record_cls\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.SignatureSetRecord","title":"<code>SignatureSetRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a signature set record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass SignatureSetRecord(Record):\n    \"\"\"Represents a signature set record.\"\"\"\n    account: Optional[dict] = field(default_factory=dict)\n    signatures: Optional[RecordRange[MessageRecord]] = field(default=None)\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"account\": self.account,\n            \"signatures\": self.signatures.to_dict() if self.signatures else None,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"SignatureSetRecord\":\n        return cls(\n            account=data.get(\"account\", {}),\n            signatures=RecordRange.from_dict(data[\"signatures\"], MessageRecord) if \"signatures\" in data else None,\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.TxIDRecord","title":"<code>TxIDRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a TxID record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass TxIDRecord(Record):\n    \"\"\"Represents a TxID record.\"\"\"\n    value: Optional[str] = None\n\n    def to_dict(self) -&gt; dict:\n        return {\"value\": self.value}\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"TxIDRecord\":\n        return cls(value=data.get(\"value\"))\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.UrlRecord","title":"<code>UrlRecord</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a URL record.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>@dataclass\nclass UrlRecord(Record):\n    \"\"\"Represents a URL record.\"\"\"\n    value: Optional[str] = None\n\n    def to_dict(self) -&gt; dict:\n        return {\"value\": self.value}\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"UrlRecord\":\n        return cls(value=data.get(\"value\"))\n</code></pre>"},{"location":"api_reference/#accumulate.models.records.range_of","title":"<code>range_of(record_range, item_type)</code>","text":"<p>Validate and cast a RecordRange to a specific item type.</p> Source code in <code>accumulate\\models\\records.py</code> <pre><code>def range_of(record_range: \"RecordRange\", item_type: Type[T]) -&gt; \"RecordRange[T]\":\n    \"\"\"Validate and cast a RecordRange to a specific item type.\"\"\"\n    if not all(isinstance(record, item_type) for record in record_range.records):\n        raise AccumulateError(\n            f\"RecordRange contains items of an incorrect type. Expected {item_type}, \"\n            f\"but got {[type(record) for record in record_range.records]}\"\n        )\n    return record_range\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts","title":"<code>accounts</code>","text":""},{"location":"api_reference/#accumulate.models.accounts.Account","title":"<code>Account</code>","text":"<p>               Bases: <code>UnionValue</code></p> <p>Base class for all account types.</p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>class Account(UnionValue):\n    \"\"\"Base class for all account types.\"\"\"\n\n    def type(self) -&gt; str:\n        raise NotImplementedError(\"Account type not implemented\")\n\n    def get_url(self) -&gt; Any:\n        raise NotImplementedError(\"get_url() not implemented\")\n\n    def strip_url(self) -&gt; None:\n        raise NotImplementedError(\"strip_url() not implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.FullAccount","title":"<code>FullAccount</code>","text":"<p>               Bases: <code>Account</code></p> <p>Base class for accounts with authentication.</p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>class FullAccount(Account):\n    \"\"\"Base class for accounts with authentication.\"\"\"\n\n    def __init__(self, account_auth: Optional['AccountAuth'] = None):\n        self.account_auth = account_auth or AccountAuth()\n\n    def get_auth(self) -&gt; 'AccountAuth':\n        return self.account_auth\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.KeyBook","title":"<code>KeyBook</code>","text":"<p>               Bases: <code>FullAccount</code></p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>class KeyBook(FullAccount):\n    def __init__(self, url: Any, account_auth: Optional['AccountAuth'] = None, page_count: int = 0, book_type: str = ''):\n        print(f\"DEBUG: Initializing KeyBook with URL: {url}, page_count: {page_count}, book_type: {book_type}\")\n        super().__init__(account_auth)\n        self.url = self._ensure_url(url)\n\n        # Enforce additional validation specific to KeyBook\n        print(f\"DEBUG: Ensured URL in KeyBook: {self.url}\")\n        self._validate_key_book_url()\n\n        self.page_count = page_count\n        self.book_type = book_type\n        print(f\"DEBUG: KeyBook initialized successfully with URL: {self.url}\")\n\n    def _ensure_url(self, url: Any) -&gt; Any:\n        from accumulate.utils.url import URL\n        if isinstance(url, str):\n            print(f\"DEBUG: Parsing URL from string in _ensure_url: {url}\") #\n            return URL.parse(url.strip()) #\n\n        if isinstance(url, URL):\n            # Normalize existing URL objects\n            if \"@\" in url.authority or url.authority.endswith(\"@\"):\n                raise ValueError(f\"Invalid URL: '@' not allowed in authority: {url.authority}\")\n            if url.authority.startswith(\"acc://\"):\n                raise ValueError(f\"Invalid URL: Redundant 'acc://' in authority: {url.authority}\")\n\n        return url\n\n    def _validate_key_book_url(self):\n        \"\"\"Validation specific to KeyBook URLs.\"\"\"\n        # Ensure the URL path is not empty or just \"/\"\n        if not self.url.path or self.url.path == \"/\":\n            print(f\"ERROR: Invalid KeyBook URL - Missing book name in path: {self.url}\")\n            raise ValueError(f\"Invalid KeyBook URL: {self.url} must include a book name in the path.\")\n\n        # Ensure the path does not contain invalid characters\n        if \"@\" in self.url.path or \" \" in self.url.path:\n            print(f\"ERROR: Invalid KeyBook URL - Invalid characters in path: {self.url}\")\n            raise ValueError(f\"Invalid KeyBook URL: {self.url} contains invalid characters in the path.\")\n\n        # Ensure authority is not empty or invalid\n        if not self.url.authority or not self.url.authority.strip():\n            print(f\"ERROR: Invalid KeyBook URL - Missing or empty authority: {self.url}\")\n            raise ValueError(f\"Invalid KeyBook URL: Authority must not be empty in {self.url}\")\n\n        # Check for invalid domain names\n        if self.url.authority.startswith(\".\") or self.url.authority.endswith(\".com\"):\n            print(f\"ERROR: Invalid KeyBook URL - Invalid domain in authority: {self.url}\")\n            raise ValueError(f\"Invalid KeyBook URL: {self.url} contains invalid domain in authority.\")\n\n    def get_url(self) -&gt; Any:\n        print(f\"DEBUG: Retrieving URL in KeyBook: {self.url}\")\n        return self.url\n\n    def strip_url(self) -&gt; None:\n        print(f\"DEBUG: Stripping extras from URL in KeyBook: {self.url}\")\n        self.url = self.url.strip_extras()\n        print(f\"DEBUG: URL after stripping: {self.url}\")\n\n    def get_signers(self) -&gt; List[Any]:\n        print(f\"DEBUG: Generating signers for KeyBook with page_count: {self.page_count}\")\n        signers = [self._format_key_page_url(self.url, i) for i in range(self.page_count)]\n        print(f\"DEBUG: Generated signers in KeyBook: {[str(signer) for signer in signers]}\")\n        return signers\n\n    def _format_key_page_url(self, book_url: URL, index: int) -&gt; URL:\n        if not book_url.authority or not book_url.path:\n            raise ValueError(f\"Invalid KeyBook URL: {book_url}\")\n\n        normalized_path = f\"{book_url.path.rstrip('/')}/{index}\"\n        return URL(authority=book_url.authority, path=normalized_path)\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.KeyBook._validate_key_book_url","title":"<code>_validate_key_book_url()</code>","text":"<p>Validation specific to KeyBook URLs.</p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>def _validate_key_book_url(self):\n    \"\"\"Validation specific to KeyBook URLs.\"\"\"\n    # Ensure the URL path is not empty or just \"/\"\n    if not self.url.path or self.url.path == \"/\":\n        print(f\"ERROR: Invalid KeyBook URL - Missing book name in path: {self.url}\")\n        raise ValueError(f\"Invalid KeyBook URL: {self.url} must include a book name in the path.\")\n\n    # Ensure the path does not contain invalid characters\n    if \"@\" in self.url.path or \" \" in self.url.path:\n        print(f\"ERROR: Invalid KeyBook URL - Invalid characters in path: {self.url}\")\n        raise ValueError(f\"Invalid KeyBook URL: {self.url} contains invalid characters in the path.\")\n\n    # Ensure authority is not empty or invalid\n    if not self.url.authority or not self.url.authority.strip():\n        print(f\"ERROR: Invalid KeyBook URL - Missing or empty authority: {self.url}\")\n        raise ValueError(f\"Invalid KeyBook URL: Authority must not be empty in {self.url}\")\n\n    # Check for invalid domain names\n    if self.url.authority.startswith(\".\") or self.url.authority.endswith(\".com\"):\n        print(f\"ERROR: Invalid KeyBook URL - Invalid domain in authority: {self.url}\")\n        raise ValueError(f\"Invalid KeyBook URL: {self.url} contains invalid domain in authority.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.LiteIdentity","title":"<code>LiteIdentity</code>","text":"<p>               Bases: <code>Account</code></p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>class LiteIdentity(Account):\n    def __init__(self, url: Any, credit_balance: int = 0, last_used_on: Optional[int] = None):\n        if url is None:\n            raise ValueError(\"URL cannot be None.\")\n        if credit_balance &lt; 0:\n            raise ValueError(\"Credit balance cannot be negative.\")\n        self.url = self._ensure_url(url)\n        self.credit_balance = credit_balance\n        self.last_used_on = last_used_on\n\n    def _ensure_url(self, url: Any) -&gt; Any:\n        if isinstance(url, str):\n            from accumulate.utils.url import URL\n            return URL.parse(url)\n        return url\n\n    def get_url(self) -&gt; Any:\n        return self.url\n\n    def strip_url(self) -&gt; None:\n        self.url = self.url.strip_extras()\n\n    def get_credit_balance(self) -&gt; int:\n        return self.credit_balance\n\n    def get_signature_threshold(self) -&gt; int:\n        return 1\n\n    def entry_by_key(self, key: bytes) -&gt; Tuple[int, Optional['LiteIdentity'], bool]:\n        key_hash = sha256(key).digest()\n        lite_key = self._parse_lite_identity(self.url)\n\n        print(f\"[DEBUG] Calculated key_hash[:20]: {key_hash[:20].hex()}\")\n        print(f\"[DEBUG] Derived lite_key: {lite_key.hex()}\")\n\n        if lite_key == key_hash[:20]:\n            print(f\"[DEBUG] Key match successful.\")\n            return 0, self, True\n\n        print(f\"[DEBUG] Key match failed.\")\n        return -1, None, False\n\n\n    @staticmethod\n    def _parse_lite_identity(url: Any) -&gt; bytes:\n        return sha256(url.authority.encode()).digest()[:20]\n\n    def __repr__(self):\n        \"\"\"Custom representation for LiteIdentity.\"\"\"\n        return (\n            f\"&lt;LiteIdentity url={self.url}, \"\n            f\"credit_balance={self.credit_balance}, \"\n            f\"last_used_on={self.last_used_on}&gt;\"\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.LiteIdentity.__repr__","title":"<code>__repr__()</code>","text":"<p>Custom representation for LiteIdentity.</p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>def __repr__(self):\n    \"\"\"Custom representation for LiteIdentity.\"\"\"\n    return (\n        f\"&lt;LiteIdentity url={self.url}, \"\n        f\"credit_balance={self.credit_balance}, \"\n        f\"last_used_on={self.last_used_on}&gt;\"\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.LiteTokenAccount","title":"<code>LiteTokenAccount</code>","text":"<p>               Bases: <code>Account</code></p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>class LiteTokenAccount(Account):\n    def __init__(self, url: Any, token_url: Any, balance: Decimal = Decimal(\"0.00\")):\n        if url is None or token_url is None:\n            raise ValueError(\"URL and Token URL cannot be None.\")\n        if balance &lt; 0:\n            raise ValueError(\"Balance cannot be negative.\")\n\n        self.url = self._ensure_url(url)\n        self.token_url = self._ensure_url(token_url)\n        if not self.token_url.path:\n            raise ValueError(f\"Invalid lite token account URL: {self.token_url}\")\n\n        self.balance = balance\n\n    def _ensure_url(self, url: Any) -&gt; Any:\n        \"\"\"Ensure the URL is valid or parse it.\"\"\"\n        if isinstance(url, str):\n            from accumulate.utils.url import URL\n            return URL.parse(url)\n        return url\n\n    def get_url(self) -&gt; Any:\n        return self.url\n\n    def strip_url(self) -&gt; None:\n        self.url = self.url.strip_extras()\n\n    def token_balance(self) -&gt; Decimal:\n        return self.balance\n\n    def credit_tokens(self, amount: Decimal) -&gt; bool:\n        if amount &lt;= 0:\n            return False\n        self.balance += amount\n        return True\n\n    def can_debit_tokens(self, amount: Decimal) -&gt; bool:\n        return amount &gt; 0 and self.balance &gt;= amount\n\n    def debit_tokens(self, amount: Decimal) -&gt; bool:\n        if not self.can_debit_tokens(amount):\n            return False\n        self.balance -= amount\n        return True\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.LiteTokenAccount._ensure_url","title":"<code>_ensure_url(url)</code>","text":"<p>Ensure the URL is valid or parse it.</p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>def _ensure_url(self, url: Any) -&gt; Any:\n    \"\"\"Ensure the URL is valid or parse it.\"\"\"\n    if isinstance(url, str):\n        from accumulate.utils.url import URL\n        return URL.parse(url)\n    return url\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.UnknownAccount","title":"<code>UnknownAccount</code>","text":"<p>               Bases: <code>Account</code></p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>class UnknownAccount(Account):\n    def __init__(self, url: Any):\n        self.url = self._ensure_url(url)\n\n    def _ensure_url(self, url: Any) -&gt; Any:\n        \"\"\"Ensure the URL is a valid instance or parse it.\"\"\"\n        if isinstance(url, str):\n            from accumulate.utils.url import URL\n            return URL.parse(url)\n        return url\n\n    def get_url(self) -&gt; Any:\n        return self.url\n\n    def strip_url(self) -&gt; None:\n        self.url = self.url.strip_extras()\n</code></pre>"},{"location":"api_reference/#accumulate.models.accounts.UnknownAccount._ensure_url","title":"<code>_ensure_url(url)</code>","text":"<p>Ensure the URL is a valid instance or parse it.</p> Source code in <code>accumulate\\models\\accounts.py</code> <pre><code>def _ensure_url(self, url: Any) -&gt; Any:\n    \"\"\"Ensure the URL is a valid instance or parse it.\"\"\"\n    if isinstance(url, str):\n        from accumulate.utils.url import URL\n        return URL.parse(url)\n    return url\n</code></pre>"},{"location":"api_reference/#accumulate.models.submission","title":"<code>submission</code>","text":""},{"location":"api_reference/#accumulate.models.submission.Submission","title":"<code>Submission</code>  <code>dataclass</code>","text":"<p>Represents a transaction submission in the Accumulate blockchain.</p> Source code in <code>accumulate\\models\\submission.py</code> <pre><code>@dataclass\nclass Submission:\n    \"\"\"\n    Represents a transaction submission in the Accumulate blockchain.\n    \"\"\"\n    txid: Optional[str] = None  # Add `txid` field\n    status: Optional[Dict[str, Any]] = None  # Corresponds to protocol.TransactionStatus\n    success: bool = False  # Indicates whether the envelope was successfully submitted\n    message: Optional[str] = None  # Message returned by the consensus engine\n\n    def __post_init__(self):\n        if self.status is not None and not isinstance(self.status, dict):\n            raise TypeError(\"The 'status' field must be a dictionary or None.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Converts the Submission instance to a dictionary.\n        \"\"\"\n        return {\n            \"txid\": self.txid,\n            \"status\": self.status,\n            \"success\": self.success,\n            \"message\": self.message,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"Submission\":\n        \"\"\"\n        Creates a Submission instance from a dictionary.\n        \"\"\"\n        return cls(\n            txid=data.get(\"txid\"),  # extract the `txid` field\n            status=data.get(\"status\"),\n            success=data.get(\"success\", False),\n            message=data.get(\"message\"),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.submission.Submission.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Creates a Submission instance from a dictionary.</p> Source code in <code>accumulate\\models\\submission.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"Submission\":\n    \"\"\"\n    Creates a Submission instance from a dictionary.\n    \"\"\"\n    return cls(\n        txid=data.get(\"txid\"),  # extract the `txid` field\n        status=data.get(\"status\"),\n        success=data.get(\"success\", False),\n        message=data.get(\"message\"),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.submission.Submission.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the Submission instance to a dictionary.</p> Source code in <code>accumulate\\models\\submission.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the Submission instance to a dictionary.\n    \"\"\"\n    return {\n        \"txid\": self.txid,\n        \"status\": self.status,\n        \"success\": self.success,\n        \"message\": self.message,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.signature_types","title":"<code>signature_types</code>","text":""},{"location":"api_reference/#accumulate.models.signature_types.SignatureType","title":"<code>SignatureType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Cryptographic signature algorithms using string identifiers.</p> Source code in <code>accumulate\\models\\signature_types.py</code> <pre><code>class SignatureType(Enum):\n    \"\"\"Cryptographic signature algorithms using string identifiers.\"\"\"\n    UNKNOWN = 0x00\n    LEGACY_ED25519 = 0x01\n    ED25519 = 0x02\n    RCD1 = 0x03\n    RECEIPT = 0x04\n    PARTITION = 0x05\n    SET = 0x06\n    REMOTE = 0x07\n    BTC = 0x08\n    BTC_LEGACY = 0x09\n    ETH = 0x0A\n    DELEGATED = 0x0B\n    INTERNAL = 0x0C\n    AUTHORITY = 0x0D\n    RSA_SHA256 = 0x0E\n    ECDSA_SHA256 = 0x0F\n    TYPED_DATA = 0x10\n\n    @classmethod\n    def from_value(cls, value):\n        \"\"\"Retrieve an enum instance by its value.\"\"\"\n        for item in cls:\n            if item.value == value:\n                return item\n        raise ValueError(f\"Invalid SignatureType value: {value}\")\n\n    def to_rpc_format(self) -&gt; str:\n        \"\"\"Convert SignatureType to the expected string format for JSON-RPC.\"\"\"\n        mapping = {\n            SignatureType.UNKNOWN: \"unknown\",\n            SignatureType.LEGACY_ED25519: \"legacyEd25519\",\n            SignatureType.ED25519: \"ed25519\",\n            SignatureType.RCD1: \"rcd1\",\n            SignatureType.RECEIPT: \"receipt\",\n            SignatureType.PARTITION: \"partition\",\n            SignatureType.SET: \"set\",\n            SignatureType.REMOTE: \"remote\",\n            SignatureType.BTC: \"btc\",\n            SignatureType.BTC_LEGACY: \"btcLegacy\",\n            SignatureType.ETH: \"eth\",\n            SignatureType.DELEGATED: \"delegated\",\n            SignatureType.INTERNAL: \"internal\",\n            SignatureType.AUTHORITY: \"authority\",\n            SignatureType.RSA_SHA256: \"rsaSha256\",\n            SignatureType.ECDSA_SHA256: \"ecdsaSha256\",\n            SignatureType.TYPED_DATA: \"typedData\",\n        }\n        return mapping[self]\n</code></pre>"},{"location":"api_reference/#accumulate.models.signature_types.SignatureType.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Retrieve an enum instance by its value.</p> Source code in <code>accumulate\\models\\signature_types.py</code> <pre><code>@classmethod\ndef from_value(cls, value):\n    \"\"\"Retrieve an enum instance by its value.\"\"\"\n    for item in cls:\n        if item.value == value:\n            return item\n    raise ValueError(f\"Invalid SignatureType value: {value}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.signature_types.SignatureType.to_rpc_format","title":"<code>to_rpc_format()</code>","text":"<p>Convert SignatureType to the expected string format for JSON-RPC.</p> Source code in <code>accumulate\\models\\signature_types.py</code> <pre><code>def to_rpc_format(self) -&gt; str:\n    \"\"\"Convert SignatureType to the expected string format for JSON-RPC.\"\"\"\n    mapping = {\n        SignatureType.UNKNOWN: \"unknown\",\n        SignatureType.LEGACY_ED25519: \"legacyEd25519\",\n        SignatureType.ED25519: \"ed25519\",\n        SignatureType.RCD1: \"rcd1\",\n        SignatureType.RECEIPT: \"receipt\",\n        SignatureType.PARTITION: \"partition\",\n        SignatureType.SET: \"set\",\n        SignatureType.REMOTE: \"remote\",\n        SignatureType.BTC: \"btc\",\n        SignatureType.BTC_LEGACY: \"btcLegacy\",\n        SignatureType.ETH: \"eth\",\n        SignatureType.DELEGATED: \"delegated\",\n        SignatureType.INTERNAL: \"internal\",\n        SignatureType.AUTHORITY: \"authority\",\n        SignatureType.RSA_SHA256: \"rsaSha256\",\n        SignatureType.ECDSA_SHA256: \"ecdsaSha256\",\n        SignatureType.TYPED_DATA: \"typedData\",\n    }\n    return mapping[self]\n</code></pre>"},{"location":"api_reference/#additional-models-schemas","title":"Additional Models &amp; Schemas","text":""},{"location":"api_reference/#accumulate.models.AccountAuthOperations","title":"<code>AccountAuthOperations</code>","text":""},{"location":"api_reference/#accumulate.models.AccountAuthOperations.AccountAuthOperation","title":"<code>AccountAuthOperation</code>","text":"<p>Base class for account authentication operations.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>class AccountAuthOperation:\n    \"\"\"\n    Base class for account authentication operations.\n    \"\"\"\n\n    def __init__(self, authority: URL):\n        self.authority = authority\n\n    def type(self) -&gt; AccountAuthOperationType:\n        \"\"\"\n        Return the operation type. Must be implemented by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement the `type` method.\")\n\n    def hash(self) -&gt; str:\n        \"\"\"\n        Generate a unique hash for this operation based on its attributes.\n        \"\"\"\n        serialized = f\"{self.type().name}:{self.authority}\"\n        return sha256(serialized.encode()).hexdigest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.AccountAuthOperations.AccountAuthOperation.hash","title":"<code>hash()</code>","text":"<p>Generate a unique hash for this operation based on its attributes.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>def hash(self) -&gt; str:\n    \"\"\"\n    Generate a unique hash for this operation based on its attributes.\n    \"\"\"\n    serialized = f\"{self.type().name}:{self.authority}\"\n    return sha256(serialized.encode()).hexdigest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.AccountAuthOperations.AccountAuthOperation.type","title":"<code>type()</code>","text":"<p>Return the operation type. Must be implemented by subclasses.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>def type(self) -&gt; AccountAuthOperationType:\n    \"\"\"\n    Return the operation type. Must be implemented by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement the `type` method.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.AccountAuthOperations.AddAccountAuthorityOperation","title":"<code>AddAccountAuthorityOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Represents an operation to add an authority to an account's authorization list.</p> <p>:param authority: The URL of the authority to add.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>class AddAccountAuthorityOperation(AccountAuthOperation):\n    \"\"\"\n    Represents an operation to add an authority to an account's authorization list.\n\n    :param authority: The URL of the authority to add.\n    \"\"\"\n\n    def __init__(self, authority: URL):\n        super().__init__(authority)\n\n    def type(self) -&gt; AccountAuthOperationType:\n        return AccountAuthOperationType.ADD_AUTHORITY\n</code></pre>"},{"location":"api_reference/#accumulate.models.AccountAuthOperations.DisableAccountAuthOperation","title":"<code>DisableAccountAuthOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Represents an operation to disable authorization for a specific authority.</p> <p>:param authority: The URL of the authority to disable.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>class DisableAccountAuthOperation(AccountAuthOperation):\n    \"\"\"\n    Represents an operation to disable authorization for a specific authority.\n\n    :param authority: The URL of the authority to disable.\n    \"\"\"\n\n    def __init__(self, authority: URL):\n        super().__init__(authority)\n\n    def type(self) -&gt; AccountAuthOperationType:\n        return AccountAuthOperationType.DISABLE\n</code></pre>"},{"location":"api_reference/#accumulate.models.AccountAuthOperations.EnableAccountAuthOperation","title":"<code>EnableAccountAuthOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Represents an operation to enable authorization for a specific authority.</p> <p>:param authority: The URL of the authority to enable.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>class EnableAccountAuthOperation(AccountAuthOperation):\n    \"\"\"\n    Represents an operation to enable authorization for a specific authority.\n\n    :param authority: The URL of the authority to enable.\n    \"\"\"\n\n    def __init__(self, authority: URL):\n        super().__init__(authority)\n\n    def type(self) -&gt; AccountAuthOperationType:\n        return AccountAuthOperationType.ENABLE\n</code></pre>"},{"location":"api_reference/#accumulate.models.AccountAuthOperations.RemoveAccountAuthorityOperation","title":"<code>RemoveAccountAuthorityOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Represents an operation to remove an authority from an account's authorization list.</p> <p>:param authority: The URL of the authority to remove.</p> Source code in <code>accumulate\\models\\AccountAuthOperations.py</code> <pre><code>class RemoveAccountAuthorityOperation(AccountAuthOperation):\n    \"\"\"\n    Represents an operation to remove an authority from an account's authorization list.\n\n    :param authority: The URL of the authority to remove.\n    \"\"\"\n\n    def __init__(self, authority: URL):\n        super().__init__(authority)\n\n    def type(self) -&gt; AccountAuthOperationType:\n        return AccountAuthOperationType.REMOVE_AUTHORITY\n</code></pre>"},{"location":"api_reference/#accumulate.models.address","title":"<code>address</code>","text":""},{"location":"api_reference/#accumulate.models.address.Address","title":"<code>Address</code>","text":"<p>Abstract base class for addresses.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>class Address:\n    \"\"\"Abstract base class for addresses.\"\"\"\n\n    def get_type(self) -&gt; str:\n        \"\"\"Get the type of the address.\"\"\"\n        raise NotImplementedError\n\n    def get_public_key_hash(self) -&gt; Tuple[Optional[bytes], bool]:\n        \"\"\"Get the public key hash.\"\"\"\n        raise NotImplementedError\n\n    def get_public_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        \"\"\"Get the public key.\"\"\"\n        raise NotImplementedError\n\n    def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        \"\"\"Get the private key.\"\"\"\n        raise NotImplementedError\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return the string representation of the address.\"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Address.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the address.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return the string representation of the address.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Address.get_private_key","title":"<code>get_private_key()</code>","text":"<p>Get the private key.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n    \"\"\"Get the private key.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Address.get_public_key","title":"<code>get_public_key()</code>","text":"<p>Get the public key.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def get_public_key(self) -&gt; Tuple[Optional[bytes], bool]:\n    \"\"\"Get the public key.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Address.get_public_key_hash","title":"<code>get_public_key_hash()</code>","text":"<p>Get the public key hash.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def get_public_key_hash(self) -&gt; Tuple[Optional[bytes], bool]:\n    \"\"\"Get the public key hash.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Address.get_type","title":"<code>get_type()</code>","text":"<p>Get the type of the address.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"Get the type of the address.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Lite","title":"<code>Lite</code>","text":"<p>               Bases: <code>Address</code></p> <p>Represents a lightweight address.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>class Lite(Address):\n    \"\"\"Represents a lightweight address.\"\"\"\n\n    def __init__(self, url: str, address_bytes: bytes):\n        self.url = url\n        self.address_bytes = address_bytes\n\n    def get_type(self) -&gt; str:\n        return \"Unknown\"\n\n    def get_public_key_hash(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def get_public_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def __str__(self) -&gt; str:\n        return self.url\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.PrivateKey","title":"<code>PrivateKey</code>","text":"<p>               Bases: <code>PublicKey</code></p> <p>Represents an address based on a private key.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>class PrivateKey(PublicKey):\n    \"\"\"Represents an address based on a private key.\"\"\"\n\n    def __init__(self, signature_type: str, public_key: bytes, private_key: bytes):\n        super().__init__(signature_type, public_key)\n        self.private_key = private_key\n\n    def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return self.private_key, True\n\n    def __str__(self) -&gt; str:\n        return self.private_key.hex()\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.PublicKey","title":"<code>PublicKey</code>","text":"<p>               Bases: <code>Address</code></p> <p>Represents an address based on a public key.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>class PublicKey(Address):\n    \"\"\"Represents an address based on a public key.\"\"\"\n\n    def __init__(self, signature_type: str, public_key: bytes):\n        self.signature_type = signature_type\n        self.public_key = public_key\n\n    def get_type(self) -&gt; str:\n        return self.signature_type\n\n    def get_public_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return self.public_key, True\n\n    def get_public_key_hash(self) -&gt; Tuple[Optional[bytes], bool]:\n        # Simulate hashing for demonstration\n        return hash_public_key(self.public_key, self.signature_type)\n\n    def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def __str__(self) -&gt; str:\n        hash_value, valid = self.get_public_key_hash()\n        if not valid:\n            return \"&lt;invalid address&gt;\"\n        return format_address(self.signature_type, hash_value)\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.PublicKeyHashAddress","title":"<code>PublicKeyHashAddress</code>","text":"<p>               Bases: <code>Address</code></p> <p>Represents an address based on a public key hash.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>class PublicKeyHashAddress(Address):\n    \"\"\"Represents an address based on a public key hash.\"\"\"\n\n    def __init__(self, signature_type: str, hash_value: bytes):\n        self.signature_type = signature_type #\n        self.hash_value = hash_value #\n\n    def get_type(self) -&gt; str:\n        return self.signature_type\n\n    def get_public_key_hash(self) -&gt; Tuple[Optional[bytes], bool]:\n        return self.hash_value, True #\n    def get_public_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def __str__(self) -&gt; str:\n        return format_address(self.signature_type, self.hash_value)\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.Unknown","title":"<code>Unknown</code>","text":"<p>               Bases: <code>Address</code></p> <p>Represents an unknown address.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>class Unknown(Address):\n    \"\"\"Represents an unknown address.\"\"\"\n\n    def __init__(self, value: bytes, encoding: str = \"hex\"):\n        self.value = value\n        self.encoding = encoding\n\n    def get_type(self) -&gt; str:\n        return \"Unknown\"\n\n    def get_public_key_hash(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def get_public_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def get_private_key(self) -&gt; Tuple[Optional[bytes], bool]:\n        return None, False\n\n    def __str__(self) -&gt; str:\n        if self.encoding == \"base58\":\n            return base58.b58encode(self.value).decode()\n        return self.value.hex()\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.format_address","title":"<code>format_address(signature_type, hash_value)</code>","text":"<p>Format an address based on its type and hash value.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def format_address(signature_type: str, hash_value: bytes) -&gt; str:\n    \"\"\"Format an address based on its type and hash value.\"\"\"\n    if signature_type in {\"ED25519\", \"LegacyED25519\"}:\n        return f\"AC1-{hash_value.hex()}\"\n    if signature_type == \"RCD1\":\n        return f\"FA-{hash_value.hex()}\"\n    if signature_type in {\"BTC\", \"BTCLegacy\"}:\n        return f\"BTC-{hash_value.hex()}\"\n    if signature_type == \"ETH\":\n        return f\"ETH-{hash_value.hex()}\"\n    if signature_type == \"EcdsaSha256\":\n        return f\"AC2-{hash_value.hex()}\"\n    if signature_type == \"RsaSha256\":\n        return f\"AC3-{hash_value.hex()}\"\n    return f\"MH-{hash_value.hex()}\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.address.hash_public_key","title":"<code>hash_public_key(public_key, signature_type)</code>","text":"<p>Hash a public key based on its signature type.</p> Source code in <code>accumulate\\models\\address.py</code> <pre><code>def hash_public_key(public_key: bytes, signature_type: str) -&gt; Tuple[Optional[bytes], bool]:\n    \"\"\"Hash a public key based on its signature type.\"\"\"\n    try:\n        if signature_type in {\"ED25519\", \"LegacyED25519\"}:\n            return hashlib.sha256(public_key).digest(), True\n        if signature_type == \"BTC\":\n            return hashlib.sha256(public_key).digest(), True\n        return None, False\n    except Exception:\n        return None, False\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth","title":"<code>auth</code>","text":""},{"location":"api_reference/#accumulate.models.auth.AccountAuth","title":"<code>AccountAuth</code>","text":"<p>Manages account authorities for access control.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>class AccountAuth:\n    \"\"\"Manages account authorities for access control.\"\"\"\n\n    def __init__(self, authorities: Optional[List[AuthorityEntry]] = None):\n        \"\"\"\n        Initialize AccountAuth.\n\n        :param authorities: Optional list of AuthorityEntry objects.\n        \"\"\"\n        self.authorities: List[AuthorityEntry] = authorities or []\n\n    def key_book(self) -&gt; Optional[URL]:\n        \"\"\"\n        Get the primary authority's URL.\n\n        :return: URL of the primary authority or None if not available.\n        \"\"\"\n        return self.authorities[0].url if self.authorities else None\n\n    def manager_key_book(self) -&gt; Optional[URL]:\n        \"\"\"\n        Get the secondary authority's URL.\n\n        :return: URL of the secondary authority or None if not available.\n        \"\"\"\n        return self.authorities[1].url if len(self.authorities) &gt; 1 else None\n\n    def all_authorities_are_disabled(self) -&gt; bool:\n        \"\"\"\n        Check if all authorities are disabled.\n\n        :return: True if all authorities are disabled, False otherwise.\n        \"\"\"\n        return all(authority.disabled for authority in self.authorities)\n\n    def get_authority(self, entry_url: URL) -&gt; Tuple[Optional[AuthorityEntry], bool]:\n        \"\"\"\n        Get an authority entry by its URL.\n\n        :param entry_url: The URL of the authority to find.\n        :return: A tuple containing the AuthorityEntry and a boolean indicating if it was found.\n        \"\"\"\n        for authority in self.authorities:\n            if authority.url == entry_url:\n                return authority, True\n        return None, False\n\n    def add_authority(self, entry_url: URL) -&gt; Tuple[AuthorityEntry, bool]:\n        \"\"\"\n        Add a new authority entry.\n\n        :param entry_url: The URL of the new authority.\n        :return: A tuple containing the new or existing AuthorityEntry and a boolean indicating if it was newly added.\n        \"\"\"\n        existing_authority, found = self.get_authority(entry_url)\n        if found:\n            return existing_authority, False\n        new_authority = AuthorityEntry(url=entry_url)\n        self.authorities.append(new_authority)\n        self.authorities.sort(key=lambda auth: auth.url)  # Keep the list sorted\n        return new_authority, True\n\n    def remove_authority(self, entry_url: URL) -&gt; bool:\n        \"\"\"\n        Remove an authority entry by its URL.\n\n        :param entry_url: The URL of the authority to remove.\n        :return: True if the authority was removed, False otherwise.\n        \"\"\"\n        for i, authority in enumerate(self.authorities):\n            if authority.url == entry_url:\n                del self.authorities[i]\n                return True\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.__init__","title":"<code>__init__(authorities=None)</code>","text":"<p>Initialize AccountAuth.</p> <p>:param authorities: Optional list of AuthorityEntry objects.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def __init__(self, authorities: Optional[List[AuthorityEntry]] = None):\n    \"\"\"\n    Initialize AccountAuth.\n\n    :param authorities: Optional list of AuthorityEntry objects.\n    \"\"\"\n    self.authorities: List[AuthorityEntry] = authorities or []\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.add_authority","title":"<code>add_authority(entry_url)</code>","text":"<p>Add a new authority entry.</p> <p>:param entry_url: The URL of the new authority. :return: A tuple containing the new or existing AuthorityEntry and a boolean indicating if it was newly added.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def add_authority(self, entry_url: URL) -&gt; Tuple[AuthorityEntry, bool]:\n    \"\"\"\n    Add a new authority entry.\n\n    :param entry_url: The URL of the new authority.\n    :return: A tuple containing the new or existing AuthorityEntry and a boolean indicating if it was newly added.\n    \"\"\"\n    existing_authority, found = self.get_authority(entry_url)\n    if found:\n        return existing_authority, False\n    new_authority = AuthorityEntry(url=entry_url)\n    self.authorities.append(new_authority)\n    self.authorities.sort(key=lambda auth: auth.url)  # Keep the list sorted\n    return new_authority, True\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.all_authorities_are_disabled","title":"<code>all_authorities_are_disabled()</code>","text":"<p>Check if all authorities are disabled.</p> <p>:return: True if all authorities are disabled, False otherwise.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def all_authorities_are_disabled(self) -&gt; bool:\n    \"\"\"\n    Check if all authorities are disabled.\n\n    :return: True if all authorities are disabled, False otherwise.\n    \"\"\"\n    return all(authority.disabled for authority in self.authorities)\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.get_authority","title":"<code>get_authority(entry_url)</code>","text":"<p>Get an authority entry by its URL.</p> <p>:param entry_url: The URL of the authority to find. :return: A tuple containing the AuthorityEntry and a boolean indicating if it was found.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def get_authority(self, entry_url: URL) -&gt; Tuple[Optional[AuthorityEntry], bool]:\n    \"\"\"\n    Get an authority entry by its URL.\n\n    :param entry_url: The URL of the authority to find.\n    :return: A tuple containing the AuthorityEntry and a boolean indicating if it was found.\n    \"\"\"\n    for authority in self.authorities:\n        if authority.url == entry_url:\n            return authority, True\n    return None, False\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.key_book","title":"<code>key_book()</code>","text":"<p>Get the primary authority's URL.</p> <p>:return: URL of the primary authority or None if not available.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def key_book(self) -&gt; Optional[URL]:\n    \"\"\"\n    Get the primary authority's URL.\n\n    :return: URL of the primary authority or None if not available.\n    \"\"\"\n    return self.authorities[0].url if self.authorities else None\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.manager_key_book","title":"<code>manager_key_book()</code>","text":"<p>Get the secondary authority's URL.</p> <p>:return: URL of the secondary authority or None if not available.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def manager_key_book(self) -&gt; Optional[URL]:\n    \"\"\"\n    Get the secondary authority's URL.\n\n    :return: URL of the secondary authority or None if not available.\n    \"\"\"\n    return self.authorities[1].url if len(self.authorities) &gt; 1 else None\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AccountAuth.remove_authority","title":"<code>remove_authority(entry_url)</code>","text":"<p>Remove an authority entry by its URL.</p> <p>:param entry_url: The URL of the authority to remove. :return: True if the authority was removed, False otherwise.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def remove_authority(self, entry_url: URL) -&gt; bool:\n    \"\"\"\n    Remove an authority entry by its URL.\n\n    :param entry_url: The URL of the authority to remove.\n    :return: True if the authority was removed, False otherwise.\n    \"\"\"\n    for i, authority in enumerate(self.authorities):\n        if authority.url == entry_url:\n            del self.authorities[i]\n            return True\n    return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AuthorityEntry","title":"<code>AuthorityEntry</code>","text":"<p>Represents an authority entry with a URL and a disabled flag.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>class AuthorityEntry:\n    \"\"\"Represents an authority entry with a URL and a disabled flag.\"\"\"\n\n    def __init__(self, url: URL, disabled: bool = False):\n        \"\"\"\n        Initialize an AuthorityEntry.\n\n        :param url: The URL of the authority.\n        :param disabled: Boolean flag indicating if the authority is disabled.\n        \"\"\"\n        self.url = url\n        self.disabled = disabled\n</code></pre>"},{"location":"api_reference/#accumulate.models.auth.AuthorityEntry.__init__","title":"<code>__init__(url, disabled=False)</code>","text":"<p>Initialize an AuthorityEntry.</p> <p>:param url: The URL of the authority. :param disabled: Boolean flag indicating if the authority is disabled.</p> Source code in <code>accumulate\\models\\auth.py</code> <pre><code>def __init__(self, url: URL, disabled: bool = False):\n    \"\"\"\n    Initialize an AuthorityEntry.\n\n    :param url: The URL of the authority.\n    :param disabled: Boolean flag indicating if the authority is disabled.\n    \"\"\"\n    self.url = url\n    self.disabled = disabled\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions","title":"<code>base_transactions</code>","text":""},{"location":"api_reference/#accumulate.models.base_transactions.ExpireOptions","title":"<code>ExpireOptions</code>","text":"<p>Represents expiration options for a transaction.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>class ExpireOptions:\n    \"\"\"\n    Represents expiration options for a transaction.\n    \"\"\"\n\n    def __init__(self, at_time: Optional[int] = None):\n        \"\"\"\n        :param at_time: The expiration time as a Unix timestamp.\n        \"\"\"\n        self.at_time = at_time\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.ExpireOptions.__init__","title":"<code>__init__(at_time=None)</code>","text":"<p>:param at_time: The expiration time as a Unix timestamp.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def __init__(self, at_time: Optional[int] = None):\n    \"\"\"\n    :param at_time: The expiration time as a Unix timestamp.\n    \"\"\"\n    self.at_time = at_time\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.HoldUntilOptions","title":"<code>HoldUntilOptions</code>","text":"<p>Represents hold-until options for a transaction.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>class HoldUntilOptions:\n    \"\"\"\n    Represents hold-until options for a transaction.\n    \"\"\"\n\n    def __init__(self, minor_block: Optional[int] = None):\n        \"\"\"\n        :param minor_block: The minor block at which the transaction is held until.\n        \"\"\"\n        self.minor_block = minor_block\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.HoldUntilOptions.__init__","title":"<code>__init__(minor_block=None)</code>","text":"<p>:param minor_block: The minor block at which the transaction is held until.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def __init__(self, minor_block: Optional[int] = None):\n    \"\"\"\n    :param minor_block: The minor block at which the transaction is held until.\n    \"\"\"\n    self.minor_block = minor_block\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase","title":"<code>TransactionBodyBase</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all transaction bodies, providing standardized marshaling/unmarshaling.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>class TransactionBodyBase(ABC):\n    \"\"\"Base class for all transaction bodies, providing standardized marshaling/unmarshaling.\"\"\"\n\n    @abstractmethod\n    def type(self) -&gt; TransactionType:\n        \"\"\"Return the transaction type.\"\"\"\n        pass\n\n    @abstractmethod\n    def fields_to_encode(self):\n        \"\"\"Return the fields to encode as a list of (field_id, value, encoding_function).\"\"\"\n        pass\n\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"Generic marshaling for all transactions using structured encoding.\"\"\"\n        logger.debug(f\" START Marshaling {self.__class__.__name__}\")\n\n        serialized = b\"\"\n\n        #  Confirm Execution (Force an Output to Ensure it Runs)\n        assert True, \" DEBUG: `marshal()` method is being executed!\"\n\n        for field_num, value, encode_func in self.fields_to_encode():\n            encoded_value = encode_func(value)\n\n            #  Explicit Debugging of Each Field\n            logger.debug(f\" Encoding Field {field_num}: {encoded_value.hex() if isinstance(encoded_value, bytes) else encoded_value}\")\n\n            serialized += field_marshal_binary(field_num, encoded_value)\n\n        logger.debug(f\" FINAL Marshaled {self.__class__.__name__} (HEX): {serialized.hex()}\")\n\n        return serialized\n\n\n    @classmethod\n    @abstractmethod\n    def unmarshal(cls, data: bytes):\n        \"\"\"Generic unmarshaling method to be implemented per transaction type.\"\"\"\n        pass\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert transaction to a dictionary with correct type formatting.\"\"\"\n        return {\"type\": self._format_transaction_type(self.type().name)}\n\n    @staticmethod\n    def _format_transaction_type(transaction_type: str) -&gt; str:\n        \"\"\"Convert ENUM transaction type to lowerCamelCase for JSON compatibility.\"\"\"\n        words = transaction_type.lower().split(\"_\")\n        return words[0] + \"\".join(word.capitalize() for word in words[1:])\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase._format_transaction_type","title":"<code>_format_transaction_type(transaction_type)</code>  <code>staticmethod</code>","text":"<p>Convert ENUM transaction type to lowerCamelCase for JSON compatibility.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@staticmethod\ndef _format_transaction_type(transaction_type: str) -&gt; str:\n    \"\"\"Convert ENUM transaction type to lowerCamelCase for JSON compatibility.\"\"\"\n    words = transaction_type.lower().split(\"_\")\n    return words[0] + \"\".join(word.capitalize() for word in words[1:])\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase.fields_to_encode","title":"<code>fields_to_encode()</code>  <code>abstractmethod</code>","text":"<p>Return the fields to encode as a list of (field_id, value, encoding_function).</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@abstractmethod\ndef fields_to_encode(self):\n    \"\"\"Return the fields to encode as a list of (field_id, value, encoding_function).\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase.marshal","title":"<code>marshal()</code>","text":"<p>Generic marshaling for all transactions using structured encoding.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"Generic marshaling for all transactions using structured encoding.\"\"\"\n    logger.debug(f\" START Marshaling {self.__class__.__name__}\")\n\n    serialized = b\"\"\n\n    #  Confirm Execution (Force an Output to Ensure it Runs)\n    assert True, \" DEBUG: `marshal()` method is being executed!\"\n\n    for field_num, value, encode_func in self.fields_to_encode():\n        encoded_value = encode_func(value)\n\n        #  Explicit Debugging of Each Field\n        logger.debug(f\" Encoding Field {field_num}: {encoded_value.hex() if isinstance(encoded_value, bytes) else encoded_value}\")\n\n        serialized += field_marshal_binary(field_num, encoded_value)\n\n    logger.debug(f\" FINAL Marshaled {self.__class__.__name__} (HEX): {serialized.hex()}\")\n\n    return serialized\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert transaction to a dictionary with correct type formatting.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert transaction to a dictionary with correct type formatting.\"\"\"\n    return {\"type\": self._format_transaction_type(self.type().name)}\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase.type","title":"<code>type()</code>  <code>abstractmethod</code>","text":"<p>Return the transaction type.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@abstractmethod\ndef type(self) -&gt; TransactionType:\n    \"\"\"Return the transaction type.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyBase.unmarshal","title":"<code>unmarshal(data)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Generic unmarshaling method to be implemented per transaction type.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@classmethod\n@abstractmethod\ndef unmarshal(cls, data: bytes):\n    \"\"\"Generic unmarshaling method to be implemented per transaction type.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyFactory","title":"<code>TransactionBodyFactory</code>","text":"<p>Factory for creating transaction body instances based on transaction type.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>class TransactionBodyFactory:\n    \"\"\"\n    Factory for creating transaction body instances based on transaction type.\n    \"\"\"\n\n    @classmethod\n    async def create(cls, client, transaction_type: TransactionType, *args, **kwargs) -&gt; Optional[TransactionBodyBase]:\n        \"\"\"\n        Dynamically create a transaction body instance of the specified type.\n\n        :param client: AccumulateClient instance (optional, for API interactions).\n        :param transaction_type: Enum specifying the transaction type.\n        :param args: Positional arguments for the transaction body constructor.\n        :param kwargs: Keyword arguments for the transaction body constructor.\n        :return: A fully initialized TransactionBodyBase subclass instance, or None if unsupported.\n        \"\"\"\n        from accumulate.models.transactions import (\n            AddCredits, CreateIdentity, SendTokens, CreateDataAccount, CreateTokenAccount,\n            WriteData, IssueTokens, BurnTokens, TransferCredits, RemoteTransaction, \n            UpdateKeyPage, UpdateAccountAuth, CreateToken\n        )\n\n        TRANSACTION_TYPE_MAP: Dict[TransactionType, Type[TransactionBodyBase]] = {\n            TransactionType.ADD_CREDITS: AddCredits,\n            TransactionType.CREATE_IDENTITY: CreateIdentity,\n            TransactionType.SEND_TOKENS: SendTokens,\n            TransactionType.CREATE_DATA_ACCOUNT: CreateDataAccount,\n            TransactionType.CREATE_TOKEN_ACCOUNT: CreateTokenAccount,\n            TransactionType.WRITE_DATA: WriteData,\n            TransactionType.ISSUE_TOKENS: IssueTokens,\n            TransactionType.BURN_TOKENS: BurnTokens,\n            TransactionType.TRANSFER_CREDITS: TransferCredits,\n            TransactionType.REMOTE: RemoteTransaction,\n            TransactionType.UPDATE_KEY_PAGE: UpdateKeyPage,\n            TransactionType.UPDATE_ACCOUNT_AUTH: UpdateAccountAuth,\n            TransactionType.CREATE_TOKEN: CreateToken,\n        }\n\n        if transaction_type not in TRANSACTION_TYPE_MAP:\n            logger.error(f\" Unsupported transaction type: {transaction_type}\")\n            return None  # Or raise an exception if you prefer\n\n        transaction_class = TRANSACTION_TYPE_MAP[transaction_type]\n\n        #  Create the transaction body instance dynamically\n        instance = transaction_class(client, *args, **kwargs)\n\n        #  If it has an initialize method, call it asynchronously (e.g., fetching oracle price)\n        if hasattr(instance, \"initialize\") and callable(instance.initialize):\n            await instance.initialize(client)\n\n        return instance\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionBodyFactory.create","title":"<code>create(client, transaction_type, *args, **kwargs)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Dynamically create a transaction body instance of the specified type.</p> <p>:param client: AccumulateClient instance (optional, for API interactions). :param transaction_type: Enum specifying the transaction type. :param args: Positional arguments for the transaction body constructor. :param kwargs: Keyword arguments for the transaction body constructor. :return: A fully initialized TransactionBodyBase subclass instance, or None if unsupported.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@classmethod\nasync def create(cls, client, transaction_type: TransactionType, *args, **kwargs) -&gt; Optional[TransactionBodyBase]:\n    \"\"\"\n    Dynamically create a transaction body instance of the specified type.\n\n    :param client: AccumulateClient instance (optional, for API interactions).\n    :param transaction_type: Enum specifying the transaction type.\n    :param args: Positional arguments for the transaction body constructor.\n    :param kwargs: Keyword arguments for the transaction body constructor.\n    :return: A fully initialized TransactionBodyBase subclass instance, or None if unsupported.\n    \"\"\"\n    from accumulate.models.transactions import (\n        AddCredits, CreateIdentity, SendTokens, CreateDataAccount, CreateTokenAccount,\n        WriteData, IssueTokens, BurnTokens, TransferCredits, RemoteTransaction, \n        UpdateKeyPage, UpdateAccountAuth, CreateToken\n    )\n\n    TRANSACTION_TYPE_MAP: Dict[TransactionType, Type[TransactionBodyBase]] = {\n        TransactionType.ADD_CREDITS: AddCredits,\n        TransactionType.CREATE_IDENTITY: CreateIdentity,\n        TransactionType.SEND_TOKENS: SendTokens,\n        TransactionType.CREATE_DATA_ACCOUNT: CreateDataAccount,\n        TransactionType.CREATE_TOKEN_ACCOUNT: CreateTokenAccount,\n        TransactionType.WRITE_DATA: WriteData,\n        TransactionType.ISSUE_TOKENS: IssueTokens,\n        TransactionType.BURN_TOKENS: BurnTokens,\n        TransactionType.TRANSFER_CREDITS: TransferCredits,\n        TransactionType.REMOTE: RemoteTransaction,\n        TransactionType.UPDATE_KEY_PAGE: UpdateKeyPage,\n        TransactionType.UPDATE_ACCOUNT_AUTH: UpdateAccountAuth,\n        TransactionType.CREATE_TOKEN: CreateToken,\n    }\n\n    if transaction_type not in TRANSACTION_TYPE_MAP:\n        logger.error(f\" Unsupported transaction type: {transaction_type}\")\n        return None  # Or raise an exception if you prefer\n\n    transaction_class = TRANSACTION_TYPE_MAP[transaction_type]\n\n    #  Create the transaction body instance dynamically\n    instance = transaction_class(client, *args, **kwargs)\n\n    #  If it has an initialize method, call it asynchronously (e.g., fetching oracle price)\n    if hasattr(instance, \"initialize\") and callable(instance.initialize):\n        await instance.initialize(client)\n\n    return instance\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionHeader","title":"<code>TransactionHeader</code>","text":"<p>Represents the header of a transaction, containing metadata and conditions.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>class TransactionHeader:\n    \"\"\"\n    Represents the header of a transaction, containing metadata and conditions.\n    \"\"\"\n\n    def __init__(\n        self,\n        principal: str,\n        initiator: bytes,\n        timestamp: int,\n        signature_type: SignatureType,\n        memo: Optional[str] = None,\n        metadata: Optional[bytes] = None,\n        expire: Optional[\"ExpireOptions\"] = None,\n        hold_until: Optional[\"HoldUntilOptions\"] = None,\n        authorities: Optional[List[str]] = None,\n    ):\n        self.timestamp = timestamp\n        self.principal = principal\n        self.initiator = initiator\n        self.signature_type = signature_type\n        self.memo = memo\n        self.metadata = metadata\n        self.expire = expire\n        self.hold_until = hold_until\n        self.authorities = authorities or []\n\n\n    @classmethod\n    async def create(\n        cls,\n        principal: str,\n        public_key: bytes,\n        signer: \"Signer\",\n        timestamp: Optional[int] = None,\n        transaction_body=None,  #  Add transaction body to check for RemoteTransaction\n    ) -&gt; \"TransactionHeader\":\n        \"\"\"Automatically compute the initiator hash and return a fully constructed TransactionHeader.\"\"\"\n\n        from accumulate.signing.signer import Signer\n        from accumulate.signing.timestamp import TimestampFromVariable\n        from accumulate.models.transactions import RemoteTransaction  #  Import RemoteTransaction\n\n        #  If this is a RemoteTransaction, set header differently\n        if isinstance(transaction_body, RemoteTransaction):\n            logger.info(\" RemoteTransaction detected! Adjusting header...\")\n\n            #  Use the referenced transaction's hash as the initiator\n            initiator_hash = transaction_body.hash  # This should be the original signed transaction hash\n\n            #  Remote Transactions do not need a new timestamp\n            timestamp = None  \n\n            logger.info(f\" Using referenced transaction hash: {initiator_hash.hex()}\")\n\n        else:\n\n            #  Generate timestamp only if it's not provided\n            timestamp = timestamp or TimestampFromVariable().get()\n\n            #  Fetch signer version dynamically\n            signer_version = await signer.get_signer_version()\n\n            #  Fetch the correct signature type dynamically\n            signature_type = await signer.get_signature_type()\n\n            #  Use the correct Lite Identity URL (not a token sub-account)\n            signer_url = str(signer.url)  #  Extract URL from Signer object\n\n            logger.info(f\" Correcting Signer URL (used in metadata hash): {signer_url}\")\n\n            #  Compute initiator hash using the same function as `Signer.sign_transaction()`\n            initiator_hash = Signer.calculate_metadata_hash(\n                public_key, timestamp, signer_url, signer_version, signature_type.value\n            )\n\n            logger.info(f\" Computed Initiator Hash Header (public key): {public_key.hex()}\")\n            logger.info(f\" Computed Initiator Hash Header (timestamp): {timestamp}\")\n            logger.info(f\" Computed Initiator Hash Header (signer): {principal}\")\n            logger.info(f\" Computed Initiator Hash Header (signer_version): {signer_version}\")\n            logger.info(f\" Computed Initiator Hash Header (signature_type.value): {signature_type.value}\")\n            logger.info(f\" Computed Initiator Hash (from TransactionHeader.create()): {initiator_hash.hex()}\")\n\n        #  Ensure timestamp and signature type are included when creating the instance\n        return cls(\n            principal=principal,\n            initiator=initiator_hash,\n            timestamp=timestamp,  #  This will be None for Remote Transactions\n            signature_type=signature_type if not isinstance(transaction_body, RemoteTransaction) else None,\n        )\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the transaction header to a dictionary while conditionally including optional fields.\"\"\"\n        txn_dict = {\n            \"principal\": self.principal,\n            \"initiator\": self.initiator.hex(),\n        }\n        if self.memo:\n            txn_dict[\"memo\"] = self.memo\n        if self.metadata:\n            txn_dict[\"metadata\"] = base64.b64encode(self.metadata).decode()\n        if self.expire:\n            txn_dict[\"expire\"] = self.expire.at_time\n        if self.hold_until:\n            txn_dict[\"hold_until\"] = self.hold_until.minor_block\n        if self.authorities:\n            txn_dict[\"authorities\"] = self.authorities\n        return txn_dict\n\n    def marshal_binary(self) -&gt; bytes:\n        \"\"\"Serialize the transaction header to bytes using the updated field\u2010based encoding.\"\"\"\n        print(\"\\n DEBUG: Marshaling Transaction Header\")\n        result = b\"\"\n\n        # Field 1: Principal \u2013 encode as: [varint(length)] + principal_bytes\n        principal_bytes = self.principal.encode(\"utf-8\")\n        field1 = field_marshal_binary(1, encode_uvarint(len(principal_bytes)) + principal_bytes)\n        result += field1\n        print(f\"   Field 1 (Principal): {field1.hex()}\")\n\n        # Field 2: Initiator \u2013 raw bytes (assumed fixed length, e.g. 32 bytes)\n        field2 = field_marshal_binary(2, self.initiator)\n        result += field2\n        print(f\"   Field 2 (Initiator): {field2.hex()}\")\n\n        # Optional Field 4: Memo (if present)\n        if self.memo:\n            memo_bytes = self.memo.encode(\"utf-8\")\n            field4 = field_marshal_binary(4, encode_uvarint(len(memo_bytes)) + memo_bytes)\n            result += field4\n            print(f\"   Field 4 (Memo): {field4.hex()}\")\n\n        # Optional Field 5: Metadata (if present)\n        if self.metadata:\n            field5 = field_marshal_binary(5, encode_uvarint(len(self.metadata)) + self.metadata)\n            result += field5\n            print(f\"   Field 5 (Metadata): {field5.hex()}\")\n\n        # Optional Field 6: Expire (if present; fixed 8 bytes)\n        if self.expire:\n            expire_bytes = struct.pack(\"&gt;Q\", self.expire.at_time)\n            field6 = field_marshal_binary(6, expire_bytes)\n            result += field6\n            print(f\"   Field 6 (Expire): {field6.hex()}\")\n\n        # Optional Field 7: Hold Until (if present; fixed 8 bytes)\n        if self.hold_until:\n            hold_until_bytes = struct.pack(\"&gt;Q\", self.hold_until.minor_block)\n            field7 = field_marshal_binary(7, hold_until_bytes)\n            result += field7\n            print(f\"   Field 7 (Hold Until): {field7.hex()}\")\n\n        # Optional Field 8: Authorities (if present; encoded as length-prefixed UTF-8 string)\n        if self.authorities:\n            auth_str = \",\".join(self.authorities)\n            auth_bytes = auth_str.encode(\"utf-8\")\n            field8 = field_marshal_binary(8, encode_uvarint(len(auth_bytes)) + auth_bytes)\n            result += field8\n            print(f\"   Field 8 (Authorities): {field8.hex()}\")\n\n        print(f\"   Final Header Encoding: {result.hex()}\")\n        return result\n\n    @staticmethod\n    def unmarshal(data: bytes) -&gt; \"TransactionHeader\":\n        \"\"\"Deserialize the transaction header from bytes using the updated encoding scheme.\"\"\"\n        print(\"\\n DEBUG: Unmarshaling Transaction Header\")\n        reader = io.BytesIO(data)\n\n        principal = None\n        initiator = None\n        memo = None\n        metadata = None\n        expire = None\n        hold_until = None\n        authorities = None\n\n        # Process fields one by one (each field starts with a 1-byte field id)\n        while True:\n            field_id_byte = reader.read(1)\n            if not field_id_byte:\n                break  # End of header data\n            field_id = field_id_byte[0]\n            if field_id == 1:\n                # Principal is length-prefixed: read length then string\n                plen = read_uvarint(reader)\n                principal = reader.read(plen).decode(\"utf-8\")\n                print(f\"   Unmarshaled Field 1 (Principal): {principal}\")\n            elif field_id == 2:\n                # Initiator: fixed length (assume 32 bytes)\n                initiator = reader.read(32)\n                print(f\"   Unmarshaled Field 2 (Initiator): {initiator.hex()}\")\n            elif field_id == 4:\n                # Memo: length-prefixed string\n                mlen = read_uvarint(reader)\n                memo = reader.read(mlen).decode(\"utf-8\")\n                print(f\"   Unmarshaled Field 4 (Memo): {memo}\")\n            elif field_id == 5:\n                # Metadata: length-prefixed bytes\n                mlen = read_uvarint(reader)\n                metadata = reader.read(mlen)\n                print(f\"   Unmarshaled Field 5 (Metadata): {metadata.hex()}\")\n            elif field_id == 6:\n                # Expire: fixed 8 bytes\n                expire_val = struct.unpack(\"&gt;Q\", reader.read(8))[0]\n                if expire_val &gt; 0:\n                    expire = ExpireOptions(expire_val)\n                print(f\"   Unmarshaled Field 6 (Expire): {expire_val}\")\n            elif field_id == 7:\n                # Hold Until: fixed 8 bytes\n                hold_val = struct.unpack(\"&gt;Q\", reader.read(8))[0]\n                if hold_val &gt; 0:\n                    hold_until = HoldUntilOptions(hold_val)\n                print(f\"   Unmarshaled Field 7 (Hold Until): {hold_val}\")\n            elif field_id == 8:\n                # Authorities: length-prefixed string (comma-separated)\n                alen = read_uvarint(reader)\n                auth_data = reader.read(alen).decode(\"utf-8\")\n                authorities = auth_data.split(\",\")\n                print(f\"   Unmarshaled Field 8 (Authorities): {authorities}\")\n            else:\n                # Unknown field \u2013 skip (or break)\n                print(f\"   Unknown field id {field_id} encountered. Skipping.\")\n                break\n\n        return TransactionHeader(\n            principal=principal,\n            initiator=initiator,\n            memo=memo,\n            metadata=metadata,\n            expire=expire,\n            hold_until=hold_until,\n            authorities=authorities,\n        )\n\n\n    def build_transaction(self, txn):\n        \"\"\"\n        Build transaction JSON while conditionally including optional fields.\n        Ensures transactionHash matches header['initiator'] for validation.\n        Automatically wraps the transaction inside a list.\n        \"\"\"\n        from accumulate.models.transactions import Transaction\n\n        txn_hash = txn.get_hash()\n\n        expected_hash = txn.header.initiator.hex() if txn.header.initiator else None\n\n        logger.info(f\" Verifying Transaction Hash Before Sending\")\n        logger.info(f\" Computed Transaction Hash: {txn_hash.hex()}\")\n        logger.info(f\"vs Expected Hash from Initiator: {expected_hash}\")\n\n        if expected_hash and txn_hash.hex() != expected_hash:\n            logger.error(\" Transaction hash mismatch! Computed hash does not match the expected initiator hash.\")\n            raise ValueError(\"Transaction hash mismatch! Computed hash does not match the expected initiator hash.\")\n\n        txn_data = {\n            \"header\": txn.header.to_dict(),\n            \"body\": txn.body.to_dict() if txn.body else {}\n        }\n\n        #  Automatically wrap the transaction inside a list\n        return {\"transaction\": [txn_data]}\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionHeader.build_transaction","title":"<code>build_transaction(txn)</code>","text":"<p>Build transaction JSON while conditionally including optional fields. Ensures transactionHash matches header['initiator'] for validation. Automatically wraps the transaction inside a list.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def build_transaction(self, txn):\n    \"\"\"\n    Build transaction JSON while conditionally including optional fields.\n    Ensures transactionHash matches header['initiator'] for validation.\n    Automatically wraps the transaction inside a list.\n    \"\"\"\n    from accumulate.models.transactions import Transaction\n\n    txn_hash = txn.get_hash()\n\n    expected_hash = txn.header.initiator.hex() if txn.header.initiator else None\n\n    logger.info(f\" Verifying Transaction Hash Before Sending\")\n    logger.info(f\" Computed Transaction Hash: {txn_hash.hex()}\")\n    logger.info(f\"vs Expected Hash from Initiator: {expected_hash}\")\n\n    if expected_hash and txn_hash.hex() != expected_hash:\n        logger.error(\" Transaction hash mismatch! Computed hash does not match the expected initiator hash.\")\n        raise ValueError(\"Transaction hash mismatch! Computed hash does not match the expected initiator hash.\")\n\n    txn_data = {\n        \"header\": txn.header.to_dict(),\n        \"body\": txn.body.to_dict() if txn.body else {}\n    }\n\n    #  Automatically wrap the transaction inside a list\n    return {\"transaction\": [txn_data]}\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionHeader.create","title":"<code>create(principal, public_key, signer, timestamp=None, transaction_body=None)</code>  <code>async</code> <code>classmethod</code>","text":"<p>Automatically compute the initiator hash and return a fully constructed TransactionHeader.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@classmethod\nasync def create(\n    cls,\n    principal: str,\n    public_key: bytes,\n    signer: \"Signer\",\n    timestamp: Optional[int] = None,\n    transaction_body=None,  #  Add transaction body to check for RemoteTransaction\n) -&gt; \"TransactionHeader\":\n    \"\"\"Automatically compute the initiator hash and return a fully constructed TransactionHeader.\"\"\"\n\n    from accumulate.signing.signer import Signer\n    from accumulate.signing.timestamp import TimestampFromVariable\n    from accumulate.models.transactions import RemoteTransaction  #  Import RemoteTransaction\n\n    #  If this is a RemoteTransaction, set header differently\n    if isinstance(transaction_body, RemoteTransaction):\n        logger.info(\" RemoteTransaction detected! Adjusting header...\")\n\n        #  Use the referenced transaction's hash as the initiator\n        initiator_hash = transaction_body.hash  # This should be the original signed transaction hash\n\n        #  Remote Transactions do not need a new timestamp\n        timestamp = None  \n\n        logger.info(f\" Using referenced transaction hash: {initiator_hash.hex()}\")\n\n    else:\n\n        #  Generate timestamp only if it's not provided\n        timestamp = timestamp or TimestampFromVariable().get()\n\n        #  Fetch signer version dynamically\n        signer_version = await signer.get_signer_version()\n\n        #  Fetch the correct signature type dynamically\n        signature_type = await signer.get_signature_type()\n\n        #  Use the correct Lite Identity URL (not a token sub-account)\n        signer_url = str(signer.url)  #  Extract URL from Signer object\n\n        logger.info(f\" Correcting Signer URL (used in metadata hash): {signer_url}\")\n\n        #  Compute initiator hash using the same function as `Signer.sign_transaction()`\n        initiator_hash = Signer.calculate_metadata_hash(\n            public_key, timestamp, signer_url, signer_version, signature_type.value\n        )\n\n        logger.info(f\" Computed Initiator Hash Header (public key): {public_key.hex()}\")\n        logger.info(f\" Computed Initiator Hash Header (timestamp): {timestamp}\")\n        logger.info(f\" Computed Initiator Hash Header (signer): {principal}\")\n        logger.info(f\" Computed Initiator Hash Header (signer_version): {signer_version}\")\n        logger.info(f\" Computed Initiator Hash Header (signature_type.value): {signature_type.value}\")\n        logger.info(f\" Computed Initiator Hash (from TransactionHeader.create()): {initiator_hash.hex()}\")\n\n    #  Ensure timestamp and signature type are included when creating the instance\n    return cls(\n        principal=principal,\n        initiator=initiator_hash,\n        timestamp=timestamp,  #  This will be None for Remote Transactions\n        signature_type=signature_type if not isinstance(transaction_body, RemoteTransaction) else None,\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionHeader.marshal_binary","title":"<code>marshal_binary()</code>","text":"<p>Serialize the transaction header to bytes using the updated field\u2010based encoding.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def marshal_binary(self) -&gt; bytes:\n    \"\"\"Serialize the transaction header to bytes using the updated field\u2010based encoding.\"\"\"\n    print(\"\\n DEBUG: Marshaling Transaction Header\")\n    result = b\"\"\n\n    # Field 1: Principal \u2013 encode as: [varint(length)] + principal_bytes\n    principal_bytes = self.principal.encode(\"utf-8\")\n    field1 = field_marshal_binary(1, encode_uvarint(len(principal_bytes)) + principal_bytes)\n    result += field1\n    print(f\"   Field 1 (Principal): {field1.hex()}\")\n\n    # Field 2: Initiator \u2013 raw bytes (assumed fixed length, e.g. 32 bytes)\n    field2 = field_marshal_binary(2, self.initiator)\n    result += field2\n    print(f\"   Field 2 (Initiator): {field2.hex()}\")\n\n    # Optional Field 4: Memo (if present)\n    if self.memo:\n        memo_bytes = self.memo.encode(\"utf-8\")\n        field4 = field_marshal_binary(4, encode_uvarint(len(memo_bytes)) + memo_bytes)\n        result += field4\n        print(f\"   Field 4 (Memo): {field4.hex()}\")\n\n    # Optional Field 5: Metadata (if present)\n    if self.metadata:\n        field5 = field_marshal_binary(5, encode_uvarint(len(self.metadata)) + self.metadata)\n        result += field5\n        print(f\"   Field 5 (Metadata): {field5.hex()}\")\n\n    # Optional Field 6: Expire (if present; fixed 8 bytes)\n    if self.expire:\n        expire_bytes = struct.pack(\"&gt;Q\", self.expire.at_time)\n        field6 = field_marshal_binary(6, expire_bytes)\n        result += field6\n        print(f\"   Field 6 (Expire): {field6.hex()}\")\n\n    # Optional Field 7: Hold Until (if present; fixed 8 bytes)\n    if self.hold_until:\n        hold_until_bytes = struct.pack(\"&gt;Q\", self.hold_until.minor_block)\n        field7 = field_marshal_binary(7, hold_until_bytes)\n        result += field7\n        print(f\"   Field 7 (Hold Until): {field7.hex()}\")\n\n    # Optional Field 8: Authorities (if present; encoded as length-prefixed UTF-8 string)\n    if self.authorities:\n        auth_str = \",\".join(self.authorities)\n        auth_bytes = auth_str.encode(\"utf-8\")\n        field8 = field_marshal_binary(8, encode_uvarint(len(auth_bytes)) + auth_bytes)\n        result += field8\n        print(f\"   Field 8 (Authorities): {field8.hex()}\")\n\n    print(f\"   Final Header Encoding: {result.hex()}\")\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionHeader.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the transaction header to a dictionary while conditionally including optional fields.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the transaction header to a dictionary while conditionally including optional fields.\"\"\"\n    txn_dict = {\n        \"principal\": self.principal,\n        \"initiator\": self.initiator.hex(),\n    }\n    if self.memo:\n        txn_dict[\"memo\"] = self.memo\n    if self.metadata:\n        txn_dict[\"metadata\"] = base64.b64encode(self.metadata).decode()\n    if self.expire:\n        txn_dict[\"expire\"] = self.expire.at_time\n    if self.hold_until:\n        txn_dict[\"hold_until\"] = self.hold_until.minor_block\n    if self.authorities:\n        txn_dict[\"authorities\"] = self.authorities\n    return txn_dict\n</code></pre>"},{"location":"api_reference/#accumulate.models.base_transactions.TransactionHeader.unmarshal","title":"<code>unmarshal(data)</code>  <code>staticmethod</code>","text":"<p>Deserialize the transaction header from bytes using the updated encoding scheme.</p> Source code in <code>accumulate\\models\\base_transactions.py</code> <pre><code>@staticmethod\ndef unmarshal(data: bytes) -&gt; \"TransactionHeader\":\n    \"\"\"Deserialize the transaction header from bytes using the updated encoding scheme.\"\"\"\n    print(\"\\n DEBUG: Unmarshaling Transaction Header\")\n    reader = io.BytesIO(data)\n\n    principal = None\n    initiator = None\n    memo = None\n    metadata = None\n    expire = None\n    hold_until = None\n    authorities = None\n\n    # Process fields one by one (each field starts with a 1-byte field id)\n    while True:\n        field_id_byte = reader.read(1)\n        if not field_id_byte:\n            break  # End of header data\n        field_id = field_id_byte[0]\n        if field_id == 1:\n            # Principal is length-prefixed: read length then string\n            plen = read_uvarint(reader)\n            principal = reader.read(plen).decode(\"utf-8\")\n            print(f\"   Unmarshaled Field 1 (Principal): {principal}\")\n        elif field_id == 2:\n            # Initiator: fixed length (assume 32 bytes)\n            initiator = reader.read(32)\n            print(f\"   Unmarshaled Field 2 (Initiator): {initiator.hex()}\")\n        elif field_id == 4:\n            # Memo: length-prefixed string\n            mlen = read_uvarint(reader)\n            memo = reader.read(mlen).decode(\"utf-8\")\n            print(f\"   Unmarshaled Field 4 (Memo): {memo}\")\n        elif field_id == 5:\n            # Metadata: length-prefixed bytes\n            mlen = read_uvarint(reader)\n            metadata = reader.read(mlen)\n            print(f\"   Unmarshaled Field 5 (Metadata): {metadata.hex()}\")\n        elif field_id == 6:\n            # Expire: fixed 8 bytes\n            expire_val = struct.unpack(\"&gt;Q\", reader.read(8))[0]\n            if expire_val &gt; 0:\n                expire = ExpireOptions(expire_val)\n            print(f\"   Unmarshaled Field 6 (Expire): {expire_val}\")\n        elif field_id == 7:\n            # Hold Until: fixed 8 bytes\n            hold_val = struct.unpack(\"&gt;Q\", reader.read(8))[0]\n            if hold_val &gt; 0:\n                hold_until = HoldUntilOptions(hold_val)\n            print(f\"   Unmarshaled Field 7 (Hold Until): {hold_val}\")\n        elif field_id == 8:\n            # Authorities: length-prefixed string (comma-separated)\n            alen = read_uvarint(reader)\n            auth_data = reader.read(alen).decode(\"utf-8\")\n            authorities = auth_data.split(\",\")\n            print(f\"   Unmarshaled Field 8 (Authorities): {authorities}\")\n        else:\n            # Unknown field \u2013 skip (or break)\n            print(f\"   Unknown field id {field_id} encountered. Skipping.\")\n            break\n\n    return TransactionHeader(\n        principal=principal,\n        initiator=initiator,\n        memo=memo,\n        metadata=metadata,\n        expire=expire,\n        hold_until=hold_until,\n        authorities=authorities,\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.credits","title":"<code>credits</code>","text":""},{"location":"api_reference/#accumulate.models.credits.CreditsAccount","title":"<code>CreditsAccount</code>","text":"<p>Represents an account with a credit balance.</p> Source code in <code>accumulate\\models\\credits.py</code> <pre><code>class CreditsAccount:\n    \"\"\"Represents an account with a credit balance.\"\"\"\n\n    def __init__(self, credit_balance: int = 0):\n        \"\"\"\n        Initialize a credits account.\n\n        :param credit_balance: Initial credit balance of the account.\n        \"\"\"\n        self.credit_balance = credit_balance\n\n    def get_credit_balance(self) -&gt; int:\n        \"\"\"\n        Get the current credit balance.\n\n        :return: The credit balance as an integer.\n        \"\"\"\n        return self.credit_balance\n\n    def credit_credits(self, amount: int):\n        \"\"\"\n        Add credits to the account.\n\n        :param amount: The amount of credits to add.\n        \"\"\"\n        self.credit_balance += amount\n\n    def can_debit_credits(self, amount: int) -&gt; bool:\n        \"\"\"\n        Check if the account has enough credits to debit.\n\n        :param amount: The amount to check for debiting.\n        :return: True if the account can debit the amount, False otherwise.\n        \"\"\"\n        return amount &lt;= self.credit_balance\n\n    def debit_credits(self, amount: int) -&gt; bool:\n        \"\"\"\n        Debit credits from the account.\n\n        :param amount: The amount of credits to debit.\n        :return: True if the debit was successful, False otherwise.\n        \"\"\"\n        if not self.can_debit_credits(amount):\n            return False\n        self.credit_balance -= amount\n        return True\n</code></pre>"},{"location":"api_reference/#accumulate.models.credits.CreditsAccount.__init__","title":"<code>__init__(credit_balance=0)</code>","text":"<p>Initialize a credits account.</p> <p>:param credit_balance: Initial credit balance of the account.</p> Source code in <code>accumulate\\models\\credits.py</code> <pre><code>def __init__(self, credit_balance: int = 0):\n    \"\"\"\n    Initialize a credits account.\n\n    :param credit_balance: Initial credit balance of the account.\n    \"\"\"\n    self.credit_balance = credit_balance\n</code></pre>"},{"location":"api_reference/#accumulate.models.credits.CreditsAccount.can_debit_credits","title":"<code>can_debit_credits(amount)</code>","text":"<p>Check if the account has enough credits to debit.</p> <p>:param amount: The amount to check for debiting. :return: True if the account can debit the amount, False otherwise.</p> Source code in <code>accumulate\\models\\credits.py</code> <pre><code>def can_debit_credits(self, amount: int) -&gt; bool:\n    \"\"\"\n    Check if the account has enough credits to debit.\n\n    :param amount: The amount to check for debiting.\n    :return: True if the account can debit the amount, False otherwise.\n    \"\"\"\n    return amount &lt;= self.credit_balance\n</code></pre>"},{"location":"api_reference/#accumulate.models.credits.CreditsAccount.credit_credits","title":"<code>credit_credits(amount)</code>","text":"<p>Add credits to the account.</p> <p>:param amount: The amount of credits to add.</p> Source code in <code>accumulate\\models\\credits.py</code> <pre><code>def credit_credits(self, amount: int):\n    \"\"\"\n    Add credits to the account.\n\n    :param amount: The amount of credits to add.\n    \"\"\"\n    self.credit_balance += amount\n</code></pre>"},{"location":"api_reference/#accumulate.models.credits.CreditsAccount.debit_credits","title":"<code>debit_credits(amount)</code>","text":"<p>Debit credits from the account.</p> <p>:param amount: The amount of credits to debit. :return: True if the debit was successful, False otherwise.</p> Source code in <code>accumulate\\models\\credits.py</code> <pre><code>def debit_credits(self, amount: int) -&gt; bool:\n    \"\"\"\n    Debit credits from the account.\n\n    :param amount: The amount of credits to debit.\n    :return: True if the debit was successful, False otherwise.\n    \"\"\"\n    if not self.can_debit_credits(amount):\n        return False\n    self.credit_balance -= amount\n    return True\n</code></pre>"},{"location":"api_reference/#accumulate.models.credits.CreditsAccount.get_credit_balance","title":"<code>get_credit_balance()</code>","text":"<p>Get the current credit balance.</p> <p>:return: The credit balance as an integer.</p> Source code in <code>accumulate\\models\\credits.py</code> <pre><code>def get_credit_balance(self) -&gt; int:\n    \"\"\"\n    Get the current credit balance.\n\n    :return: The credit balance as an integer.\n    \"\"\"\n    return self.credit_balance\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries","title":"<code>data_entries</code>","text":""},{"location":"api_reference/#accumulate.models.data_entries.AccumulateDataEntry","title":"<code>AccumulateDataEntry</code>","text":"<p>               Bases: <code>DataEntry</code></p> <p>Represents a single-hash data entry.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>class AccumulateDataEntry(DataEntry):\n    \"\"\"Represents a single-hash data entry.\"\"\"\n\n    def type(self) -&gt; DataEntryType:\n        return DataEntryType.ACCUMULATE\n\n    def hash(self) -&gt; bytes:\n        hasher = hashlib.sha256()\n        for chunk in self.data:\n            hasher.update(chunk)\n        return hasher.digest()\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"\n        Serialize the DataEntry to bytes.\n        \"\"\"\n        type_byte = encode_uvarint(2)\n        chunk_count = encode_uvarint(len(self.data))  #  Use uvarint encoding for chunk count\n        serialized_chunks = b\"\".join(bytes_marshal_binary(chunk) for chunk in self.data)\n\n        return type_byte + chunk_count + serialized_chunks\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n         Convert AccumulateDataEntry to a JSON-serializable dictionary.\n        \"\"\"\n        return {\n            \"type\": \"accumulate\",  #  Ensure type matches expected JSON output\n            \"data\": [chunk.hex() for chunk in self.data]  #  Convert bytes to hex\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.AccumulateDataEntry.marshal","title":"<code>marshal()</code>","text":"<p>Serialize the DataEntry to bytes.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"\n    Serialize the DataEntry to bytes.\n    \"\"\"\n    type_byte = encode_uvarint(2)\n    chunk_count = encode_uvarint(len(self.data))  #  Use uvarint encoding for chunk count\n    serialized_chunks = b\"\".join(bytes_marshal_binary(chunk) for chunk in self.data)\n\n    return type_byte + chunk_count + serialized_chunks\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.AccumulateDataEntry.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert AccumulateDataEntry to a JSON-serializable dictionary.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n     Convert AccumulateDataEntry to a JSON-serializable dictionary.\n    \"\"\"\n    return {\n        \"type\": \"accumulate\",  #  Ensure type matches expected JSON output\n        \"data\": [chunk.hex() for chunk in self.data]  #  Convert bytes to hex\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntry","title":"<code>DataEntry</code>","text":"<p>Base class for data entries.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>class DataEntry:\n    \"\"\"Base class for data entries.\"\"\"\n\n    def __init__(self, data: List[bytes]):\n        if not isinstance(data, list) or not all(isinstance(d, bytes) for d in data):\n            raise TypeError(\"Data must be a list of byte arrays.\")\n        self.data = data\n\n    def type(self) -&gt; DataEntryType:\n        \"\"\"Return the data entry type (must be implemented by subclasses).\"\"\"\n        raise NotImplementedError(\"Type method must be implemented by subclasses.\")\n\n    def get_data(self) -&gt; List[bytes]:\n        \"\"\"Return the raw data of the entry.\"\"\"\n        return self.data\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Return the hash of the data entry (must be implemented by subclasses).\"\"\"\n        raise NotImplementedError(\"Hash method must be implemented by subclasses.\")\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"\n        Serialize the DataEntry to bytes.\n         FIX: Ensure the correct entry encoding.\n        \"\"\"\n        type_byte = encode_uvarint(self.type().value)  #  Correctly encode DataEntryType\n        serialized_chunks = b\"\".join(bytes_marshal_binary(chunk) for chunk in self.data)\n\n        return type_byte + serialized_chunks\n\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"DataEntry\":\n        \"\"\"Deserialize a data entry from bytes.\"\"\"\n        logger.debug(f\" Unmarshaling DataEntry\")\n\n        reader = io.BytesIO(data)\n\n        #  Step 1: Read **DataEntryType**\n        type_value = read_uvarint(reader)\n        if type_value not in {DataEntryType.ACCUMULATE.value, DataEntryType.DOUBLE_HASH.value}:\n            raise ValueError(f\"Unknown DataEntryType: {type_value}\")\n\n        #  Step 2: Read **Chunk Count**\n        chunk_count = read_uvarint(reader)\n\n        #  Step 3: Read **Each Data Chunk**\n        chunks = [unmarshal_bytes(reader) for _ in range(chunk_count)]\n\n        #  Step 4: Return the correct DataEntry subclass\n        if type_value == DataEntryType.ACCUMULATE.value:\n            return AccumulateDataEntry(chunks)\n        elif type_value == DataEntryType.DOUBLE_HASH.value:\n            return DoubleHashDataEntry(chunks)\n        else:\n            raise ValueError(f\"Unexpected DataEntryType: {type_value}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntry.get_data","title":"<code>get_data()</code>","text":"<p>Return the raw data of the entry.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def get_data(self) -&gt; List[bytes]:\n    \"\"\"Return the raw data of the entry.\"\"\"\n    return self.data\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntry.hash","title":"<code>hash()</code>","text":"<p>Return the hash of the data entry (must be implemented by subclasses).</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Return the hash of the data entry (must be implemented by subclasses).\"\"\"\n    raise NotImplementedError(\"Hash method must be implemented by subclasses.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntry.marshal","title":"<code>marshal()</code>","text":"<p>Serialize the DataEntry to bytes.  FIX: Ensure the correct entry encoding.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"\n    Serialize the DataEntry to bytes.\n     FIX: Ensure the correct entry encoding.\n    \"\"\"\n    type_byte = encode_uvarint(self.type().value)  #  Correctly encode DataEntryType\n    serialized_chunks = b\"\".join(bytes_marshal_binary(chunk) for chunk in self.data)\n\n    return type_byte + serialized_chunks\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntry.type","title":"<code>type()</code>","text":"<p>Return the data entry type (must be implemented by subclasses).</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def type(self) -&gt; DataEntryType:\n    \"\"\"Return the data entry type (must be implemented by subclasses).\"\"\"\n    raise NotImplementedError(\"Type method must be implemented by subclasses.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntry.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a data entry from bytes.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"DataEntry\":\n    \"\"\"Deserialize a data entry from bytes.\"\"\"\n    logger.debug(f\" Unmarshaling DataEntry\")\n\n    reader = io.BytesIO(data)\n\n    #  Step 1: Read **DataEntryType**\n    type_value = read_uvarint(reader)\n    if type_value not in {DataEntryType.ACCUMULATE.value, DataEntryType.DOUBLE_HASH.value}:\n        raise ValueError(f\"Unknown DataEntryType: {type_value}\")\n\n    #  Step 2: Read **Chunk Count**\n    chunk_count = read_uvarint(reader)\n\n    #  Step 3: Read **Each Data Chunk**\n    chunks = [unmarshal_bytes(reader) for _ in range(chunk_count)]\n\n    #  Step 4: Return the correct DataEntry subclass\n    if type_value == DataEntryType.ACCUMULATE.value:\n        return AccumulateDataEntry(chunks)\n    elif type_value == DataEntryType.DOUBLE_HASH.value:\n        return DoubleHashDataEntry(chunks)\n    else:\n        raise ValueError(f\"Unexpected DataEntryType: {type_value}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntryUtils","title":"<code>DataEntryUtils</code>","text":"<p>Utility functions for data entries.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>class DataEntryUtils:\n    \"\"\"Utility functions for data entries.\"\"\"\n\n    TRANSACTION_SIZE_MAX = 20480  # Maximum transaction size\n    FEE_DATA_UNIT = 256          # Fee unit size\n\n    @staticmethod\n    def check_data_entry_size(entry: DataEntry) -&gt; int:\n        \"\"\"\n        Validate the size of the data entry.\n\n        :param entry: The data entry to check.\n        :return: The size of the marshaled data entry in bytes.\n        :raises ValueError: If the entry is empty or exceeds the size limit.\n        \"\"\"\n        size = sum(len(chunk) for chunk in entry.get_data())\n        if size &gt; DataEntryUtils.TRANSACTION_SIZE_MAX:\n            raise ValueError(f\"Data exceeds {DataEntryUtils.TRANSACTION_SIZE_MAX} byte entry limit.\")\n        if size &lt;= 0:\n            raise ValueError(\"No data provided for WriteData.\")\n        return size\n\n    @staticmethod\n    def calculate_data_entry_cost(entry: DataEntry, fee_data: int) -&gt; int:\n        \"\"\"\n        Calculate the cost of writing a data entry.\n\n        :param entry: The data entry to calculate the cost for.\n        :param fee_data: The base fee multiplier for data entries.\n        :return: The cost in credits.\n        \"\"\"\n        size = DataEntryUtils.check_data_entry_size(entry)\n        return fee_data * ((size // DataEntryUtils.FEE_DATA_UNIT) + 1)\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntryUtils.calculate_data_entry_cost","title":"<code>calculate_data_entry_cost(entry, fee_data)</code>  <code>staticmethod</code>","text":"<p>Calculate the cost of writing a data entry.</p> <p>:param entry: The data entry to calculate the cost for. :param fee_data: The base fee multiplier for data entries. :return: The cost in credits.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>@staticmethod\ndef calculate_data_entry_cost(entry: DataEntry, fee_data: int) -&gt; int:\n    \"\"\"\n    Calculate the cost of writing a data entry.\n\n    :param entry: The data entry to calculate the cost for.\n    :param fee_data: The base fee multiplier for data entries.\n    :return: The cost in credits.\n    \"\"\"\n    size = DataEntryUtils.check_data_entry_size(entry)\n    return fee_data * ((size // DataEntryUtils.FEE_DATA_UNIT) + 1)\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DataEntryUtils.check_data_entry_size","title":"<code>check_data_entry_size(entry)</code>  <code>staticmethod</code>","text":"<p>Validate the size of the data entry.</p> <p>:param entry: The data entry to check. :return: The size of the marshaled data entry in bytes. :raises ValueError: If the entry is empty or exceeds the size limit.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>@staticmethod\ndef check_data_entry_size(entry: DataEntry) -&gt; int:\n    \"\"\"\n    Validate the size of the data entry.\n\n    :param entry: The data entry to check.\n    :return: The size of the marshaled data entry in bytes.\n    :raises ValueError: If the entry is empty or exceeds the size limit.\n    \"\"\"\n    size = sum(len(chunk) for chunk in entry.get_data())\n    if size &gt; DataEntryUtils.TRANSACTION_SIZE_MAX:\n        raise ValueError(f\"Data exceeds {DataEntryUtils.TRANSACTION_SIZE_MAX} byte entry limit.\")\n    if size &lt;= 0:\n        raise ValueError(\"No data provided for WriteData.\")\n    return size\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DoubleHashDataEntry","title":"<code>DoubleHashDataEntry</code>","text":"<p>               Bases: <code>DataEntry</code></p> <p>Represents a double-hash data entry (Used in Go JSON).</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>class DoubleHashDataEntry(DataEntry):\n    \"\"\"Represents a double-hash data entry (Used in Go JSON).\"\"\"\n\n    def type(self) -&gt; DataEntryType:\n        \"\"\"Return the DataEntryType for double-hash entries.\"\"\"\n        return DataEntryType.DOUBLE_HASH\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Compute the double SHA-256 hash (Merkle root of the data).\"\"\"\n        hasher = hashlib.sha256()\n        for chunk in self.data:\n            hasher.update(chunk)\n        merkle_root = hasher.digest()\n        return hashlib.sha256(merkle_root).digest()\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"\n        Serialize the DataEntry to bytes.\n         FIX: Ensure the correct entry encoding.\n        \"\"\"\n        entry_type = encode_uvarint(1)  #  Entry field identifier is always `01`\n        type_value = encode_uvarint(self.type().value)  #  Encode `03` for doubleHash\n        data_field = encode_uvarint(2)  #  Data field identifier is always `02`\n\n        serialized_chunks = b\"\".join(bytes_marshal_binary(chunk) for chunk in self.data)\n\n        return entry_type + type_value + data_field + serialized_chunks  #  Fix order!\n\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n         Convert DoubleHashDataEntry to a JSON-serializable dictionary.\n        \"\"\"\n        return {\n            \"type\": \"doubleHash\",  #  Ensure type matches expected JSON output\n            \"data\": [chunk.hex() for chunk in self.data]  #  Convert bytes to hex\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DoubleHashDataEntry.hash","title":"<code>hash()</code>","text":"<p>Compute the double SHA-256 hash (Merkle root of the data).</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Compute the double SHA-256 hash (Merkle root of the data).\"\"\"\n    hasher = hashlib.sha256()\n    for chunk in self.data:\n        hasher.update(chunk)\n    merkle_root = hasher.digest()\n    return hashlib.sha256(merkle_root).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DoubleHashDataEntry.marshal","title":"<code>marshal()</code>","text":"<p>Serialize the DataEntry to bytes.  FIX: Ensure the correct entry encoding.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"\n    Serialize the DataEntry to bytes.\n     FIX: Ensure the correct entry encoding.\n    \"\"\"\n    entry_type = encode_uvarint(1)  #  Entry field identifier is always `01`\n    type_value = encode_uvarint(self.type().value)  #  Encode `03` for doubleHash\n    data_field = encode_uvarint(2)  #  Data field identifier is always `02`\n\n    serialized_chunks = b\"\".join(bytes_marshal_binary(chunk) for chunk in self.data)\n\n    return entry_type + type_value + data_field + serialized_chunks  #  Fix order!\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DoubleHashDataEntry.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert DoubleHashDataEntry to a JSON-serializable dictionary.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n     Convert DoubleHashDataEntry to a JSON-serializable dictionary.\n    \"\"\"\n    return {\n        \"type\": \"doubleHash\",  #  Ensure type matches expected JSON output\n        \"data\": [chunk.hex() for chunk in self.data]  #  Convert bytes to hex\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.data_entries.DoubleHashDataEntry.type","title":"<code>type()</code>","text":"<p>Return the DataEntryType for double-hash entries.</p> Source code in <code>accumulate\\models\\data_entries.py</code> <pre><code>def type(self) -&gt; DataEntryType:\n    \"\"\"Return the DataEntryType for double-hash entries.\"\"\"\n    return DataEntryType.DOUBLE_HASH\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums","title":"<code>enums</code>","text":""},{"location":"api_reference/#accumulate.models.enums.AccountAuthOperationType","title":"<code>AccountAuthOperationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Operations for account authorization.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class AccountAuthOperationType(Enum):\n    \"\"\"Operations for account authorization.\"\"\"\n    UNKNOWN = 0\n    ENABLE = 1\n    DISABLE = 2\n    ADD_AUTHORITY = 3\n    REMOVE_AUTHORITY = 4\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.AccountType","title":"<code>AccountType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of accounts in the Accumulate blockchain.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class AccountType(Enum):\n    \"\"\"Types of accounts in the Accumulate blockchain.\"\"\"\n    UNKNOWN = 0\n    ANCHOR_LEDGER = 1\n    IDENTITY = 2\n    TOKEN_ISSUER = 3\n    TOKEN_ACCOUNT = 4\n    LITE_TOKEN_ACCOUNT = 5\n    BLOCK_LEDGER = 6\n    KEY_PAGE = 9\n    KEY_BOOK = 10\n    DATA_ACCOUNT = 11\n    LITE_DATA_ACCOUNT = 12\n    SYSTEM_LEDGER = 14\n    LITE_IDENTITY = 15\n    SYNTHETIC_LEDGER = 16\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.BookType","title":"<code>BookType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of key books.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class BookType(Enum):\n    \"\"\"Types of key books.\"\"\"\n    NORMAL = 0\n    VALIDATOR = 1\n    OPERATOR = 2\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.DataEntryType","title":"<code>DataEntryType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of data entries in the blockchain.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class DataEntryType(Enum):\n    \"\"\"Types of data entries in the blockchain.\"\"\"\n    UNKNOWN = 0x00\n    FACTOM = 0x01\n    ACCUMULATE = 0x02\n    DOUBLE_HASH = 0x03\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.EventType","title":"<code>EventType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of blockchain events.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class EventType(Enum):\n    \"\"\"Types of blockchain events.\"\"\"\n    ERROR = 1\n    BLOCK = 2\n    GLOBALS = 3\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.ExecutorVersion","title":"<code>ExecutorVersion</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Versions of the executor system.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class ExecutorVersion(Enum):\n    \"\"\"Versions of the executor system.\"\"\"\n    V1 = 1\n    V1_SIGNATURE_ANCHORING = 2\n    V1_DOUBLE_HASH_ENTRIES = 3\n    V1_HALT = 4\n    V2 = 5\n    V2_BAIKONUR = 6\n    V2_VANDENBERG = 7\n    V2_JIUQUAN = 8\n    V_NEXT = 9\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.KeyPageOperationType","title":"<code>KeyPageOperationType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Operations for key pages.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class KeyPageOperationType(Enum):\n    \"\"\"Operations for key pages.\"\"\"\n    UNKNOWN = 0\n    UPDATE = 1\n    REMOVE = 2\n    ADD = 3\n    SET_THRESHOLD = 15\n    UPDATE_ALLOWED = 5\n    SET_REJECT_THRESHOLD = 6\n    SET_RESPONSE_THRESHOLD = 7\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.KnownPeerStatus","title":"<code>KnownPeerStatus</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Statuses of known peers in the network.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class KnownPeerStatus(Enum):\n    \"\"\"Statuses of known peers in the network.\"\"\"\n    UNKNOWN = 0\n    GOOD = 1\n    BAD = 2\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.QueryType","title":"<code>QueryType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Query types for retrieving blockchain data.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class QueryType(Enum):\n    \"\"\"Query types for retrieving blockchain data.\"\"\"\n    DEFAULT = 0x00\n    CHAIN = 0x01\n    DATA = 0x02\n    DIRECTORY = 0x03\n    PENDING = 0x04\n    BLOCK = 0x05\n    ANCHOR_SEARCH = 0x10\n    PUBLIC_KEY_SEARCH = 0x11\n    PUBLIC_KEY_HASH_SEARCH = 0x12\n    DELEGATE_SEARCH = 0x13\n    MESSAGE_HASH_SEARCH = 0x14\n\n    @classmethod\n    def from_value(cls, value):\n        \"\"\"Retrieve an enum instance by its numeric value.\"\"\"\n        for item in cls:\n            if item.value == value:\n                return item\n        raise ValueError(f\"Invalid QueryType value: {value}\")\n\n    def to_rpc_format(self) -&gt; str:\n        \"\"\"Convert to the expected JSON-RPC queryType format (camelCase).\"\"\"\n        mapping = {\n            \"DEFAULT\": \"default\",\n            \"CHAIN\": \"chain\",\n            \"DATA\": \"data\",\n            \"DIRECTORY\": \"directory\",\n            \"PENDING\": \"pending\",\n            \"BLOCK\": \"block\",\n            \"ANCHOR_SEARCH\": \"anchor\",\n            \"PUBLIC_KEY_SEARCH\": \"publicKeySearch\",\n            \"PUBLIC_KEY_HASH_SEARCH\": \"publicKeyHashSearch\",\n            \"DELEGATE_SEARCH\": \"delegateSearch\",\n            \"MESSAGE_HASH_SEARCH\": \"messageHashSearch\",\n        }\n        return mapping[self.name]\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.QueryType.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Retrieve an enum instance by its numeric value.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>@classmethod\ndef from_value(cls, value):\n    \"\"\"Retrieve an enum instance by its numeric value.\"\"\"\n    for item in cls:\n        if item.value == value:\n            return item\n    raise ValueError(f\"Invalid QueryType value: {value}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.QueryType.to_rpc_format","title":"<code>to_rpc_format()</code>","text":"<p>Convert to the expected JSON-RPC queryType format (camelCase).</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>def to_rpc_format(self) -&gt; str:\n    \"\"\"Convert to the expected JSON-RPC queryType format (camelCase).\"\"\"\n    mapping = {\n        \"DEFAULT\": \"default\",\n        \"CHAIN\": \"chain\",\n        \"DATA\": \"data\",\n        \"DIRECTORY\": \"directory\",\n        \"PENDING\": \"pending\",\n        \"BLOCK\": \"block\",\n        \"ANCHOR_SEARCH\": \"anchor\",\n        \"PUBLIC_KEY_SEARCH\": \"publicKeySearch\",\n        \"PUBLIC_KEY_HASH_SEARCH\": \"publicKeyHashSearch\",\n        \"DELEGATE_SEARCH\": \"delegateSearch\",\n        \"MESSAGE_HASH_SEARCH\": \"messageHashSearch\",\n    }\n    return mapping[self.name]\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.RecordType","title":"<code>RecordType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of records stored in the blockchain.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class RecordType(Enum):\n    \"\"\"Types of records stored in the blockchain.\"\"\"\n    ACCOUNT = 0x01\n    CHAIN = 0x02\n    CHAIN_ENTRY = 0x03\n    KEY = 0x04\n    MESSAGE = 0x10\n    SIGNATURE_SET = 0x11\n    MINOR_BLOCK = 0x20\n    MAJOR_BLOCK = 0x21\n    RANGE = 0x80\n    URL = 0x81\n    TX_ID = 0x82\n    INDEX_ENTRY = 0x83\n    ERROR = 0x8F\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.ServiceType","title":"<code>ServiceType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Types of services available in the Accumulate network, using hexadecimal values.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class ServiceType(Enum):\n    \"\"\"Types of services available in the Accumulate network, using hexadecimal values.\"\"\"\n    UNKNOWN = 0x00  # Indicates an unknown service type\n    NODE = 0x01  # Node service\n    CONSENSUS = 0x02  # Consensus service\n    NETWORK = 0x03  # Network service\n    METRICS = 0x04  # Metrics service\n    QUERY = 0x05  # Querier service\n    EVENT = 0x06  # Event service\n    SUBMIT = 0x07  # Submitter service\n    VALIDATE = 0x08  # Validator service\n    FAUCET = 0x09  # Faucet service\n    SNAPSHOT = 0x0A  # Snapshot service\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.TransactionType","title":"<code>TransactionType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Transaction types supported by the Accumulate blockchain.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class TransactionType(Enum):\n    \"\"\"Transaction types supported by the Accumulate blockchain.\"\"\"\n    # User Transactions\n    UNKNOWN = 0x00\n    CREATE_IDENTITY = 0x01\n    CREATE_TOKEN_ACCOUNT = 0x02\n    SEND_TOKENS = 0x03\n    CREATE_DATA_ACCOUNT = 0x04\n    WRITE_DATA = 0x05\n    WRITE_DATA_TO = 0x06\n    ACME_FAUCET = 0x07\n    CREATE_TOKEN = 0x08\n    ISSUE_TOKENS = 0x09\n    BURN_TOKENS = 0x0A\n    CREATE_LITE_TOKEN_ACCOUNT = 0x0B\n    CREATE_KEY_PAGE = 0x0C\n    CREATE_KEY_BOOK = 0x0D\n    ADD_CREDITS = 0x0E\n    UPDATE_KEY_PAGE = 0x0F\n    LOCK_ACCOUNT = 0x10\n    BURN_CREDITS = 0x11\n    TRANSFER_CREDITS = 0x12\n    UPDATE_ACCOUNT_AUTH = 0x15\n    UPDATE_KEY = 0x16\n    NETWORK_MAINTENANCE = 0x2E\n    ACTIVATE_PROTOCOL_VERSION = 0x2F\n    REMOTE = 0x30\n\n    # Systems Transactions\n    SYNTHETIC_CREATE_IDENTITY = 0x31\n    SYNTHETIC_WRITE_DATA = 0x32\n    SYNTHETIC_DEPOSIT_TOKENS = 0x33\n    SYNTHETIC_DEPOSIT_CREDITS = 0x34\n    SYNTHETIC_BURN_TOKENS = 0x35\n    SYNTHETIC_FORWARD_TRANSACTION = 0x36\n\n    ##### SYSTEM TRANSACTIONS #####\n    SYSTEM_GENESIS = 0x60\n    DIRECTORY_ANCHOR = 0x61\n    BLOCK_VALIDATOR_ANCHOR = 0x62\n    SYSTEM_WRITE_DATA = 0x63\n\n\n    def is_user(self) -&gt; bool:\n        \"\"\"Check if the transaction type is a user transaction.\"\"\"\n        return self.value &lt; 0x31  # Synthetic transactions start at 0x31\n\n    def is_synthetic(self) -&gt; bool:\n        \"\"\"Check if the transaction type is synthetic.\"\"\"\n        return 0x31 &lt;= self.value &lt;= 0x36\n\n    def is_anchor(self) -&gt; bool:\n        \"\"\"Check if the transaction type is an anchor transaction.\"\"\"\n        return self in {TransactionType.DIRECTORY_ANCHOR, TransactionType.BLOCK_VALIDATOR_ANCHOR}\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.TransactionType.is_anchor","title":"<code>is_anchor()</code>","text":"<p>Check if the transaction type is an anchor transaction.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>def is_anchor(self) -&gt; bool:\n    \"\"\"Check if the transaction type is an anchor transaction.\"\"\"\n    return self in {TransactionType.DIRECTORY_ANCHOR, TransactionType.BLOCK_VALIDATOR_ANCHOR}\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.TransactionType.is_synthetic","title":"<code>is_synthetic()</code>","text":"<p>Check if the transaction type is synthetic.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>def is_synthetic(self) -&gt; bool:\n    \"\"\"Check if the transaction type is synthetic.\"\"\"\n    return 0x31 &lt;= self.value &lt;= 0x36\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.TransactionType.is_user","title":"<code>is_user()</code>","text":"<p>Check if the transaction type is a user transaction.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>def is_user(self) -&gt; bool:\n    \"\"\"Check if the transaction type is a user transaction.\"\"\"\n    return self.value &lt; 0x31  # Synthetic transactions start at 0x31\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.VoteType","title":"<code>VoteType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Vote types used in governance.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>class VoteType(Enum):\n    \"\"\"Vote types used in governance.\"\"\"\n    ACCEPT = 0\n    REJECT = 1\n    ABSTAIN = 2\n    SUGGEST = 3\n</code></pre>"},{"location":"api_reference/#accumulate.models.enums.enum_from_name","title":"<code>enum_from_name(enum_cls, name)</code>","text":"<p>Retrieve enum value by name.</p> Source code in <code>accumulate\\models\\enums.py</code> <pre><code>def enum_from_name(enum_cls, name: str):\n    \"\"\"Retrieve enum value by name.\"\"\"\n    try:\n        return enum_cls[name.upper()]\n    except KeyError:\n        raise ValueError(f\"Invalid {enum_cls.__name__}: {name}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors","title":"<code>errors</code>","text":""},{"location":"api_reference/#accumulate.models.errors.AccumulateError","title":"<code>AccumulateError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for Accumulate-related errors.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class AccumulateError(Exception):\n    \"\"\"\n    Base class for Accumulate-related errors.\n    \"\"\"\n    def __init__(self, code: ErrorCode, message: Optional[str] = None):\n        self.code = code\n        self.message = message or code.description\n        super().__init__(f\"[{self.code.name}] {self.message}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.EncodingError","title":"<code>EncodingError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Error raised when encoding or decoding fails.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class EncodingError(AccumulateError):\n    \"\"\"\n    Error raised when encoding or decoding fails.\n    \"\"\"\n    def __init__(self, message: str = ErrorCode.ENCODING_ERROR.description):\n        super().__init__(ErrorCode.ENCODING_ERROR, message)\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.ErrorCode","title":"<code>ErrorCode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of error codes and their descriptions.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class ErrorCode(Enum):\n    \"\"\"\n    Enumeration of error codes and their descriptions.\n    \"\"\"\n    OK = (0, \"Indicates the request succeeded\")\n    ENCODING_ERROR = (1, \"Indicates something could not be decoded or encoded\")\n    FAILED = (2, \"Indicates the request failed\")\n    DID_PANIC = (3, \"Indicates the request failed due to a fatal error\")\n    UNKNOWN_ERROR = (4, \"Indicates the request failed due to an unknown error\")\n\n    def __init__(self, value: int, description: str):\n        self._value_ = value\n        self.description = description\n\n    def success(self) -&gt; bool:\n        \"\"\"\n        Determines if the error code represents a successful state.\n        \"\"\"\n        return self == ErrorCode.OK\n\n    @classmethod\n    def from_value(cls, value: int) -&gt; \"ErrorCode\":\n        \"\"\"\n        Retrieve the error code enum from its integer value.\n\n        :param value: The integer value of the error code.\n        :return: The corresponding ErrorCode enum.\n        :raises ValueError: If the value is not a valid error code.\n        \"\"\"\n        for error in cls:\n            if error.value == value:\n                return error\n        raise ValueError(f\"Unknown ErrorCode value: {value}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.ErrorCode.from_value","title":"<code>from_value(value)</code>  <code>classmethod</code>","text":"<p>Retrieve the error code enum from its integer value.</p> <p>:param value: The integer value of the error code. :return: The corresponding ErrorCode enum. :raises ValueError: If the value is not a valid error code.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>@classmethod\ndef from_value(cls, value: int) -&gt; \"ErrorCode\":\n    \"\"\"\n    Retrieve the error code enum from its integer value.\n\n    :param value: The integer value of the error code.\n    :return: The corresponding ErrorCode enum.\n    :raises ValueError: If the value is not a valid error code.\n    \"\"\"\n    for error in cls:\n        if error.value == value:\n            return error\n    raise ValueError(f\"Unknown ErrorCode value: {value}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.ErrorCode.success","title":"<code>success()</code>","text":"<p>Determines if the error code represents a successful state.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>def success(self) -&gt; bool:\n    \"\"\"\n    Determines if the error code represents a successful state.\n    \"\"\"\n    return self == ErrorCode.OK\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.FailedError","title":"<code>FailedError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Error raised for general failure cases.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class FailedError(AccumulateError):\n    \"\"\"\n    Error raised for general failure cases.\n    \"\"\"\n    def __init__(self, message: str = \"Request failed\"):\n        super().__init__(ErrorCode.FAILED, message)\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.PanicError","title":"<code>PanicError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Error raised for fatal errors.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class PanicError(AccumulateError):\n    \"\"\"\n    Error raised for fatal errors.\n    \"\"\"\n    def __init__(self, message: str = \"A fatal error occurred\"):\n        super().__init__(ErrorCode.DID_PANIC, message)\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.UnknownError","title":"<code>UnknownError</code>","text":"<p>               Bases: <code>AccumulateError</code></p> <p>Error raised for unknown issues.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class UnknownError(AccumulateError):\n    \"\"\"\n    Error raised for unknown issues.\n    \"\"\"\n    def __init__(self, message: str = \"An unknown error occurred\"):\n        super().__init__(ErrorCode.UNKNOWN_ERROR, message)\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when validation fails.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"Raised when validation fails.\"\"\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.errors.raise_for_error_code","title":"<code>raise_for_error_code(code, message=None)</code>","text":"<p>Raise the appropriate exception based on the error code.</p> <p>:param code: The error code as an integer. :param message: An optional message describing the error. :raises AccumulateError: The corresponding exception for the error code.</p> Source code in <code>accumulate\\models\\errors.py</code> <pre><code>def raise_for_error_code(code: int, message: Optional[str] = None):\n    \"\"\"\n    Raise the appropriate exception based on the error code.\n\n    :param code: The error code as an integer.\n    :param message: An optional message describing the error.\n    :raises AccumulateError: The corresponding exception for the error code.\n    \"\"\"\n    error_code = ErrorCode.from_value(code)\n    if error_code == ErrorCode.OK:\n        return  # No error\n\n    error_map = {\n        ErrorCode.ENCODING_ERROR: EncodingError,\n        ErrorCode.FAILED: FailedError,\n        ErrorCode.DID_PANIC: PanicError,\n        ErrorCode.UNKNOWN_ERROR: UnknownError,\n    }\n\n    exception_class = error_map.get(error_code, AccumulateError)\n    raise exception_class(message or error_code.description)\n</code></pre>"},{"location":"api_reference/#accumulate.models.events","title":"<code>events</code>","text":""},{"location":"api_reference/#accumulate.models.events.BlockEvent","title":"<code>BlockEvent</code>","text":"<p>               Bases: <code>Record</code></p> <p>Represents a block event.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>class BlockEvent(Record):\n    \"\"\"Represents a block event.\"\"\"\n\n    def __init__(\n        self,\n        partition: str,\n        index: int,\n        time: datetime,\n        major: int,\n        entries: Optional[List[Dict[str, Any]]] = None,\n    ):\n        super().__init__(record_type=\"BlockEvent\")\n        self.partition = partition\n        self.index = index\n        self.time = time\n        self.major = major\n        self.entries = entries or []\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\n            \"record_type\": self.record_type,\n            \"partition\": self.partition,\n            \"index\": self.index,\n            \"time\": self.time.isoformat(),\n            \"major\": self.major,\n            \"entries\": self.entries,\n        }\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"BlockEvent\":\n        \"\"\"Create a BlockEvent from a dictionary.\"\"\"\n        return BlockEvent(\n            partition=data[\"partition\"],\n            index=data[\"index\"],\n            time=datetime.fromisoformat(data[\"time\"]),\n            major=data[\"major\"],\n            entries=data.get(\"entries\", []),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.BlockEvent.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Create a BlockEvent from a dictionary.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>@staticmethod\ndef from_dict(data: Dict[str, Any]) -&gt; \"BlockEvent\":\n    \"\"\"Create a BlockEvent from a dictionary.\"\"\"\n    return BlockEvent(\n        partition=data[\"partition\"],\n        index=data[\"index\"],\n        time=datetime.fromisoformat(data[\"time\"]),\n        major=data[\"major\"],\n        entries=data.get(\"entries\", []),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.BlockEvent.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    return {\n        \"record_type\": self.record_type,\n        \"partition\": self.partition,\n        \"index\": self.index,\n        \"time\": self.time.isoformat(),\n        \"major\": self.major,\n        \"entries\": self.entries,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.ErrorEvent","title":"<code>ErrorEvent</code>","text":"<p>Represents an error event in the system.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>class ErrorEvent:\n    \"\"\"Represents an error event in the system.\"\"\"\n\n    def __init__(self, err: Optional[Dict[str, Any]] = None):\n        self.err = err\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\"err\": self.err}\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"ErrorEvent\":\n        \"\"\"Create an ErrorEvent from a dictionary.\"\"\"\n        return ErrorEvent(err=data.get(\"err\"))\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.ErrorEvent.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Create an ErrorEvent from a dictionary.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>@staticmethod\ndef from_dict(data: Dict[str, Any]) -&gt; \"ErrorEvent\":\n    \"\"\"Create an ErrorEvent from a dictionary.\"\"\"\n    return ErrorEvent(err=data.get(\"err\"))\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.ErrorEvent.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    return {\"err\": self.err}\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.GlobalsEvent","title":"<code>GlobalsEvent</code>","text":"<p>Represents a global values change event.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>class GlobalsEvent:\n    \"\"\"Represents a global values change event.\"\"\"\n\n    def __init__(self, old: Optional[Dict[str, Any]] = None, new: Optional[Dict[str, Any]] = None):\n        self.old = old\n        self.new = new\n\n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"Convert to dictionary.\"\"\"\n        return {\"old\": self.old, \"new\": self.new}\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"GlobalsEvent\":\n        \"\"\"Create a GlobalsEvent from a dictionary.\"\"\"\n        return GlobalsEvent(\n            old=data.get(\"old\"),\n            new=data.get(\"new\"),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.GlobalsEvent.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Create a GlobalsEvent from a dictionary.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>@staticmethod\ndef from_dict(data: Dict[str, Any]) -&gt; \"GlobalsEvent\":\n    \"\"\"Create a GlobalsEvent from a dictionary.\"\"\"\n    return GlobalsEvent(\n        old=data.get(\"old\"),\n        new=data.get(\"new\"),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.events.GlobalsEvent.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert to dictionary.</p> Source code in <code>accumulate\\models\\events.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"Convert to dictionary.\"\"\"\n    return {\"old\": self.old, \"new\": self.new}\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet","title":"<code>faucet</code>","text":""},{"location":"api_reference/#accumulate.models.faucet.Faucet","title":"<code>Faucet</code>","text":"<p>Represents the Accumulate faucet account.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>class Faucet:\n    \"\"\"Represents the Accumulate faucet account.\"\"\"\n\n    ACME_FAUCET_AMOUNT = 10\n    ACME_FAUCET_BALANCE = 200_000_000\n\n    # Generate the faucet key using a fixed seed\n    FAUCET_SEED = hashlib.sha256(b\"faucet\").digest()\n    FAUCET_KEY = Ed25519PrivateKey.from_private_bytes(FAUCET_SEED[:32])\n\n    def __init__(self):\n        \"\"\"Initialize the Faucet.\"\"\"\n        self.faucet_url = self._generate_faucet_url()\n\n    def _generate_faucet_url(self) -&gt; str:\n        \"\"\"\n        Generate the faucet URL using the public key.\n\n        :return: A string representing the faucet URL.\n        \"\"\"\n        public_key = self.public_key()\n        return f\"{LiteAuthorityForKey(public_key, SignatureType.ED25519)}/ACME\"\n\n    def public_key(self) -&gt; bytes:\n        \"\"\"\n        Get the public key of the faucet.\n\n        :return: The public key as bytes.\n        \"\"\"\n        return self.FAUCET_KEY.public_key().public_bytes(\n            encoding=Encoding.PEM,  # Use PEM for portability\n            format=PublicFormat.SubjectPublicKeyInfo  # Standard format for public keys\n        )\n\n    def signer(self) -&gt; \"FaucetSigner\":\n        \"\"\"\n        Create a new faucet signer with the current timestamp.\n\n        :return: A FaucetSigner instance.\n        \"\"\"\n        return FaucetSigner(int(datetime.now(timezone.utc).timestamp() * 1e9))\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.Faucet.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the Faucet.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the Faucet.\"\"\"\n    self.faucet_url = self._generate_faucet_url()\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.Faucet._generate_faucet_url","title":"<code>_generate_faucet_url()</code>","text":"<p>Generate the faucet URL using the public key.</p> <p>:return: A string representing the faucet URL.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def _generate_faucet_url(self) -&gt; str:\n    \"\"\"\n    Generate the faucet URL using the public key.\n\n    :return: A string representing the faucet URL.\n    \"\"\"\n    public_key = self.public_key()\n    return f\"{LiteAuthorityForKey(public_key, SignatureType.ED25519)}/ACME\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.Faucet.public_key","title":"<code>public_key()</code>","text":"<p>Get the public key of the faucet.</p> <p>:return: The public key as bytes.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def public_key(self) -&gt; bytes:\n    \"\"\"\n    Get the public key of the faucet.\n\n    :return: The public key as bytes.\n    \"\"\"\n    return self.FAUCET_KEY.public_key().public_bytes(\n        encoding=Encoding.PEM,  # Use PEM for portability\n        format=PublicFormat.SubjectPublicKeyInfo  # Standard format for public keys\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.Faucet.signer","title":"<code>signer()</code>","text":"<p>Create a new faucet signer with the current timestamp.</p> <p>:return: A FaucetSigner instance.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def signer(self) -&gt; \"FaucetSigner\":\n    \"\"\"\n    Create a new faucet signer with the current timestamp.\n\n    :return: A FaucetSigner instance.\n    \"\"\"\n    return FaucetSigner(int(datetime.now(timezone.utc).timestamp() * 1e9))\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.FaucetSigner","title":"<code>FaucetSigner</code>","text":"<p>Handles signing for the faucet.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>class FaucetSigner:\n    \"\"\"Handles signing for the faucet.\"\"\"\n\n    def __init__(self, timestamp: int):\n        \"\"\"\n        Initialize the FaucetSigner.\n\n        :param timestamp: The timestamp to use for signing.\n        \"\"\"\n        self.timestamp = timestamp\n\n    def version(self) -&gt; int:\n        \"\"\"\n        Get the version of the signer.\n\n        :return: Version as an integer.\n        \"\"\"\n        return 1\n\n    def set_public_key(self, sig: Signature) -&gt; None:\n        \"\"\"\n        Set the public key for a given signature.\n\n        :param sig: The signature object to update.\n        :raises ValueError: If the signature type is unsupported.\n        \"\"\"\n        if isinstance(sig, (LegacyED25519Signature, ED25519Signature, RCD1Signature)):\n            sig.public_key = Faucet.FAUCET_KEY.public_key().public_bytes(\n                encoding=Encoding.PEM,\n                format=PublicFormat.SubjectPublicKeyInfo\n            )\n        else:\n            raise ValueError(f\"Cannot set the public key on {type(sig).__name__}\")\n\n    def sign(self, sig: Signature, sig_md_hash: bytes, message: bytes) -&gt; None:\n        \"\"\"\n        Sign the message with the faucet key.\n\n        :param sig: The signature object to update.\n        :param sig_md_hash: The metadata hash for the signature.\n        :param message: The message to sign.\n        :raises ValueError: If the signature type is unsupported.\n        \"\"\"\n        if isinstance(sig, (LegacyED25519Signature, ED25519Signature, RCD1Signature)):\n            signature = Faucet.FAUCET_KEY.sign(message)\n            sig.signature = signature\n        else:\n            raise ValueError(f\"Cannot sign {type(sig).__name__} with a key.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.FaucetSigner.__init__","title":"<code>__init__(timestamp)</code>","text":"<p>Initialize the FaucetSigner.</p> <p>:param timestamp: The timestamp to use for signing.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def __init__(self, timestamp: int):\n    \"\"\"\n    Initialize the FaucetSigner.\n\n    :param timestamp: The timestamp to use for signing.\n    \"\"\"\n    self.timestamp = timestamp\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.FaucetSigner.set_public_key","title":"<code>set_public_key(sig)</code>","text":"<p>Set the public key for a given signature.</p> <p>:param sig: The signature object to update. :raises ValueError: If the signature type is unsupported.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def set_public_key(self, sig: Signature) -&gt; None:\n    \"\"\"\n    Set the public key for a given signature.\n\n    :param sig: The signature object to update.\n    :raises ValueError: If the signature type is unsupported.\n    \"\"\"\n    if isinstance(sig, (LegacyED25519Signature, ED25519Signature, RCD1Signature)):\n        sig.public_key = Faucet.FAUCET_KEY.public_key().public_bytes(\n            encoding=Encoding.PEM,\n            format=PublicFormat.SubjectPublicKeyInfo\n        )\n    else:\n        raise ValueError(f\"Cannot set the public key on {type(sig).__name__}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.FaucetSigner.sign","title":"<code>sign(sig, sig_md_hash, message)</code>","text":"<p>Sign the message with the faucet key.</p> <p>:param sig: The signature object to update. :param sig_md_hash: The metadata hash for the signature. :param message: The message to sign. :raises ValueError: If the signature type is unsupported.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def sign(self, sig: Signature, sig_md_hash: bytes, message: bytes) -&gt; None:\n    \"\"\"\n    Sign the message with the faucet key.\n\n    :param sig: The signature object to update.\n    :param sig_md_hash: The metadata hash for the signature.\n    :param message: The message to sign.\n    :raises ValueError: If the signature type is unsupported.\n    \"\"\"\n    if isinstance(sig, (LegacyED25519Signature, ED25519Signature, RCD1Signature)):\n        signature = Faucet.FAUCET_KEY.sign(message)\n        sig.signature = signature\n    else:\n        raise ValueError(f\"Cannot sign {type(sig).__name__} with a key.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.faucet.FaucetSigner.version","title":"<code>version()</code>","text":"<p>Get the version of the signer.</p> <p>:return: Version as an integer.</p> Source code in <code>accumulate\\models\\faucet.py</code> <pre><code>def version(self) -&gt; int:\n    \"\"\"\n    Get the version of the signer.\n\n    :return: Version as an integer.\n    \"\"\"\n    return 1\n</code></pre>"},{"location":"api_reference/#accumulate.models.fee_schedule","title":"<code>fee_schedule</code>","text":""},{"location":"api_reference/#accumulate.models.fee_schedule.Fee","title":"<code>Fee</code>","text":"<p>Enumeration of transaction fees in credits.</p> Source code in <code>accumulate\\models\\fee_schedule.py</code> <pre><code>class Fee:\n    \"\"\"Enumeration of transaction fees in credits.\"\"\"\n    FEE_FAILED_MAXIMUM = 100  # $0.01\n    FEE_SIGNATURE = 1         # $0.0001\n    FEE_CREATE_IDENTITY = 50000  # $5.00\n    FEE_CREATE_DIRECTORY = 1000  # $0.10\n    FEE_CREATE_ACCOUNT = 2500    # $0.25\n    FEE_TRANSFER_TOKENS = 300    # $0.03\n    FEE_TRANSFER_TOKENS_EXTRA = 100  # $0.01\n    FEE_CREATE_TOKEN = 500000    # $50.00\n    FEE_GENERAL_TINY = 1         # $0.001\n    FEE_GENERAL_SMALL = 10       # $0.001\n    FEE_CREATE_KEY_PAGE = 10000  # $1.00\n    FEE_CREATE_KEY_PAGE_EXTRA = 100  # $0.01\n    FEE_DATA = 10                # $0.001 / 256 bytes\n    FEE_SCRATCH_DATA = 1         # $0.0001 / 256 bytes\n    FEE_UPDATE_AUTH = 300        # $0.03\n    FEE_UPDATE_AUTH_EXTRA = 100  # $0.01\n    FEE_MINIMUM_CREDIT_PURCHASE = 100  # $0.01\n</code></pre>"},{"location":"api_reference/#accumulate.models.fee_schedule.FeeSchedule","title":"<code>FeeSchedule</code>","text":"Source code in <code>accumulate\\models\\fee_schedule.py</code> <pre><code>class FeeSchedule:\n    @staticmethod\n    def compute_signature_fee(sig: Signature, signature_size_max: int = 1024) -&gt; int:\n        logger.debug(f\"Starting compute_signature_fee with signature: {sig}\")\n        size = len(sig.serialize())\n        logger.debug(f\"Initial signature size: {size}\")\n        if size &gt; signature_size_max:\n            raise ValueError(f\"Signature size exceeds {signature_size_max} bytes.\")\n\n        fee = Fee.FEE_SIGNATURE\n        chunks = max(1, (size - 1) // 256 + 1)\n        fee += Fee.FEE_SIGNATURE * (chunks - 1)\n        logger.debug(f\"Fee after chunk calculation for main signature: {fee} (chunks: {chunks})\")\n\n        visited_signatures = set()  # Avoid repeated processing\n        while sig and hasattr(sig, \"delegated_signature\"):\n            if sig in visited_signatures:\n                raise RuntimeError(\"Circular delegation detected.\")\n            visited_signatures.add(sig)\n\n            sig = sig.delegated_signature\n            if sig is None:  # Break if no further delegation\n                break\n\n            size = len(sig.serialize())\n            logger.debug(f\"Delegated signature size: {size}\")\n\n            chunks = max(1, (size - 1) // 256 + 1)\n            fee += Fee.FEE_SIGNATURE * chunks\n            logger.debug(f\"Updated fee after processing delegated signature: {fee}\")\n\n        logger.debug(f\"Final computed fee: {fee}\")\n        return fee\n\n\n\n    @staticmethod\n    def compute_transaction_fee(tx: Transaction, transaction_size_max: int = 20480) -&gt; int:\n        \"\"\"\n        Compute the fee for a given transaction.\n\n        :param tx: The transaction object.\n        :param transaction_size_max: Maximum allowed size for a transaction.\n        :return: The calculated fee in credits.\n        \"\"\"\n        size = len(tx.serialize())\n        if size &gt; transaction_size_max:\n            raise ValueError(f\"Transaction size exceeds {transaction_size_max} bytes.\")\n\n        fee = 0\n        count = max(1, (size - 1) // 256 + 1)\n\n        tx_type = tx.body.type()\n        if tx_type == \"CreateToken\":\n            fee = Fee.FEE_CREATE_TOKEN + Fee.FEE_DATA * (count - 1)\n        elif tx_type == \"CreateIdentity\":\n            fee = Fee.FEE_CREATE_IDENTITY + Fee.FEE_DATA * (count - 1)\n        elif tx_type in {\"CreateTokenAccount\", \"CreateDataAccount\"}:\n            fee = Fee.FEE_CREATE_ACCOUNT + Fee.FEE_DATA * (count - 1)\n        elif tx_type == \"SendTokens\":\n            fee = (\n                Fee.FEE_TRANSFER_TOKENS\n                + Fee.FEE_TRANSFER_TOKENS_EXTRA * (len(tx.body.to) - 1)\n                + Fee.FEE_DATA * (count - 1)\n            )\n        elif tx_type == \"CreateKeyPage\":\n            fee = (\n                Fee.FEE_CREATE_KEY_PAGE\n                + Fee.FEE_CREATE_KEY_PAGE_EXTRA * (len(tx.body.keys) - 1)\n                + Fee.FEE_DATA * (count - 1)\n            )\n        else:\n            fee = Fee.FEE_GENERAL_SMALL + Fee.FEE_DATA * (count - 1)\n\n        return fee\n\n    @staticmethod\n    def compute_synthetic_refund(tx: Transaction, synth_count: int) -&gt; int:\n        paid = FeeSchedule.compute_transaction_fee(tx)\n        if paid &lt;= Fee.FEE_FAILED_MAXIMUM:\n            return 0\n\n        tx_type = tx.body.type()\n        if tx_type in {\"SendTokens\", \"IssueTokens\"}:\n            if synth_count &gt; 1:  # Ensure this condition is correctly evaluated\n                raise ValueError(f\"A {tx_type} transaction cannot have multiple outputs.\")\n            return Fee.FEE_TRANSFER_TOKENS_EXTRA\n\n        return paid - Fee.FEE_FAILED_MAXIMUM\n</code></pre>"},{"location":"api_reference/#accumulate.models.fee_schedule.FeeSchedule.compute_transaction_fee","title":"<code>compute_transaction_fee(tx, transaction_size_max=20480)</code>  <code>staticmethod</code>","text":"<p>Compute the fee for a given transaction.</p> <p>:param tx: The transaction object. :param transaction_size_max: Maximum allowed size for a transaction. :return: The calculated fee in credits.</p> Source code in <code>accumulate\\models\\fee_schedule.py</code> <pre><code>@staticmethod\ndef compute_transaction_fee(tx: Transaction, transaction_size_max: int = 20480) -&gt; int:\n    \"\"\"\n    Compute the fee for a given transaction.\n\n    :param tx: The transaction object.\n    :param transaction_size_max: Maximum allowed size for a transaction.\n    :return: The calculated fee in credits.\n    \"\"\"\n    size = len(tx.serialize())\n    if size &gt; transaction_size_max:\n        raise ValueError(f\"Transaction size exceeds {transaction_size_max} bytes.\")\n\n    fee = 0\n    count = max(1, (size - 1) // 256 + 1)\n\n    tx_type = tx.body.type()\n    if tx_type == \"CreateToken\":\n        fee = Fee.FEE_CREATE_TOKEN + Fee.FEE_DATA * (count - 1)\n    elif tx_type == \"CreateIdentity\":\n        fee = Fee.FEE_CREATE_IDENTITY + Fee.FEE_DATA * (count - 1)\n    elif tx_type in {\"CreateTokenAccount\", \"CreateDataAccount\"}:\n        fee = Fee.FEE_CREATE_ACCOUNT + Fee.FEE_DATA * (count - 1)\n    elif tx_type == \"SendTokens\":\n        fee = (\n            Fee.FEE_TRANSFER_TOKENS\n            + Fee.FEE_TRANSFER_TOKENS_EXTRA * (len(tx.body.to) - 1)\n            + Fee.FEE_DATA * (count - 1)\n        )\n    elif tx_type == \"CreateKeyPage\":\n        fee = (\n            Fee.FEE_CREATE_KEY_PAGE\n            + Fee.FEE_CREATE_KEY_PAGE_EXTRA * (len(tx.body.keys) - 1)\n            + Fee.FEE_DATA * (count - 1)\n        )\n    else:\n        fee = Fee.FEE_GENERAL_SMALL + Fee.FEE_DATA * (count - 1)\n\n    return fee\n</code></pre>"},{"location":"api_reference/#accumulate.models.general","title":"<code>general</code>","text":""},{"location":"api_reference/#accumulate.models.general.AccountAuth","title":"<code>AccountAuth</code>  <code>dataclass</code>","text":"<p>Represents account authorization details.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass AccountAuth:\n    \"\"\"Represents account authorization details.\"\"\"\n    authorities: List[\"AuthorityEntry\"] = field(default_factory=list)\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.AnchorMetadata","title":"<code>AnchorMetadata</code>  <code>dataclass</code>","text":"<p>Metadata for an anchor.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass AnchorMetadata:\n    \"\"\"Metadata for an anchor.\"\"\"\n    account: Optional[URL]\n    index: int\n    source_index: int\n    source_block: int\n    entry: bytes\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.AuthorityEntry","title":"<code>AuthorityEntry</code>  <code>dataclass</code>","text":"<p>Represents an entry in the account's authorization list.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass AuthorityEntry:\n    \"\"\"Represents an entry in the account's authorization list.\"\"\"\n    url: Optional[URL]\n    disabled: bool  # True if auth checks are disabled for this authority\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.BlockEntry","title":"<code>BlockEntry</code>  <code>dataclass</code>","text":"<p>Represents a single entry in a block.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass BlockEntry:\n    \"\"\"Represents a single entry in a block.\"\"\"\n    account: Optional[URL]\n    chain: str\n    index: int\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.CreditRecipient","title":"<code>CreditRecipient</code>  <code>dataclass</code>","text":"Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass CreditRecipient:\n    url: Optional[URL]\n    amount: int\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert TokenRecipient to dictionary format for JSON serialization.\"\"\"\n        return {\n            \"url\": str(self.url),\n            \"amount\": str(self.amount),  # Convert to string to match Accumulate JSON format\n        }\n\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"Serialize CreditRecipient to bytes.\"\"\"\n        url_data = string_marshal_binary(str(self.url))\n        amount_data = encode_uvarint(self.amount)\n        return url_data + amount_data\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"CreditRecipient\":\n        \"\"\"Deserialize bytes into CreditRecipient.\"\"\"\n        reader = io.BytesIO(data)\n\n        # Read the URL\n        url_length, _ = decode_uvarint(reader.read(2))\n        url_str = reader.read(url_length).decode(\"utf-8\")\n        url = URL.parse(url_str)\n\n        # Read the amount\n        amount, _ = decode_uvarint(reader.read())\n\n        return cls(url, amount)\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.CreditRecipient.marshal","title":"<code>marshal()</code>","text":"<p>Serialize CreditRecipient to bytes.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"Serialize CreditRecipient to bytes.\"\"\"\n    url_data = string_marshal_binary(str(self.url))\n    amount_data = encode_uvarint(self.amount)\n    return url_data + amount_data\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.CreditRecipient.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert TokenRecipient to dictionary format for JSON serialization.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert TokenRecipient to dictionary format for JSON serialization.\"\"\"\n    return {\n        \"url\": str(self.url),\n        \"amount\": str(self.amount),  # Convert to string to match Accumulate JSON format\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.CreditRecipient.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize bytes into CreditRecipient.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"CreditRecipient\":\n    \"\"\"Deserialize bytes into CreditRecipient.\"\"\"\n    reader = io.BytesIO(data)\n\n    # Read the URL\n    url_length, _ = decode_uvarint(reader.read(2))\n    url_str = reader.read(url_length).decode(\"utf-8\")\n    url = URL.parse(url_str)\n\n    # Read the amount\n    amount, _ = decode_uvarint(reader.read())\n\n    return cls(url, amount)\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.FeeSchedule","title":"<code>FeeSchedule</code>  <code>dataclass</code>","text":"<p>Represents a fee schedule for the network.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass FeeSchedule:\n    \"\"\"Represents a fee schedule for the network.\"\"\"\n    create_identity_sliding: List[int]\n    create_sub_identity: int\n    bare_identity_discount: int\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.IndexEntry","title":"<code>IndexEntry</code>  <code>dataclass</code>","text":"<p>Represents an index entry in a chain.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass IndexEntry:\n    \"\"\"Represents an index entry in a chain.\"\"\"\n    source: int\n    anchor: Optional[int] = None\n    block_index: Optional[int] = None\n    block_time: Optional[int] = None  # Unix timestamp\n    root_index_index: Optional[int] = None\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.NetworkGlobals","title":"<code>NetworkGlobals</code>  <code>dataclass</code>","text":"<p>Represents network-level global configurations.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass NetworkGlobals:\n    \"\"\"Represents network-level global configurations.\"\"\"\n    operator_accept_threshold: float\n    validator_accept_threshold: float\n    major_block_schedule: str\n    anchor_empty_blocks: bool\n    fee_schedule: Optional[\"FeeSchedule\"]\n    limits: Optional[\"NetworkLimits\"]\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.NetworkLimits","title":"<code>NetworkLimits</code>  <code>dataclass</code>","text":"<p>Represents network protocol limits.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass NetworkLimits:\n    \"\"\"Represents network protocol limits.\"\"\"\n    data_entry_parts: int\n    account_authorities: int\n    book_pages: int\n    page_entries: int\n    identity_accounts: int\n    pending_major_blocks: int\n    events_per_block: int\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.Object","title":"<code>Object</code>  <code>dataclass</code>","text":"<p>Generic object with chains and pending transactions.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass Object:\n    \"\"\"Generic object with chains and pending transactions.\"\"\"\n    type: str  # Enum for ObjectType\n    chains: List[\"ChainMetadata\"] = field(default_factory=list)\n    pending: Optional[List[\"TxIdSet\"]] = None  # Pending transactions\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.TokenRecipient","title":"<code>TokenRecipient</code>  <code>dataclass</code>","text":"Source code in <code>accumulate\\models\\general.py</code> <pre><code>@dataclass\nclass TokenRecipient:\n    url: URL\n    amount: int\n\n    def __post_init__(self):\n        if not self.url:\n            raise ValueError(\"URL cannot be None.\")\n        if self.amount &lt; 0:\n            raise ValueError(\"Amount must be a non-negative integer.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert TokenRecipient to dictionary format for JSON serialization.\"\"\"\n        return {\n            \"url\": str(self.url),  \n            \"amount\": str(self.amount),  \n        }\n\n    def __repr__(self) -&gt; str:\n        return f\"TokenRecipient(url={self.url}, amount={self.amount})\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.general.TokenRecipient.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert TokenRecipient to dictionary format for JSON serialization.</p> Source code in <code>accumulate\\models\\general.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert TokenRecipient to dictionary format for JSON serialization.\"\"\"\n    return {\n        \"url\": str(self.url),  \n        \"amount\": str(self.amount),  \n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management","title":"<code>key_management</code>","text":""},{"location":"api_reference/#accumulate.models.key_management.AddKeyOperation","title":"<code>AddKeyOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to add a key to a key page.</p> <p>:param entry: The key specification to add.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass AddKeyOperation:\n    \"\"\"\n    Represents an operation to add a key to a key page.\n\n    :param entry: The key specification to add.\n    \"\"\"\n    entry: KeySpec\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeyPage","title":"<code>KeyPage</code>  <code>dataclass</code>","text":"<p>Represents a page of keys with threshold signature requirements.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass KeyPage:\n    \"\"\"Represents a page of keys with threshold signature requirements.\"\"\"\n    accept_threshold: int\n    keys: List[KeySpec] = field(default_factory=list)\n\n    def get_m_of_n(self) -&gt; Tuple[int, int]:\n        \"\"\"\n        Retrieve the signature requirements for the key page.\n\n        :return: A tuple (m, n) where m is the threshold and n is the total number of keys.\n        \"\"\"\n        return self.accept_threshold, len(self.keys)\n\n    def set_threshold(self, m: int) -&gt; None:\n        \"\"\"\n        Set the signature threshold for the key page.\n\n        :param m: The required number of signatures.\n        :raises ValueError: If the threshold is invalid.\n        \"\"\"\n        if m &lt;= 0:\n            raise ValueError(\"Threshold must be greater than 0.\")\n        if m &gt; len(self.keys):\n            raise ValueError(\n                f\"Cannot require {m} signatures with only {len(self.keys)} keys available.\"\n            )\n        self.accept_threshold = m\n\n    def entry_by_key_hash(self, key_hash: bytes) -&gt; Tuple[int, Optional[KeySpec], bool]:\n        \"\"\"\n        Find a key entry by its hash.\n\n        :param key_hash: The hash of the key to search for.\n        :return: A tuple (index, key_spec, found) where index is the position, key_spec is the found key, and found is a boolean.\n        \"\"\"\n        for i, key_spec in enumerate(self.keys):\n            if key_spec.public_key_hash == key_hash:\n                return i, key_spec, True\n        return -1, None, False\n\n    def add_key_spec(self, key_spec: KeySpec) -&gt; None:\n        \"\"\"\n        Add a key specification to the key page.\n\n        :param key_spec: The key specification to add.\n        \"\"\"\n        self.keys.append(key_spec)\n        self.keys.sort(\n            key=lambda ks: (ks.public_key_hash, ks.delegate or \"\")\n        )\n\n    def remove_key_spec_at(self, index: int) -&gt; None:\n        \"\"\"\n        Remove a key specification at a specific index.\n\n        :param index: The index of the key to remove.\n        :raises IndexError: If the index is out of range.\n        \"\"\"\n        if not (0 &lt;= index &lt; len(self.keys)):\n            raise IndexError(\"Key index out of range\")\n        self.keys.pop(index)\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeyPage.add_key_spec","title":"<code>add_key_spec(key_spec)</code>","text":"<p>Add a key specification to the key page.</p> <p>:param key_spec: The key specification to add.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def add_key_spec(self, key_spec: KeySpec) -&gt; None:\n    \"\"\"\n    Add a key specification to the key page.\n\n    :param key_spec: The key specification to add.\n    \"\"\"\n    self.keys.append(key_spec)\n    self.keys.sort(\n        key=lambda ks: (ks.public_key_hash, ks.delegate or \"\")\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeyPage.entry_by_key_hash","title":"<code>entry_by_key_hash(key_hash)</code>","text":"<p>Find a key entry by its hash.</p> <p>:param key_hash: The hash of the key to search for. :return: A tuple (index, key_spec, found) where index is the position, key_spec is the found key, and found is a boolean.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def entry_by_key_hash(self, key_hash: bytes) -&gt; Tuple[int, Optional[KeySpec], bool]:\n    \"\"\"\n    Find a key entry by its hash.\n\n    :param key_hash: The hash of the key to search for.\n    :return: A tuple (index, key_spec, found) where index is the position, key_spec is the found key, and found is a boolean.\n    \"\"\"\n    for i, key_spec in enumerate(self.keys):\n        if key_spec.public_key_hash == key_hash:\n            return i, key_spec, True\n    return -1, None, False\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeyPage.get_m_of_n","title":"<code>get_m_of_n()</code>","text":"<p>Retrieve the signature requirements for the key page.</p> <p>:return: A tuple (m, n) where m is the threshold and n is the total number of keys.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def get_m_of_n(self) -&gt; Tuple[int, int]:\n    \"\"\"\n    Retrieve the signature requirements for the key page.\n\n    :return: A tuple (m, n) where m is the threshold and n is the total number of keys.\n    \"\"\"\n    return self.accept_threshold, len(self.keys)\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeyPage.remove_key_spec_at","title":"<code>remove_key_spec_at(index)</code>","text":"<p>Remove a key specification at a specific index.</p> <p>:param index: The index of the key to remove. :raises IndexError: If the index is out of range.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def remove_key_spec_at(self, index: int) -&gt; None:\n    \"\"\"\n    Remove a key specification at a specific index.\n\n    :param index: The index of the key to remove.\n    :raises IndexError: If the index is out of range.\n    \"\"\"\n    if not (0 &lt;= index &lt; len(self.keys)):\n        raise IndexError(\"Key index out of range\")\n    self.keys.pop(index)\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeyPage.set_threshold","title":"<code>set_threshold(m)</code>","text":"<p>Set the signature threshold for the key page.</p> <p>:param m: The required number of signatures. :raises ValueError: If the threshold is invalid.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def set_threshold(self, m: int) -&gt; None:\n    \"\"\"\n    Set the signature threshold for the key page.\n\n    :param m: The required number of signatures.\n    :raises ValueError: If the threshold is invalid.\n    \"\"\"\n    if m &lt;= 0:\n        raise ValueError(\"Threshold must be greater than 0.\")\n    if m &gt; len(self.keys):\n        raise ValueError(\n            f\"Cannot require {m} signatures with only {len(self.keys)} keys available.\"\n        )\n    self.accept_threshold = m\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeySpec","title":"<code>KeySpec</code>  <code>dataclass</code>","text":"<p>Represents a key specification with metadata.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass KeySpec:\n    \"\"\"Represents a key specification with metadata.\"\"\"\n    public_key_hash: bytes\n    delegate: Optional[str] = None\n    last_used_on: int = 0\n\n    def get_last_used_on(self) -&gt; int:\n        \"\"\"Retrieve the timestamp of the last key usage.\"\"\"\n        return self.last_used_on\n\n    def set_last_used_on(self, timestamp: int) -&gt; None:\n        \"\"\"Set the timestamp of the last key usage.\"\"\"\n        self.last_used_on = timestamp\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeySpec.get_last_used_on","title":"<code>get_last_used_on()</code>","text":"<p>Retrieve the timestamp of the last key usage.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def get_last_used_on(self) -&gt; int:\n    \"\"\"Retrieve the timestamp of the last key usage.\"\"\"\n    return self.last_used_on\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeySpec.set_last_used_on","title":"<code>set_last_used_on(timestamp)</code>","text":"<p>Set the timestamp of the last key usage.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def set_last_used_on(self, timestamp: int) -&gt; None:\n    \"\"\"Set the timestamp of the last key usage.\"\"\"\n    self.last_used_on = timestamp\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeySpecParams","title":"<code>KeySpecParams</code>  <code>dataclass</code>","text":"<p>Represents the parameters for a key specification.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass KeySpecParams:\n    \"\"\"Represents the parameters for a key specification.\"\"\"\n    key_hash: bytes\n    delegate: Optional[str] = None\n\n    def marshal(self) -&gt; bytes:\n        \"\"\"Serialize the KeySpecParams to bytes correctly.\"\"\"\n        key_hash_data = field_marshal_binary(1, field_marshal_binary(0x20, self.key_hash))  #  keyHash encoding with `0x20`\n\n        delegate_data = b\"\"\n        if self.delegate:\n            delegate_data = field_marshal_binary(2, self.delegate.encode(\"utf-8\"))\n\n        return key_hash_data + delegate_data  #  Concatenating\n\n    @classmethod\n    def unmarshal(cls, data: bytes) -&gt; \"KeySpecParams\":\n        \"\"\"Deserialize bytes into a KeySpecParams instance using field-based encoding.\"\"\"\n        reader = io.BytesIO(data)\n\n        key_hash = None\n        delegate = None\n\n        while reader.tell() &lt; len(data):  #  Process all fields\n            field_number = read_uvarint(reader)  #  Read the field number\n            if field_number == 1:  #  Key Hash\n                key_hash = unmarshal_bytes(reader)\n            elif field_number == 2:  #  Delegate (if present)\n                delegate = unmarshal_string(reader)\n\n        if key_hash is None:\n            raise ValueError(\" Missing key_hash in KeySpecParams deserialization!\")\n\n        return cls(key_hash=key_hash, delegate=delegate)\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeySpecParams.marshal","title":"<code>marshal()</code>","text":"<p>Serialize the KeySpecParams to bytes correctly.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>def marshal(self) -&gt; bytes:\n    \"\"\"Serialize the KeySpecParams to bytes correctly.\"\"\"\n    key_hash_data = field_marshal_binary(1, field_marshal_binary(0x20, self.key_hash))  #  keyHash encoding with `0x20`\n\n    delegate_data = b\"\"\n    if self.delegate:\n        delegate_data = field_marshal_binary(2, self.delegate.encode(\"utf-8\"))\n\n    return key_hash_data + delegate_data  #  Concatenating\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.KeySpecParams.unmarshal","title":"<code>unmarshal(data)</code>  <code>classmethod</code>","text":"<p>Deserialize bytes into a KeySpecParams instance using field-based encoding.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@classmethod\ndef unmarshal(cls, data: bytes) -&gt; \"KeySpecParams\":\n    \"\"\"Deserialize bytes into a KeySpecParams instance using field-based encoding.\"\"\"\n    reader = io.BytesIO(data)\n\n    key_hash = None\n    delegate = None\n\n    while reader.tell() &lt; len(data):  #  Process all fields\n        field_number = read_uvarint(reader)  #  Read the field number\n        if field_number == 1:  #  Key Hash\n            key_hash = unmarshal_bytes(reader)\n        elif field_number == 2:  #  Delegate (if present)\n            delegate = unmarshal_string(reader)\n\n    if key_hash is None:\n        raise ValueError(\" Missing key_hash in KeySpecParams deserialization!\")\n\n    return cls(key_hash=key_hash, delegate=delegate)\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.RemoveKeyOperation","title":"<code>RemoveKeyOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to remove a key from a key page.</p> <p>:param entry: The key specification to remove.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass RemoveKeyOperation:\n    \"\"\"\n    Represents an operation to remove a key from a key page.\n\n    :param entry: The key specification to remove.\n    \"\"\"\n    entry: KeySpec\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.SetRejectThresholdKeyPageOperation","title":"<code>SetRejectThresholdKeyPageOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to set the rejection threshold for a key page.</p> <p>:param threshold: The number of signatures required to reject.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass SetRejectThresholdKeyPageOperation:\n    \"\"\"\n    Represents an operation to set the rejection threshold for a key page.\n\n    :param threshold: The number of signatures required to reject.\n    \"\"\"\n    threshold: int\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.SetResponseThresholdKeyPageOperation","title":"<code>SetResponseThresholdKeyPageOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to set the response threshold for a key page.</p> <p>:param threshold: The number of signatures required for a response.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass SetResponseThresholdKeyPageOperation:\n    \"\"\"\n    Represents an operation to set the response threshold for a key page.\n\n    :param threshold: The number of signatures required for a response.\n    \"\"\"\n    threshold: int\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.SetThresholdKeyPageOperation","title":"<code>SetThresholdKeyPageOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to set the signature threshold for a key page.</p> <p>:param threshold: The required number of signatures.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass SetThresholdKeyPageOperation:\n    \"\"\"\n    Represents an operation to set the signature threshold for a key page.\n\n    :param threshold: The required number of signatures.\n    \"\"\"\n    threshold: int\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.UpdateAllowedKeyPageOperation","title":"<code>UpdateAllowedKeyPageOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to update the allowed or denied transactions for a key page.</p> <p>:param allow: List of allowed transaction types. :param deny: List of denied transaction types.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass UpdateAllowedKeyPageOperation:\n    \"\"\"\n    Represents an operation to update the allowed or denied transactions for a key page.\n\n    :param allow: List of allowed transaction types.\n    :param deny: List of denied transaction types.\n    \"\"\"\n    allow: Optional[List[str]] = None\n    deny: Optional[List[str]] = None\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_management.UpdateKeyOperation","title":"<code>UpdateKeyOperation</code>  <code>dataclass</code>","text":"<p>Represents an operation to update a key in a key page.</p> <p>:param old_entry: The existing key specification to update. :param new_entry: The new key specification to replace the old one.</p> Source code in <code>accumulate\\models\\key_management.py</code> <pre><code>@dataclass\nclass UpdateKeyOperation:\n    \"\"\"\n    Represents an operation to update a key in a key page.\n\n    :param old_entry: The existing key specification to update.\n    :param new_entry: The new key specification to replace the old one.\n    \"\"\"\n    old_entry: KeySpec\n    new_entry: KeySpec\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_signature","title":"<code>key_signature</code>","text":""},{"location":"api_reference/#accumulate.models.key_signature.KeySignature","title":"<code>KeySignature</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class to represent a cryptographic signature.</p> Source code in <code>accumulate\\models\\key_signature.py</code> <pre><code>class KeySignature(ABC):\n    \"\"\"Abstract base class to represent a cryptographic signature.\"\"\"\n\n    @abstractmethod\n    def get_signature(self) -&gt; bytes:\n        \"\"\"Return the signature bytes.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_public_key_hash(self) -&gt; bytes:\n        \"\"\"Return the hash of the public key.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_public_key(self) -&gt; bytes:\n        \"\"\"Return the public key bytes.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_signer_version(self) -&gt; int:\n        \"\"\"Return the version of the signer.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_timestamp(self) -&gt; int:\n        \"\"\"Return the timestamp of the signature.\"\"\"\n        pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_signature.KeySignature.get_public_key","title":"<code>get_public_key()</code>  <code>abstractmethod</code>","text":"<p>Return the public key bytes.</p> Source code in <code>accumulate\\models\\key_signature.py</code> <pre><code>@abstractmethod\ndef get_public_key(self) -&gt; bytes:\n    \"\"\"Return the public key bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_signature.KeySignature.get_public_key_hash","title":"<code>get_public_key_hash()</code>  <code>abstractmethod</code>","text":"<p>Return the hash of the public key.</p> Source code in <code>accumulate\\models\\key_signature.py</code> <pre><code>@abstractmethod\ndef get_public_key_hash(self) -&gt; bytes:\n    \"\"\"Return the hash of the public key.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_signature.KeySignature.get_signature","title":"<code>get_signature()</code>  <code>abstractmethod</code>","text":"<p>Return the signature bytes.</p> Source code in <code>accumulate\\models\\key_signature.py</code> <pre><code>@abstractmethod\ndef get_signature(self) -&gt; bytes:\n    \"\"\"Return the signature bytes.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_signature.KeySignature.get_signer_version","title":"<code>get_signer_version()</code>  <code>abstractmethod</code>","text":"<p>Return the version of the signer.</p> Source code in <code>accumulate\\models\\key_signature.py</code> <pre><code>@abstractmethod\ndef get_signer_version(self) -&gt; int:\n    \"\"\"Return the version of the signer.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.key_signature.KeySignature.get_timestamp","title":"<code>get_timestamp()</code>  <code>abstractmethod</code>","text":"<p>Return the timestamp of the signature.</p> Source code in <code>accumulate\\models\\key_signature.py</code> <pre><code>@abstractmethod\ndef get_timestamp(self) -&gt; int:\n    \"\"\"Return the timestamp of the signature.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.node_info","title":"<code>node_info</code>","text":""},{"location":"api_reference/#accumulate.models.node_info.NodeInfo","title":"<code>NodeInfo</code>  <code>dataclass</code>","text":"<p>Represents information about a network node.</p> Source code in <code>accumulate\\models\\node_info.py</code> <pre><code>@dataclass\nclass NodeInfo:\n    \"\"\"\n    Represents information about a network node.\n    \"\"\"\n    peer_id: str  # node's unique ID\n    network: str  # name of the network (e.g., \"mainnet\" or \"testnet\")\n    services: List[ServiceAddress]  # services the node provides\n    version: str  # software version of the node\n    commit: str  # commit hash of the software version\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"NodeInfo\":\n        \"\"\"\n        Deserialize a dictionary into a NodeInfo object.\n        \"\"\"\n        return cls(\n            peer_id=data.get(\"peer_id\", \"\"),\n            network=data.get(\"network\", \"\"),\n            services=[ServiceAddress.from_dict(svc) for svc in data.get(\"services\", [])],\n            version=data.get(\"version\", \"\"),\n            commit=data.get(\"commit\", \"\"),\n        )\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Serialize a NodeInfo object into a dictionary.\n        \"\"\"\n        return {\n            \"peer_id\": self.peer_id,\n            \"network\": self.network,\n            \"services\": [service.to_dict() for service in self.services],\n            \"version\": self.version,\n            \"commit\": self.commit,\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.node_info.NodeInfo.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a dictionary into a NodeInfo object.</p> Source code in <code>accumulate\\models\\node_info.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"NodeInfo\":\n    \"\"\"\n    Deserialize a dictionary into a NodeInfo object.\n    \"\"\"\n    return cls(\n        peer_id=data.get(\"peer_id\", \"\"),\n        network=data.get(\"network\", \"\"),\n        services=[ServiceAddress.from_dict(svc) for svc in data.get(\"services\", [])],\n        version=data.get(\"version\", \"\"),\n        commit=data.get(\"commit\", \"\"),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.node_info.NodeInfo.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize a NodeInfo object into a dictionary.</p> Source code in <code>accumulate\\models\\node_info.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Serialize a NodeInfo object into a dictionary.\n    \"\"\"\n    return {\n        \"peer_id\": self.peer_id,\n        \"network\": self.network,\n        \"services\": [service.to_dict() for service in self.services],\n        \"version\": self.version,\n        \"commit\": self.commit,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.options","title":"<code>options</code>","text":""},{"location":"api_reference/#accumulate.models.options.FaucetOptions","title":"<code>FaucetOptions</code>  <code>dataclass</code>","text":"<p>Options for requesting tokens from the faucet.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>@dataclass\nclass FaucetOptions:\n    \"\"\"Options for requesting tokens from the faucet.\"\"\"\n    token: Optional[str] = None  # Token URL\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.RangeOptions","title":"<code>RangeOptions</code>  <code>dataclass</code>","text":"<p>Options for querying ranges.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>@dataclass\nclass RangeOptions:\n    \"\"\"Options for querying ranges.\"\"\"\n    start: Optional[int] = None  # Starting index\n    count: Optional[int] = None  # Number of results to return\n    expand: Optional[bool] = None  # Request expanded results\n    from_end: Optional[bool] = False  # Query from the end\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert RangeOptions to a dictionary.\"\"\"\n        return {\n            \"start\": self.start,\n            \"count\": self.count,\n            \"expand\": self.expand,\n            \"from_end\": self.from_end,\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.RangeOptions.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert RangeOptions to a dictionary.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert RangeOptions to a dictionary.\"\"\"\n    return {\n        \"start\": self.start,\n        \"count\": self.count,\n        \"expand\": self.expand,\n        \"from_end\": self.from_end,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.ReceiptOptions","title":"<code>ReceiptOptions</code>  <code>dataclass</code>","text":"<p>Options for querying receipts.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>@dataclass\nclass ReceiptOptions:\n    \"\"\"Options for querying receipts.\"\"\"\n    for_any: bool = False  # Query for any receipt\n    for_height: Optional[int] = None  # Query for receipts at a specific height\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert ReceiptOptions to a dictionary.\"\"\"\n        return {\n            \"for_any\": self.for_any,\n            \"for_height\": self.for_height,\n        }\n\n    def is_valid(self) -&gt; bool:\n        \"\"\"Validate the receipt options.\"\"\"\n        return self.for_any or self.for_height is not None\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.ReceiptOptions.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the receipt options.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>def is_valid(self) -&gt; bool:\n    \"\"\"Validate the receipt options.\"\"\"\n    return self.for_any or self.for_height is not None\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.ReceiptOptions.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert ReceiptOptions to a dictionary.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert ReceiptOptions to a dictionary.\"\"\"\n    return {\n        \"for_any\": self.for_any,\n        \"for_height\": self.for_height,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.SubmitOptions","title":"<code>SubmitOptions</code>  <code>dataclass</code>","text":"<p>Options for submitting transactions.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>@dataclass\nclass SubmitOptions:\n    \"\"\"Options for submitting transactions.\"\"\"\n    verify: Optional[bool] = True  # Verify the envelope before submitting\n    wait: Optional[bool] = True  # Wait for inclusion into a block or rejection\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.SubscribeOptions","title":"<code>SubscribeOptions</code>  <code>dataclass</code>","text":"<p>Options for subscribing to events.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>@dataclass\nclass SubscribeOptions:\n    \"\"\"Options for subscribing to events.\"\"\"\n    partition: Optional[str] = None  # Partition name\n    account: Optional[str] = None  # Account URL\n</code></pre>"},{"location":"api_reference/#accumulate.models.options.ValidateOptions","title":"<code>ValidateOptions</code>  <code>dataclass</code>","text":"<p>Options for validating transactions.</p> Source code in <code>accumulate\\models\\options.py</code> <pre><code>@dataclass\nclass ValidateOptions:\n    \"\"\"Options for validating transactions.\"\"\"\n    full: Optional[bool] = True  # Fully validate signatures and transactions\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol","title":"<code>protocol</code>","text":""},{"location":"api_reference/#accumulate.models.protocol.AccountAuthOperation","title":"<code>AccountAuthOperation</code>","text":"<p>Base class for account authorization operations.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class AccountAuthOperation:\n    \"\"\"Base class for account authorization operations.\"\"\"\n    def __init__(self, authority: URL):\n        self.authority = authority\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AccountWithTokens","title":"<code>AccountWithTokens</code>","text":"<p>Interface for accounts that manage tokens.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class AccountWithTokens:\n    \"\"\"Interface for accounts that manage tokens.\"\"\"\n\n    def __init__(self, url: URL, balance: Decimal, token_url: URL):\n        self.url = url\n        self.balance = balance\n        self.token_url = token_url\n\n    def token_balance(self) -&gt; Decimal:\n        return self.balance\n\n    def credit_tokens(self, amount: Decimal) -&gt; bool:\n        if amount &lt;= 0:\n            return False\n        self.balance += amount\n        return True\n\n    def can_debit_tokens(self, amount: Decimal) -&gt; bool:\n        return amount &gt; 0 and self.balance &gt;= amount\n\n    def debit_tokens(self, amount: Decimal) -&gt; bool:\n        if not self.can_debit_tokens(amount):\n            return False\n        self.balance -= amount\n        return True\n\n    def get_token_url(self) -&gt; URL:\n        return self.token_url\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AddAccountAuthorityOperation","title":"<code>AddAccountAuthorityOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Add a new authority to an account.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class AddAccountAuthorityOperation(AccountAuthOperation):\n    \"\"\"Add a new authority to an account.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions","title":"<code>AllowedTransactions</code>","text":"<p>Bit mask for allowed transactions.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class AllowedTransactions:\n    \"\"\"Bit mask for allowed transactions.\"\"\"\n\n    def __init__(self, value: int = 0):\n        self.value = value\n\n    def set(self, bit: int) -&gt; None:\n        \"\"\"Set the bit to 1.\"\"\"\n        self.value |= (1 &lt;&lt; bit)\n\n    def clear(self, bit: int) -&gt; None:\n        \"\"\"Clear the bit (set to 0).\"\"\"\n        self.value &amp;= ~(1 &lt;&lt; bit)\n\n    def is_set(self, bit: int) -&gt; bool:\n        \"\"\"Check if the bit is set.\"\"\"\n        return (self.value &amp; (1 &lt;&lt; bit)) != 0\n\n    def unpack(self) -&gt; List[int]:\n        \"\"\"List all set bits.\"\"\"\n        bits = []\n        value = self.value\n        bit_index = 0\n        while value &gt; 0:\n            if value &amp; 1:\n                bits.append(bit_index)\n            value &gt;&gt;= 1\n            bit_index += 1\n        return bits\n\n    def get_enum_value(self) -&gt; int:\n        \"\"\"Get the underlying integer value.\"\"\"\n        return self.value\n\n    def set_enum_value(self, value: int) -&gt; None:\n        \"\"\"Set the value from an integer.\"\"\"\n        self.value = value\n\n    def to_json(self) -&gt; str:\n        \"\"\"Serialize the object to JSON.\"\"\"\n        return json.dumps(self.unpack())\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"AllowedTransactions\":\n        \"\"\"Deserialize from JSON.\"\"\"\n        bits = json.loads(json_str)\n        instance = cls()\n        for bit in bits:\n            instance.set(bit)\n        return instance\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.clear","title":"<code>clear(bit)</code>","text":"<p>Clear the bit (set to 0).</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def clear(self, bit: int) -&gt; None:\n    \"\"\"Clear the bit (set to 0).\"\"\"\n    self.value &amp;= ~(1 &lt;&lt; bit)\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Deserialize from JSON.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; \"AllowedTransactions\":\n    \"\"\"Deserialize from JSON.\"\"\"\n    bits = json.loads(json_str)\n    instance = cls()\n    for bit in bits:\n        instance.set(bit)\n    return instance\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.get_enum_value","title":"<code>get_enum_value()</code>","text":"<p>Get the underlying integer value.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def get_enum_value(self) -&gt; int:\n    \"\"\"Get the underlying integer value.\"\"\"\n    return self.value\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.is_set","title":"<code>is_set(bit)</code>","text":"<p>Check if the bit is set.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def is_set(self, bit: int) -&gt; bool:\n    \"\"\"Check if the bit is set.\"\"\"\n    return (self.value &amp; (1 &lt;&lt; bit)) != 0\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.set","title":"<code>set(bit)</code>","text":"<p>Set the bit to 1.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def set(self, bit: int) -&gt; None:\n    \"\"\"Set the bit to 1.\"\"\"\n    self.value |= (1 &lt;&lt; bit)\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.set_enum_value","title":"<code>set_enum_value(value)</code>","text":"<p>Set the value from an integer.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def set_enum_value(self, value: int) -&gt; None:\n    \"\"\"Set the value from an integer.\"\"\"\n    self.value = value\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.to_json","title":"<code>to_json()</code>","text":"<p>Serialize the object to JSON.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"Serialize the object to JSON.\"\"\"\n    return json.dumps(self.unpack())\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.AllowedTransactions.unpack","title":"<code>unpack()</code>","text":"<p>List all set bits.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def unpack(self) -&gt; List[int]:\n    \"\"\"List all set bits.\"\"\"\n    bits = []\n    value = self.value\n    bit_index = 0\n    while value &gt; 0:\n        if value &amp; 1:\n            bits.append(bit_index)\n        value &gt;&gt;= 1\n        bit_index += 1\n    return bits\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.DisableAccountAuthOperation","title":"<code>DisableAccountAuthOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Disable authorization for an account.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class DisableAccountAuthOperation(AccountAuthOperation):\n    \"\"\"Disable authorization for an account.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.EnableAccountAuthOperation","title":"<code>EnableAccountAuthOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Enable authorization for an account.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class EnableAccountAuthOperation(AccountAuthOperation):\n    \"\"\"Enable authorization for an account.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.LiteTokenAccount","title":"<code>LiteTokenAccount</code>","text":"<p>               Bases: <code>AccountWithTokens</code></p> <p>Represents a lite token account.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class LiteTokenAccount(AccountWithTokens):\n    \"\"\"Represents a lite token account.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.Receipt","title":"<code>Receipt</code>  <code>dataclass</code>","text":"<p>Represents a receipt with block metadata.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>@dataclass\nclass Receipt:\n    \"\"\"Represents a receipt with block metadata.\"\"\"\n    local_block: Optional[int] = None\n    local_block_time: Optional[str] = None  # ISO 8601 datetime string\n    major_block: Optional[int] = None\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the receipt to a dictionary.\"\"\"\n        return {\n            \"local_block\": self.local_block,\n            \"local_block_time\": self.local_block_time,\n            \"major_block\": self.major_block,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"Receipt\":\n        \"\"\"Create a receipt from a dictionary.\"\"\"\n        local_block_time = data.get(\"local_block_time\")\n        if local_block_time:\n            cls._validate_iso8601(local_block_time)\n\n        return cls(\n            local_block=data.get(\"local_block\"),\n            local_block_time=local_block_time,\n            major_block=data.get(\"major_block\"),\n        )\n\n    @staticmethod\n    def _validate_iso8601(date_str: str):\n        \"\"\"Validate the string is in ISO 8601 format.\"\"\"\n        try:\n            datetime.fromisoformat(date_str)\n        except ValueError:\n            raise ValueError(f\"Invalid ISO 8601 datetime: {date_str}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.Receipt._validate_iso8601","title":"<code>_validate_iso8601(date_str)</code>  <code>staticmethod</code>","text":"<p>Validate the string is in ISO 8601 format.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>@staticmethod\ndef _validate_iso8601(date_str: str):\n    \"\"\"Validate the string is in ISO 8601 format.\"\"\"\n    try:\n        datetime.fromisoformat(date_str)\n    except ValueError:\n        raise ValueError(f\"Invalid ISO 8601 datetime: {date_str}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.Receipt.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a receipt from a dictionary.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"Receipt\":\n    \"\"\"Create a receipt from a dictionary.\"\"\"\n    local_block_time = data.get(\"local_block_time\")\n    if local_block_time:\n        cls._validate_iso8601(local_block_time)\n\n    return cls(\n        local_block=data.get(\"local_block\"),\n        local_block_time=local_block_time,\n        major_block=data.get(\"major_block\"),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.Receipt.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the receipt to a dictionary.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the receipt to a dictionary.\"\"\"\n    return {\n        \"local_block\": self.local_block,\n        \"local_block_time\": self.local_block_time,\n        \"major_block\": self.major_block,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.RemoveAccountAuthorityOperation","title":"<code>RemoveAccountAuthorityOperation</code>","text":"<p>               Bases: <code>AccountAuthOperation</code></p> <p>Remove an authority from an account.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class RemoveAccountAuthorityOperation(AccountAuthOperation):\n    \"\"\"Remove an authority from an account.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.TokenAccount","title":"<code>TokenAccount</code>","text":"<p>               Bases: <code>AccountWithTokens</code></p> <p>Represents a standard token account.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class TokenAccount(AccountWithTokens):\n    \"\"\"Represents a standard token account.\"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.TokenIssuer","title":"<code>TokenIssuer</code>","text":"<p>Represents a token issuer.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>class TokenIssuer:\n    \"\"\"Represents a token issuer.\"\"\"\n\n    def __init__(self, issued: Decimal, supply_limit: Optional[Decimal] = None):\n        self.issued = issued\n        self.supply_limit = supply_limit\n\n    def issue(self, amount: Decimal) -&gt; bool:\n        self.issued += amount\n        if self.supply_limit is None:\n            return True\n        return self.issued &lt;= self.supply_limit\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.acme_url","title":"<code>acme_url()</code>","text":"<p>Returns the URL for the ACME token.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def acme_url() -&gt; URL:\n    \"\"\"Returns the URL for the ACME token.\"\"\"\n    return URL(authority=ACME)\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.lite_data_address","title":"<code>lite_data_address(chain_id)</code>","text":"<p>Generates a lite data address from a chain ID.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def lite_data_address(chain_id: bytes) -&gt; Optional[URL]:\n    \"\"\"Generates a lite data address from a chain ID.\"\"\"\n    if len(chain_id) &lt; 32:\n        raise ValueError(\"chain_id must be 32 bytes long\")\n    key_str = chain_id.hex()[:32]\n    return URL(authority=key_str)\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.lite_token_address","title":"<code>lite_token_address(pub_key, token_url_str)</code>","text":"<p>Generates a lite token account URL from a public key and token URL.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def lite_token_address(pub_key: bytes, token_url_str: str) -&gt; Optional[URL]:\n    \"\"\"Generates a lite token account URL from a public key and token URL.\"\"\"\n    logger = logging.getLogger(__name__)\n    try:\n        logger.debug(f\"Attempting to generate lite token address for token URL: {token_url_str}\")\n        print(f\"DEBUG: Normalizing token URL: {token_url_str}\")\n\n        # Normalize and validate the token URL\n        token_url_str = normalize_acc_url(token_url_str)\n        print(f\"DEBUG: Normalized token URL: {token_url_str}\")\n\n        token_url = URL.parse(token_url_str)\n        print(f\"DEBUG: Parsed token URL: {token_url}\")\n\n        # Validate based on token URL type\n        print(f\"DEBUG: Validating token URL. Authority: {token_url.authority}, Path: {token_url.path}\")\n        if token_url.path == \"\" and not re.match(r\"^[a-fA-F0-9]{40,64}$\", token_url.authority):\n            if '.' not in token_url.authority:  # Check if it's a valid ADI\n                raise ValueError(\"Invalid token URL: Missing path or invalid identity format.\")\n\n        if token_url.query or token_url.fragment or token_url.user_info:\n            raise ValueError(\"Token URL cannot include query, fragment, or user info.\")\n\n        # Generate authority\n        key_hash = sha256(pub_key).hexdigest()[:40]\n        checksum = sha256(key_hash.encode()).hexdigest()[-8:]\n        authority = f\"{key_hash}{checksum}\"\n        print(f\"DEBUG: Generated authority: {authority}\")\n\n        return URL(authority=authority, path=token_url.path)\n\n    except ValueError as ve:\n        logger.error(f\"Failed to generate lite token address: {ve}\")\n        raise ValueError(f\"Invalid token URL '{token_url_str}': {ve}\") from ve\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.normalize_acc_url","title":"<code>normalize_acc_url(url_str)</code>","text":"<p>Ensures a URL starts with the 'acc://' prefix.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def normalize_acc_url(url_str: str) -&gt; str:\n    \"\"\"Ensures a URL starts with the 'acc://' prefix.\"\"\"\n    if not url_str.startswith(\"acc://\"):\n        return f\"acc://{url_str}\"\n    return url_str\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.parse_lite_address","title":"<code>parse_lite_address(url)</code>","text":"<p>Parses and validates a lite address.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def parse_lite_address(url: URL) -&gt; Optional[bytes]:\n    \"\"\"Parses and validates a lite address.\"\"\"\n    try:\n        b = bytes.fromhex(url.authority)\n        if len(b) &lt;= 4:\n            raise ValueError(\"Too short\")\n        byte_value, byte_check = b[:-4], b[-4:]\n        checksum = sha256(byte_value).digest()[-4:]\n        if checksum != byte_check:\n            raise ValueError(\"Invalid checksum\")\n        return byte_value\n    except Exception as e:\n        raise ValueError(f\"Error parsing lite address: {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.protocol.unknown_url","title":"<code>unknown_url()</code>","text":"<p>Returns the URL for unknown entities.</p> Source code in <code>accumulate\\models\\protocol.py</code> <pre><code>def unknown_url() -&gt; URL:\n    \"\"\"Returns the URL for unknown entities.\"\"\"\n    return URL(authority=UNKNOWN)\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses","title":"<code>responses</code>","text":""},{"location":"api_reference/#accumulate.models.responses.SubmissionResponse","title":"<code>SubmissionResponse</code>  <code>dataclass</code>","text":"<p>Represents the response for a transaction submission.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>@dataclass\nclass SubmissionResponse:\n    \"\"\"Represents the response for a transaction submission.\"\"\"\n    status: Optional[TransactionStatus] = None\n    success: bool = False\n    message: Optional[str] = None\n    receipt: Optional[Receipt] = None  # Added Receipt integration\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Serialize the response to a dictionary.\"\"\"\n        serialized_data = {\n            \"status\": self.status.to_dict() if self.status else None,\n            \"success\": self.success,\n            \"message\": self.message,\n            \"receipt\": self.receipt.to_dict() if self.receipt else None,  # Serialize Receipt\n        }\n        print(f\"[DEBUG] Serialized SubmissionResponse: {serialized_data}\")\n        return serialized_data\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"SubmissionResponse\":\n        \"\"\"Deserialize the response from a dictionary.\"\"\"\n        print(f\"[DEBUG] Deserializing SubmissionResponse from data: {data}\")\n        status = TransactionStatus.from_dict(data[\"status\"]) if data.get(\"status\") else None\n        print(f\"[DEBUG] Deserialized status: {status.to_dict() if status else None}\")\n        receipt = Receipt.from_dict(data[\"receipt\"]) if data.get(\"receipt\") else None\n        print(f\"[DEBUG] Deserialized receipt: {receipt.to_dict() if receipt else None}\")\n        response = cls(\n            status=status,\n            success=data.get(\"success\", False),\n            message=data.get(\"message\"),\n            receipt=receipt,\n        )\n        print(f\"[DEBUG] Final SubmissionResponse object: {response}\")\n        return response\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses.SubmissionResponse.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize the response from a dictionary.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"SubmissionResponse\":\n    \"\"\"Deserialize the response from a dictionary.\"\"\"\n    print(f\"[DEBUG] Deserializing SubmissionResponse from data: {data}\")\n    status = TransactionStatus.from_dict(data[\"status\"]) if data.get(\"status\") else None\n    print(f\"[DEBUG] Deserialized status: {status.to_dict() if status else None}\")\n    receipt = Receipt.from_dict(data[\"receipt\"]) if data.get(\"receipt\") else None\n    print(f\"[DEBUG] Deserialized receipt: {receipt.to_dict() if receipt else None}\")\n    response = cls(\n        status=status,\n        success=data.get(\"success\", False),\n        message=data.get(\"message\"),\n        receipt=receipt,\n    )\n    print(f\"[DEBUG] Final SubmissionResponse object: {response}\")\n    return response\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses.SubmissionResponse.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the response to a dictionary.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Serialize the response to a dictionary.\"\"\"\n    serialized_data = {\n        \"status\": self.status.to_dict() if self.status else None,\n        \"success\": self.success,\n        \"message\": self.message,\n        \"receipt\": self.receipt.to_dict() if self.receipt else None,  # Serialize Receipt\n    }\n    print(f\"[DEBUG] Serialized SubmissionResponse: {serialized_data}\")\n    return serialized_data\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses.TransactionResultSet","title":"<code>TransactionResultSet</code>  <code>dataclass</code>","text":"<p>Represents a set of transaction results returned from a query.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>@dataclass\nclass TransactionResultSet:\n    \"\"\"Represents a set of transaction results returned from a query.\"\"\"\n    results: List[TransactionStatus] = None\n\n    def __post_init__(self):\n        if self.results is None:\n            self.results = []\n\n    def add_result(self, result: TransactionStatus):\n        \"\"\"Add a transaction status to the results.\"\"\"\n        print(f\"[DEBUG] Adding result: {result.to_dict()}\")\n        self.results.append(result)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the result set to a dictionary representation.\"\"\"\n        serialized_data = {\"results\": [result.to_dict() for result in self.results]}\n        print(f\"[DEBUG] Serialized TransactionResultSet: {serialized_data}\")\n        return serialized_data\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"TransactionResultSet\":\n        \"\"\"Create a TransactionResultSet from a dictionary.\"\"\"\n        print(f\"[DEBUG] Deserializing TransactionResultSet from data: {data}\")\n        results = [\n            TransactionStatus.from_dict(item) for item in data.get(\"results\", [])\n        ]\n        for i, result in enumerate(results):\n            print(f\"[DEBUG] Deserialized result {i}: {result.to_dict()}\")\n        result_set = cls(results)\n        print(f\"[DEBUG] Final TransactionResultSet object: {result_set}\")\n        return result_set\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses.TransactionResultSet.add_result","title":"<code>add_result(result)</code>","text":"<p>Add a transaction status to the results.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>def add_result(self, result: TransactionStatus):\n    \"\"\"Add a transaction status to the results.\"\"\"\n    print(f\"[DEBUG] Adding result: {result.to_dict()}\")\n    self.results.append(result)\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses.TransactionResultSet.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a TransactionResultSet from a dictionary.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"TransactionResultSet\":\n    \"\"\"Create a TransactionResultSet from a dictionary.\"\"\"\n    print(f\"[DEBUG] Deserializing TransactionResultSet from data: {data}\")\n    results = [\n        TransactionStatus.from_dict(item) for item in data.get(\"results\", [])\n    ]\n    for i, result in enumerate(results):\n        print(f\"[DEBUG] Deserialized result {i}: {result.to_dict()}\")\n    result_set = cls(results)\n    print(f\"[DEBUG] Final TransactionResultSet object: {result_set}\")\n    return result_set\n</code></pre>"},{"location":"api_reference/#accumulate.models.responses.TransactionResultSet.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the result set to a dictionary representation.</p> Source code in <code>accumulate\\models\\responses.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the result set to a dictionary representation.\"\"\"\n    serialized_data = {\"results\": [result.to_dict() for result in self.results]}\n    print(f\"[DEBUG] Serialized TransactionResultSet: {serialized_data}\")\n    return serialized_data\n</code></pre>"},{"location":"api_reference/#accumulate.models.search","title":"<code>search</code>","text":""},{"location":"api_reference/#accumulate.models.search.AnchorSearchQuery","title":"<code>AnchorSearchQuery</code>","text":"<p>               Bases: <code>SearchQuery</code></p> <p>Search for an anchor in an account.</p> Source code in <code>accumulate\\models\\search.py</code> <pre><code>class AnchorSearchQuery(SearchQuery):\n    \"\"\"Search for an anchor in an account.\"\"\"\n\n    def __init__(self, anchor: Union[bytes, str], include_receipt: Optional[bool] = None):\n        \"\"\"\n        Args:\n            anchor (Union[bytes, str]): The anchor value (hash) to search for.\n            include_receipt (Optional[bool]): Whether to include a receipt in the response.\n        \"\"\"\n        anchor_value = anchor.hex() if isinstance(anchor, bytes) else anchor\n        extra_params = {\"include_receipt\": include_receipt} if include_receipt is not None else {}\n        super().__init__(QueryType.ANCHOR_SEARCH, anchor_value, extra_params)\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.AnchorSearchQuery.__init__","title":"<code>__init__(anchor, include_receipt=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>Union[bytes, str]</code> <p>The anchor value (hash) to search for.</p> required <code>include_receipt</code> <code>Optional[bool]</code> <p>Whether to include a receipt in the response.</p> <code>None</code> Source code in <code>accumulate\\models\\search.py</code> <pre><code>def __init__(self, anchor: Union[bytes, str], include_receipt: Optional[bool] = None):\n    \"\"\"\n    Args:\n        anchor (Union[bytes, str]): The anchor value (hash) to search for.\n        include_receipt (Optional[bool]): Whether to include a receipt in the response.\n    \"\"\"\n    anchor_value = anchor.hex() if isinstance(anchor, bytes) else anchor\n    extra_params = {\"include_receipt\": include_receipt} if include_receipt is not None else {}\n    super().__init__(QueryType.ANCHOR_SEARCH, anchor_value, extra_params)\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.DelegateSearchQuery","title":"<code>DelegateSearchQuery</code>","text":"<p>               Bases: <code>SearchQuery</code></p> <p>Search for a delegate in an account.</p> Source code in <code>accumulate\\models\\search.py</code> <pre><code>class DelegateSearchQuery(SearchQuery):\n    \"\"\"Search for a delegate in an account.\"\"\"\n\n    def __init__(self, delegate_url: str):\n        \"\"\"\n        Args:\n            delegate_url (str): The URL of the delegate being searched.\n        \"\"\"\n        super().__init__(QueryType.DELEGATE_SEARCH, delegate_url)\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.DelegateSearchQuery.__init__","title":"<code>__init__(delegate_url)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>delegate_url</code> <code>str</code> <p>The URL of the delegate being searched.</p> required Source code in <code>accumulate\\models\\search.py</code> <pre><code>def __init__(self, delegate_url: str):\n    \"\"\"\n    Args:\n        delegate_url (str): The URL of the delegate being searched.\n    \"\"\"\n    super().__init__(QueryType.DELEGATE_SEARCH, delegate_url)\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.PublicKeySearchQuery","title":"<code>PublicKeySearchQuery</code>","text":"<p>               Bases: <code>SearchQuery</code></p> <p>Search for a public key in an account.</p> Source code in <code>accumulate\\models\\search.py</code> <pre><code>class PublicKeySearchQuery(SearchQuery):\n    \"\"\"Search for a public key in an account.\"\"\"\n\n    def __init__(self, public_key: str, key_type: Optional[str] = None):\n        \"\"\"\n        Args:\n            public_key (str): The public key, address, or public key hash.\n            key_type (Optional[str]): The type of public key (e.g., 'ed25519', 'btc', 'eth').\n        \"\"\"\n        extra_params = {\"type\": key_type} if key_type else {}\n        super().__init__(QueryType.PUBLIC_KEY_SEARCH, public_key, extra_params)\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.PublicKeySearchQuery.__init__","title":"<code>__init__(public_key, key_type=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>public_key</code> <code>str</code> <p>The public key, address, or public key hash.</p> required <code>key_type</code> <code>Optional[str]</code> <p>The type of public key (e.g., 'ed25519', 'btc', 'eth').</p> <code>None</code> Source code in <code>accumulate\\models\\search.py</code> <pre><code>def __init__(self, public_key: str, key_type: Optional[str] = None):\n    \"\"\"\n    Args:\n        public_key (str): The public key, address, or public key hash.\n        key_type (Optional[str]): The type of public key (e.g., 'ed25519', 'btc', 'eth').\n    \"\"\"\n    extra_params = {\"type\": key_type} if key_type else {}\n    super().__init__(QueryType.PUBLIC_KEY_SEARCH, public_key, extra_params)\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.SearchQuery","title":"<code>SearchQuery</code>","text":"<p>               Bases: <code>Query</code></p> <p>Base class for all search queries (Anchor, Public Key, Delegate).</p> Source code in <code>accumulate\\models\\search.py</code> <pre><code>class SearchQuery(Query):\n    \"\"\"Base class for all search queries (Anchor, Public Key, Delegate).\"\"\"\n\n    def __init__(self, query_type: QueryType, value: str, extra_params: Optional[Dict[str, Any]] = None):\n        \"\"\"\n        Args:\n            query_type (QueryType): The type of search query (anchor, publicKey, delegate).\n            value (str): The value being searched (hash, public key, or delegate URL).\n            extra_params (Optional[Dict[str, Any]]): Additional query parameters.\n        \"\"\"\n        super().__init__(query_type)\n        self.value = value\n        self.extra_params = extra_params or {}\n\n    def is_valid(self):\n        \"\"\"Validate the search query.\"\"\"\n        if not self.value:\n            raise AccumulateError(f\"{self.query_type.name} search requires a valid value.\")\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert the search query into a dictionary that can be used with `client.search()`.\"\"\"\n        return {\n            \"value\": self.value,\n            \"extra_params\": self.extra_params\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.SearchQuery.__init__","title":"<code>__init__(query_type, value, extra_params=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>query_type</code> <code>QueryType</code> <p>The type of search query (anchor, publicKey, delegate).</p> required <code>value</code> <code>str</code> <p>The value being searched (hash, public key, or delegate URL).</p> required <code>extra_params</code> <code>Optional[Dict[str, Any]]</code> <p>Additional query parameters.</p> <code>None</code> Source code in <code>accumulate\\models\\search.py</code> <pre><code>def __init__(self, query_type: QueryType, value: str, extra_params: Optional[Dict[str, Any]] = None):\n    \"\"\"\n    Args:\n        query_type (QueryType): The type of search query (anchor, publicKey, delegate).\n        value (str): The value being searched (hash, public key, or delegate URL).\n        extra_params (Optional[Dict[str, Any]]): Additional query parameters.\n    \"\"\"\n    super().__init__(query_type)\n    self.value = value\n    self.extra_params = extra_params or {}\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.SearchQuery.is_valid","title":"<code>is_valid()</code>","text":"<p>Validate the search query.</p> Source code in <code>accumulate\\models\\search.py</code> <pre><code>def is_valid(self):\n    \"\"\"Validate the search query.\"\"\"\n    if not self.value:\n        raise AccumulateError(f\"{self.query_type.name} search requires a valid value.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.search.SearchQuery.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the search query into a dictionary that can be used with <code>client.search()</code>.</p> Source code in <code>accumulate\\models\\search.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert the search query into a dictionary that can be used with `client.search()`.\"\"\"\n    return {\n        \"value\": self.value,\n        \"extra_params\": self.extra_params\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.service","title":"<code>service</code>","text":""},{"location":"api_reference/#accumulate.models.service.FindServiceOptions","title":"<code>FindServiceOptions</code>  <code>dataclass</code>","text":"<p>Represents options for finding a service in the Accumulate network.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@dataclass\nclass FindServiceOptions:\n    \"\"\"\n    Represents options for finding a service in the Accumulate network.\n    \"\"\"\n    network: str  # network name\n    service: Optional[ServiceAddress] = None  # service address to search for\n    known: Optional[bool] = None  # Restrict results to known peers\n    timeout: Optional[timedelta] = None  #  timeout for querying the DHT\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Serialize a FindServiceOptions object into a dictionary.\n        Removes `timeout` if it is None to prevent JSON-RPC errors.\n        \"\"\"\n        params = {\n            \"network\": self.network,\n            \"service\": self.service.to_dict() if self.service else None,\n            \"known\": self.known,\n        }\n\n        # Only include timeout if it is set\n        if self.timeout is not None:\n            params[\"timeout\"] = self.timeout.total_seconds()\n\n        return params\n\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"FindServiceOptions\":\n        \"\"\"\n        Deserialize a dictionary into a FindServiceOptions object.\n        \"\"\"\n        return cls(\n            network=data.get(\"network\", \"\"),\n            service=ServiceAddress.from_dict(data[\"service\"]) if \"service\" in data else None,\n            known=data.get(\"known\"),\n            timeout=timedelta(seconds=data[\"timeout\"]) if \"timeout\" in data else None,\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.FindServiceOptions.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a dictionary into a FindServiceOptions object.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"FindServiceOptions\":\n    \"\"\"\n    Deserialize a dictionary into a FindServiceOptions object.\n    \"\"\"\n    return cls(\n        network=data.get(\"network\", \"\"),\n        service=ServiceAddress.from_dict(data[\"service\"]) if \"service\" in data else None,\n        known=data.get(\"known\"),\n        timeout=timedelta(seconds=data[\"timeout\"]) if \"timeout\" in data else None,\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.FindServiceOptions.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize a FindServiceOptions object into a dictionary. Removes <code>timeout</code> if it is None to prevent JSON-RPC errors.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Serialize a FindServiceOptions object into a dictionary.\n    Removes `timeout` if it is None to prevent JSON-RPC errors.\n    \"\"\"\n    params = {\n        \"network\": self.network,\n        \"service\": self.service.to_dict() if self.service else None,\n        \"known\": self.known,\n    }\n\n    # Only include timeout if it is set\n    if self.timeout is not None:\n        params[\"timeout\"] = self.timeout.total_seconds()\n\n    return params\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.FindServiceResult","title":"<code>FindServiceResult</code>  <code>dataclass</code>","text":"<p>Represents the result of a service search in the Accumulate network.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@dataclass\nclass FindServiceResult:\n    \"\"\"\n    Represents the result of a service search in the Accumulate network.\n    \"\"\"\n    peer_id: str  # unique ID of the peer providing the service\n    status: str  # status of the known peer\n    addresses: List[str]  # list of addresses associated with the service\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Serialize a FindServiceResult object into a dictionary.\n        \"\"\"\n        return {\n            \"peer_id\": self.peer_id,\n            \"status\": self.status,\n            \"addresses\": self.addresses,\n        }\n\n    @classmethod\n    def from_dict(cls, data: dict) -&gt; \"FindServiceResult\":\n        \"\"\"\n        Deserialize a dictionary into a FindServiceResult object.\n        \"\"\"\n        return cls(\n            peer_id=data.get(\"peer_id\", \"\"),\n            status=data.get(\"status\", \"\"),\n            addresses=data.get(\"addresses\", []),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.FindServiceResult.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Deserialize a dictionary into a FindServiceResult object.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"FindServiceResult\":\n    \"\"\"\n    Deserialize a dictionary into a FindServiceResult object.\n    \"\"\"\n    return cls(\n        peer_id=data.get(\"peer_id\", \"\"),\n        status=data.get(\"status\", \"\"),\n        addresses=data.get(\"addresses\", []),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.FindServiceResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize a FindServiceResult object into a dictionary.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Serialize a FindServiceResult object into a dictionary.\n    \"\"\"\n    return {\n        \"peer_id\": self.peer_id,\n        \"status\": self.status,\n        \"addresses\": self.addresses,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress","title":"<code>ServiceAddress</code>  <code>dataclass</code>","text":"<p>Represents a service address with type and argument.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@dataclass\nclass ServiceAddress:\n    \"\"\"\n    Represents a service address with type and argument.\n    \"\"\"\n    service_type: int  # Type of the service, represented as an integer\n    argument: Optional[str] = None  # Optional argument for the service\n\n    @property\n    def type(self) -&gt; int:\n        \"\"\"Alias for service_type.\"\"\"\n        return self.service_type\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns {type}:{argument}, or {type} if the argument is empty.\n        \"\"\"\n        base = hex(self.service_type)[2:] if isinstance(self.service_type, int) else str(self.service_type)\n        return f\"{base}:{self.argument}\" if self.argument else base\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Converts the object to a dictionary.\n        \"\"\"\n        return {\"type\": self.service_type, \"argument\": self.argument}\n\n    @staticmethod\n    def from_dict(data: dict) -&gt; \"ServiceAddress\":\n        \"\"\"\n        Creates a ServiceAddress from a dictionary.\n        \"\"\"\n        return ServiceAddress(data[\"type\"], data.get(\"argument\"))\n\n    @staticmethod\n    def parse_service_address(address: str) -&gt; \"ServiceAddress\":\n        \"\"\"\n        Parses a string into a ServiceAddress.\n\n        :param address: A string representing the service address in the format {type}:{argument}.\n        :return: A ServiceAddress instance.\n        :raises ValueError: If the format is invalid.\n        \"\"\"\n        if not address or \":\" not in address:\n            raise ValueError(\"Invalid service address: Missing ':' separator or empty string\")\n\n        parts = address.split(\":\", maxsplit=1)\n        if len(parts) &lt; 2 or not parts[0] or not parts[1]:\n            raise ValueError(\"Invalid service address: Missing type or argument\")\n\n        service_type = int(parts[0], 16) if parts[0].startswith(\"0x\") else int(parts[0])\n        return ServiceAddress(service_type=service_type, argument=parts[1])\n\n    @staticmethod\n    def unpack_address(address: str) -&gt; dict:\n        \"\"\"\n        Simulates unpacking of an address string for its components.\n\n        :param address: A string representing the service address.\n        :return: A dictionary containing type and argument of the service address.\n        :raises ValueError: If the address cannot be parsed.\n        \"\"\"\n        try:\n            service_address = ServiceAddress.parse_service_address(address)\n            return {\n                \"type\": service_address.type,\n                \"argument\": service_address.argument,\n            }\n        except Exception as e:\n            raise ValueError(f\"Failed to parse address: {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress.type","title":"<code>type</code>  <code>property</code>","text":"<p>Alias for service_type.</p>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress.__str__","title":"<code>__str__()</code>","text":"<p>Returns {type}:{argument}, or {type} if the argument is empty.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns {type}:{argument}, or {type} if the argument is empty.\n    \"\"\"\n    base = hex(self.service_type)[2:] if isinstance(self.service_type, int) else str(self.service_type)\n    return f\"{base}:{self.argument}\" if self.argument else base\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress.from_dict","title":"<code>from_dict(data)</code>  <code>staticmethod</code>","text":"<p>Creates a ServiceAddress from a dictionary.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@staticmethod\ndef from_dict(data: dict) -&gt; \"ServiceAddress\":\n    \"\"\"\n    Creates a ServiceAddress from a dictionary.\n    \"\"\"\n    return ServiceAddress(data[\"type\"], data.get(\"argument\"))\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress.parse_service_address","title":"<code>parse_service_address(address)</code>  <code>staticmethod</code>","text":"<p>Parses a string into a ServiceAddress.</p> <p>:param address: A string representing the service address in the format {type}:{argument}. :return: A ServiceAddress instance. :raises ValueError: If the format is invalid.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@staticmethod\ndef parse_service_address(address: str) -&gt; \"ServiceAddress\":\n    \"\"\"\n    Parses a string into a ServiceAddress.\n\n    :param address: A string representing the service address in the format {type}:{argument}.\n    :return: A ServiceAddress instance.\n    :raises ValueError: If the format is invalid.\n    \"\"\"\n    if not address or \":\" not in address:\n        raise ValueError(\"Invalid service address: Missing ':' separator or empty string\")\n\n    parts = address.split(\":\", maxsplit=1)\n    if len(parts) &lt; 2 or not parts[0] or not parts[1]:\n        raise ValueError(\"Invalid service address: Missing type or argument\")\n\n    service_type = int(parts[0], 16) if parts[0].startswith(\"0x\") else int(parts[0])\n    return ServiceAddress(service_type=service_type, argument=parts[1])\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress.to_dict","title":"<code>to_dict()</code>","text":"<p>Converts the object to a dictionary.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Converts the object to a dictionary.\n    \"\"\"\n    return {\"type\": self.service_type, \"argument\": self.argument}\n</code></pre>"},{"location":"api_reference/#accumulate.models.service.ServiceAddress.unpack_address","title":"<code>unpack_address(address)</code>  <code>staticmethod</code>","text":"<p>Simulates unpacking of an address string for its components.</p> <p>:param address: A string representing the service address. :return: A dictionary containing type and argument of the service address. :raises ValueError: If the address cannot be parsed.</p> Source code in <code>accumulate\\models\\service.py</code> <pre><code>@staticmethod\ndef unpack_address(address: str) -&gt; dict:\n    \"\"\"\n    Simulates unpacking of an address string for its components.\n\n    :param address: A string representing the service address.\n    :return: A dictionary containing type and argument of the service address.\n    :raises ValueError: If the address cannot be parsed.\n    \"\"\"\n    try:\n        service_address = ServiceAddress.parse_service_address(address)\n        return {\n            \"type\": service_address.type,\n            \"argument\": service_address.argument,\n        }\n    except Exception as e:\n        raise ValueError(f\"Failed to parse address: {e}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures","title":"<code>signatures</code>","text":""},{"location":"api_reference/#accumulate.models.signatures.AuthoritySignature","title":"<code>AuthoritySignature</code>","text":"<p>               Bases: <code>Signature</code></p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class AuthoritySignature(Signature):\n    def __init__(self, origin: URL, authority: URL, vote: Optional[str], txid: Optional[str]):\n        super().__init__('AuthoritySignature', origin)\n        self.authority = authority\n        self.vote = vote\n        self.txid = txid\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Calculate hash for AuthoritySignature.\"\"\"\n        authority_str = str(self.authority).removeprefix(\"acc://\")\n        authority_bytes = authority_str.encode()\n        vote_bytes = str(self.vote).encode() if self.vote else b\"\"\n\n        combined = authority_bytes + vote_bytes\n\n        result_hash = do_sha256(combined)\n        return result_hash\n\n    def verify(self, msg: bytes) -&gt; bool:\n        # TODO: Implement authority-specific verification\n        return True\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.AuthoritySignature.hash","title":"<code>hash()</code>","text":"<p>Calculate hash for AuthoritySignature.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Calculate hash for AuthoritySignature.\"\"\"\n    authority_str = str(self.authority).removeprefix(\"acc://\")\n    authority_bytes = authority_str.encode()\n    vote_bytes = str(self.vote).encode() if self.vote else b\"\"\n\n    combined = authority_bytes + vote_bytes\n\n    result_hash = do_sha256(combined)\n    return result_hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.DelegatedSignature","title":"<code>DelegatedSignature</code>","text":"<p>               Bases: <code>Signature</code></p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class DelegatedSignature(Signature):\n    def __init__(self, signature: Signature, delegator: URL):\n        super().__init__('DelegatedSignature', signature.get_url())\n        self.signature = signature\n        self.delegator = delegator\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Calculate hash for DelegatedSignature.\"\"\"\n        delegator_str = str(self.delegator).removeprefix(\"acc://\")\n        base_hash = self.signature.hash()\n        delegator_bytes = delegator_str.encode()\n\n        combined = base_hash + delegator_bytes\n\n        result_hash = do_sha256(combined)\n        return result_hash\n\n\n    def verify(self, msg: bytes) -&gt; bool:\n        return self.signature.verify(msg)\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.DelegatedSignature.hash","title":"<code>hash()</code>","text":"<p>Calculate hash for DelegatedSignature.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Calculate hash for DelegatedSignature.\"\"\"\n    delegator_str = str(self.delegator).removeprefix(\"acc://\")\n    base_hash = self.signature.hash()\n    delegator_bytes = delegator_str.encode()\n\n    combined = base_hash + delegator_bytes\n\n    result_hash = do_sha256(combined)\n    return result_hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ECDSA_SHA256Signature","title":"<code>ECDSA_SHA256Signature</code>","text":"<p>               Bases: <code>Signature</code></p> <p>Represents an ECDSA SHA-256 signature.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class ECDSA_SHA256Signature(Signature):\n    \"\"\"\n    Represents an ECDSA SHA-256 signature.\n    \"\"\"\n\n    def __init__(self, signer: URL, public_key: bytes, signature: bytes):\n        super().__init__('ECDSA_SHA256', signer)\n        self.public_key = public_key\n        self.signature = signature\n\n    def hash(self) -&gt; bytes:\n        \"\"\"\n        Calculate the SHA-256 hash of the public key.\n        \"\"\"\n        return hashlib.sha256(self.public_key).digest()\n\n    def verify(self, msg: bytes) -&gt; bool:\n        \"\"\"\n        Verify the ECDSA SHA-256 signature for the provided message.\n        \"\"\"\n        try:\n            verifying_key = VerifyingKey.from_string(self.public_key, curve=SECP256k1)\n            # Use hashlib.sha256 directly as the hash function\n            return verifying_key.verify(self.signature, msg, hashfunc=hashlib.sha256)\n        except Exception as e:\n            print(f\"Verification failed: {e}\")\n            return False\n\n    def sign(self, msg: bytes, private_key: bytes) -&gt; bytes:\n        \"\"\"\n        Sign a message using ECDSA SHA-256 with the provided private key.\n        \"\"\"\n        try:\n            signing_key = SigningKey.from_string(private_key, curve=SECP256k1)\n            signature = signing_key.sign(msg, hashfunc=hashlib.sha256)\n            self.signature = signature\n            return signature\n        except Exception as e:\n            print(f\"Signing failed: {e}\")\n            raise\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ECDSA_SHA256Signature.hash","title":"<code>hash()</code>","text":"<p>Calculate the SHA-256 hash of the public key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"\n    Calculate the SHA-256 hash of the public key.\n    \"\"\"\n    return hashlib.sha256(self.public_key).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ECDSA_SHA256Signature.sign","title":"<code>sign(msg, private_key)</code>","text":"<p>Sign a message using ECDSA SHA-256 with the provided private key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def sign(self, msg: bytes, private_key: bytes) -&gt; bytes:\n    \"\"\"\n    Sign a message using ECDSA SHA-256 with the provided private key.\n    \"\"\"\n    try:\n        signing_key = SigningKey.from_string(private_key, curve=SECP256k1)\n        signature = signing_key.sign(msg, hashfunc=hashlib.sha256)\n        self.signature = signature\n        return signature\n    except Exception as e:\n        print(f\"Signing failed: {e}\")\n        raise\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ECDSA_SHA256Signature.verify","title":"<code>verify(msg)</code>","text":"<p>Verify the ECDSA SHA-256 signature for the provided message.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def verify(self, msg: bytes) -&gt; bool:\n    \"\"\"\n    Verify the ECDSA SHA-256 signature for the provided message.\n    \"\"\"\n    try:\n        verifying_key = VerifyingKey.from_string(self.public_key, curve=SECP256k1)\n        # Use hashlib.sha256 directly as the hash function\n        return verifying_key.verify(self.signature, msg, hashfunc=hashlib.sha256)\n    except Exception as e:\n        print(f\"Verification failed: {e}\")\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ED25519Signature","title":"<code>ED25519Signature</code>","text":"<p>               Bases: <code>Signature</code></p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class ED25519Signature(Signature):\n\n    def __init__(self, signer: URL, publicKey: bytes, signature: bytes, transaction_data: bytes):\n        super().__init__('ed25519', signer, 1)\n        self.publicKey = publicKey\n        self.signature = signature\n        self.timestamp = int(time.time() * 1e6)\n        from accumulate.utils.hash_functions import hash_data\n        self.transactionHash = hash_data(transaction_data).hex()\n\n    def hash(self, message: bytes) -&gt; bytes:\n        \"\"\"Follow JS hashing structure for ED25519.\"\"\"\n        sig_md_hash = hashlib.sha256(self.encode()).digest()\n        final_hash = hashlib.sha256(sig_md_hash + message).digest()\n        return final_hash\n\n    def verify(self, msg: bytes) -&gt; bool:\n        try:\n            vk = ed25519.Ed25519PublicKey.from_public_bytes(self.publicKey)\n            final_hash = self.hash(msg)  # Ensure message is hashed before verification\n            vk.verify(self.signature, final_hash)\n            return True\n        except Exception:\n            return False\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"Convert ED25519 signature to a dictionary.\"\"\"\n        return {\n            \"type\": self.signature_type.lower(),\n            \"publicKey\": self.publicKey.hex(),\n            \"signature\": self.signature.hex(),\n            \"signer\": str(self.signer),\n            \"signerVersion\": self.version,\n            \"timestamp\": self.timestamp,\n            \"transactionHash\": self.transactionHash,\n        }\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ED25519Signature.hash","title":"<code>hash(message)</code>","text":"<p>Follow JS hashing structure for ED25519.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self, message: bytes) -&gt; bytes:\n    \"\"\"Follow JS hashing structure for ED25519.\"\"\"\n    sig_md_hash = hashlib.sha256(self.encode()).digest()\n    final_hash = hashlib.sha256(sig_md_hash + message).digest()\n    return final_hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ED25519Signature.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert ED25519 signature to a dictionary.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert ED25519 signature to a dictionary.\"\"\"\n    return {\n        \"type\": self.signature_type.lower(),\n        \"publicKey\": self.publicKey.hex(),\n        \"signature\": self.signature.hex(),\n        \"signer\": str(self.signer),\n        \"signerVersion\": self.version,\n        \"timestamp\": self.timestamp,\n        \"transactionHash\": self.transactionHash,\n    }\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.EIP712Signature","title":"<code>EIP712Signature</code>","text":"<p>               Bases: <code>Signature</code></p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class EIP712Signature(Signature):\n    def __init__(self, signer: URL, public_key: bytes, signature: bytes, chain_id: int):\n        super().__init__('EIP712', signer, 1)\n        self.public_key = public_key\n        self.signature = signature\n        self.chain_id = chain_id\n\n    def hash(self, data: Dict[str, Any]) -&gt; bytes:\n        \"\"\"Generate EIP-712 compliant hash.\"\"\"\n        encoded_data = self._encode_typed_data(data)\n        return hashlib.sha256(encoded_data).digest()\n\n    def verify(self, data: Dict[str, Any]) -&gt; bool:\n        try:\n            message_hash = self.hash(data)\n            print(f\"Debug: Verifying message_hash={message_hash.hex()}, signature={self.signature.hex()}\")\n\n            eth_key = keys.PublicKey(self.public_key)\n            print(f\"Debug: Using public_key={self.public_key.hex()}\")\n\n            # Perform verification\n            result = eth_key.verify_msg_hash(message_hash, keys.Signature(self.signature))\n            print(f\"Debug: Verification result={result}\")\n            return result\n        except Exception as e: #\n            print(f\"Error during verification: {e}\") #\n            return False #\n\n    @staticmethod\n    def _encode_typed_data(data: Dict[str, Any]) -&gt; bytes:\n        \"\"\"Encode EIP-712 typed data.\"\"\"\n        return b\"\".join(f\"{key}:{value}\".encode() for key, value in data.items())\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.EIP712Signature._encode_typed_data","title":"<code>_encode_typed_data(data)</code>  <code>staticmethod</code>","text":"<p>Encode EIP-712 typed data.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>@staticmethod\ndef _encode_typed_data(data: Dict[str, Any]) -&gt; bytes:\n    \"\"\"Encode EIP-712 typed data.\"\"\"\n    return b\"\".join(f\"{key}:{value}\".encode() for key, value in data.items())\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.EIP712Signature.hash","title":"<code>hash(data)</code>","text":"<p>Generate EIP-712 compliant hash.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self, data: Dict[str, Any]) -&gt; bytes:\n    \"\"\"Generate EIP-712 compliant hash.\"\"\"\n    encoded_data = self._encode_typed_data(data)\n    return hashlib.sha256(encoded_data).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ETHSignature","title":"<code>ETHSignature</code>","text":"<p>               Bases: <code>Signature</code></p> <p>Represents an Ethereum signature.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class ETHSignature(Signature):\n    \"\"\"Represents an Ethereum signature.\"\"\"\n    def __init__(self, signer: URL, public_key: bytes, signature: bytes):\n        super().__init__('ETH', signer)\n        self.public_key = public_key\n        self.signature = signature\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Calculate the Ethereum-specific hash of the public key.\"\"\"\n        return keccak(self.public_key)[-20:]  # Return the last 20 bytes\n\n    def verify(self, message: bytes) -&gt; bool:\n        \"\"\"Verify the Ethereum signature.\"\"\"\n        try:\n            # Hash the message using Ethereum's EIP-191 specification\n            message_hash = keccak(b\"\\x19Ethereum Signed Message:\\n\" + str(len(message)).encode() + message)\n            eth_key = keys.PublicKey(self.public_key)\n\n            # Create a Signature object\n            sig_obj = keys.Signature(self.signature[:64] + bytes([self.signature[64] % 2]))  # Ensure v is 0 or 1\n\n            # Verify the signature\n            return eth_key.verify_msg_hash(message_hash, sig_obj)\n        except Exception as e:\n            print(f\"Error during ETH signature verification: {e}\")\n            return False\n\n    def get_signature(self) -&gt; bytes:\n        \"\"\"Return the raw signature bytes.\"\"\"\n        return self.signature\n\n    def get_public_key(self) -&gt; bytes:\n        \"\"\"Return the public key bytes.\"\"\"\n        return self.public_key\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ETHSignature.get_public_key","title":"<code>get_public_key()</code>","text":"<p>Return the public key bytes.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_public_key(self) -&gt; bytes:\n    \"\"\"Return the public key bytes.\"\"\"\n    return self.public_key\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ETHSignature.get_signature","title":"<code>get_signature()</code>","text":"<p>Return the raw signature bytes.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_signature(self) -&gt; bytes:\n    \"\"\"Return the raw signature bytes.\"\"\"\n    return self.signature\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ETHSignature.hash","title":"<code>hash()</code>","text":"<p>Calculate the Ethereum-specific hash of the public key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Calculate the Ethereum-specific hash of the public key.\"\"\"\n    return keccak(self.public_key)[-20:]  # Return the last 20 bytes\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.ETHSignature.verify","title":"<code>verify(message)</code>","text":"<p>Verify the Ethereum signature.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def verify(self, message: bytes) -&gt; bool:\n    \"\"\"Verify the Ethereum signature.\"\"\"\n    try:\n        # Hash the message using Ethereum's EIP-191 specification\n        message_hash = keccak(b\"\\x19Ethereum Signed Message:\\n\" + str(len(message)).encode() + message)\n        eth_key = keys.PublicKey(self.public_key)\n\n        # Create a Signature object\n        sig_obj = keys.Signature(self.signature[:64] + bytes([self.signature[64] % 2]))  # Ensure v is 0 or 1\n\n        # Verify the signature\n        return eth_key.verify_msg_hash(message_hash, sig_obj)\n    except Exception as e:\n        print(f\"Error during ETH signature verification: {e}\")\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Lite","title":"<code>Lite</code>","text":"<p>Represents a lite account URL and associated data.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class Lite:\n    \"\"\"\n    Represents a lite account URL and associated data.\n    \"\"\"\n\n    def __init__(self, url: str, bytes_: bytes):\n        self.url = url\n        self.bytes = bytes_\n\n    def __repr__(self):\n        return f\"&lt;Lite url={self.url}, bytes={self.bytes.hex()}&gt;\"\n\n    def get_url(self) -&gt; str:\n        \"\"\"Return the URL of the lite account.\"\"\"\n        return self.url\n\n    def get_bytes(self) -&gt; bytes:\n        \"\"\"Return the raw bytes of the lite account.\"\"\"\n        return self.bytes\n\n    def __str__(self):\n        \"\"\"String representation of the lite account.\"\"\"\n        return self.url\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Lite.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the lite account.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the lite account.\"\"\"\n    return self.url\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Lite.get_bytes","title":"<code>get_bytes()</code>","text":"<p>Return the raw bytes of the lite account.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_bytes(self) -&gt; bytes:\n    \"\"\"Return the raw bytes of the lite account.\"\"\"\n    return self.bytes\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Lite.get_url","title":"<code>get_url()</code>","text":"<p>Return the URL of the lite account.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_url(self) -&gt; str:\n    \"\"\"Return the URL of the lite account.\"\"\"\n    return self.url\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PrivateKey","title":"<code>PrivateKey</code>","text":"<p>Represents a private key and its associated public key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class PrivateKey:\n    \"\"\"\n    Represents a private key and its associated public key.\n    \"\"\"\n    def __init__(self, key: bytes, type_: str, public_key: Optional[bytes] = None):\n        \"\"\"\n        Initialize a PrivateKey instance.\n\n        :param key: The private key bytes.\n        :param type_: The type of the private key (e.g., ED25519, ECDSA).\n        :param public_key: The optional public key bytes.\n        \"\"\"\n        self.key = key\n        self.type = type_\n        self.public_key = PublicKey(public_key, type_) if public_key else None\n\n    def __repr__(self):\n        return f\"&lt;PrivateKey type={self.type}, key={self.key.hex()}&gt;\"\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"type\": self.type,\n            \"key\": self.key.hex(),\n            \"public_key\": self.public_key.to_dict() if self.public_key else None,\n        }\n\n    def get_type(self) -&gt; str:\n        \"\"\"\n        Get the type of the private key.\n        \"\"\"\n        return self.type\n\n    def get_private_key(self) -&gt; Tuple[bytes, bool]:\n        \"\"\"\n        Get the raw private key bytes.\n\n        :return: A tuple containing the private key bytes and a boolean indicating success.\n        \"\"\"\n        return self.key, True\n\n    def get_public_key(self) -&gt; Optional[PublicKey]:\n        \"\"\"\n        Get the associated public key.\n\n        :return: The associated PublicKey instance or None if not set.\n        \"\"\"\n        return self.public_key\n\n    def __str__(self):\n        \"\"\"\n        Format the private key as a string representation.\n        \"\"\"\n        return binascii.hexlify(self.key).decode()\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PrivateKey.__init__","title":"<code>__init__(key, type_, public_key=None)</code>","text":"<p>Initialize a PrivateKey instance.</p> <p>:param key: The private key bytes. :param type_: The type of the private key (e.g., ED25519, ECDSA). :param public_key: The optional public key bytes.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def __init__(self, key: bytes, type_: str, public_key: Optional[bytes] = None):\n    \"\"\"\n    Initialize a PrivateKey instance.\n\n    :param key: The private key bytes.\n    :param type_: The type of the private key (e.g., ED25519, ECDSA).\n    :param public_key: The optional public key bytes.\n    \"\"\"\n    self.key = key\n    self.type = type_\n    self.public_key = PublicKey(public_key, type_) if public_key else None\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PrivateKey.__str__","title":"<code>__str__()</code>","text":"<p>Format the private key as a string representation.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Format the private key as a string representation.\n    \"\"\"\n    return binascii.hexlify(self.key).decode()\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PrivateKey.get_private_key","title":"<code>get_private_key()</code>","text":"<p>Get the raw private key bytes.</p> <p>:return: A tuple containing the private key bytes and a boolean indicating success.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_private_key(self) -&gt; Tuple[bytes, bool]:\n    \"\"\"\n    Get the raw private key bytes.\n\n    :return: A tuple containing the private key bytes and a boolean indicating success.\n    \"\"\"\n    return self.key, True\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PrivateKey.get_public_key","title":"<code>get_public_key()</code>","text":"<p>Get the associated public key.</p> <p>:return: The associated PublicKey instance or None if not set.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_public_key(self) -&gt; Optional[PublicKey]:\n    \"\"\"\n    Get the associated public key.\n\n    :return: The associated PublicKey instance or None if not set.\n    \"\"\"\n    return self.public_key\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PrivateKey.get_type","title":"<code>get_type()</code>","text":"<p>Get the type of the private key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"\n    Get the type of the private key.\n    \"\"\"\n    return self.type\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKey","title":"<code>PublicKey</code>","text":"<p>Represents a public key and provides methods for its operations.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class PublicKey:\n    \"\"\"\n    Represents a public key and provides methods for its operations.\n    \"\"\"\n    def __init__(self, key: bytes, type_: str):\n        \"\"\"\n        Initialize a PublicKey instance.\n\n        :param key: The public key bytes.\n        :param type_: The type of the public key (e.g., ED25519, ECDSA).\n        \"\"\"\n        self.key = key\n        self.type = type_\n\n    def __repr__(self):\n        return f\"&lt;PublicKey type={self.type}, key={self.key.hex()}&gt;\"\n\n    def get_type(self) -&gt; str:\n        \"\"\"\n        Get the type of the public key.\n        \"\"\"\n        return self.type\n\n    def get_public_key(self) -&gt; Tuple[bytes, bool]:\n        \"\"\"\n        Get the raw public key bytes.\n\n        :return: A tuple containing the public key bytes and a boolean indicating success.\n        \"\"\"\n        return self.key, True\n\n    def get_public_key_hash(self) -&gt; Tuple[bytes, bool]:\n        \"\"\"\n        Get the hash of the public key.\n\n        :return: A tuple containing the hashed public key bytes and a boolean indicating success.\n        \"\"\"\n        try:\n            return hashlib.sha256(self.key).digest(), True\n        except Exception:\n            return b\"\", False\n\n    def __str__(self):\n        \"\"\"\n        Format the public key as a string.\n        \"\"\"\n        pub_key_hash, success = self.get_public_key_hash()\n        return binascii.hexlify(pub_key_hash).decode() if success else \"&lt;invalid address&gt;\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKey.__init__","title":"<code>__init__(key, type_)</code>","text":"<p>Initialize a PublicKey instance.</p> <p>:param key: The public key bytes. :param type_: The type of the public key (e.g., ED25519, ECDSA).</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def __init__(self, key: bytes, type_: str):\n    \"\"\"\n    Initialize a PublicKey instance.\n\n    :param key: The public key bytes.\n    :param type_: The type of the public key (e.g., ED25519, ECDSA).\n    \"\"\"\n    self.key = key\n    self.type = type_\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKey.__str__","title":"<code>__str__()</code>","text":"<p>Format the public key as a string.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    Format the public key as a string.\n    \"\"\"\n    pub_key_hash, success = self.get_public_key_hash()\n    return binascii.hexlify(pub_key_hash).decode() if success else \"&lt;invalid address&gt;\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKey.get_public_key","title":"<code>get_public_key()</code>","text":"<p>Get the raw public key bytes.</p> <p>:return: A tuple containing the public key bytes and a boolean indicating success.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_public_key(self) -&gt; Tuple[bytes, bool]:\n    \"\"\"\n    Get the raw public key bytes.\n\n    :return: A tuple containing the public key bytes and a boolean indicating success.\n    \"\"\"\n    return self.key, True\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKey.get_public_key_hash","title":"<code>get_public_key_hash()</code>","text":"<p>Get the hash of the public key.</p> <p>:return: A tuple containing the hashed public key bytes and a boolean indicating success.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_public_key_hash(self) -&gt; Tuple[bytes, bool]:\n    \"\"\"\n    Get the hash of the public key.\n\n    :return: A tuple containing the hashed public key bytes and a boolean indicating success.\n    \"\"\"\n    try:\n        return hashlib.sha256(self.key).digest(), True\n    except Exception:\n        return b\"\", False\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKey.get_type","title":"<code>get_type()</code>","text":"<p>Get the type of the public key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"\n    Get the type of the public key.\n    \"\"\"\n    return self.type\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKeyHash","title":"<code>PublicKeyHash</code>","text":"<p>Represents a hash derived from a public key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class PublicKeyHash:\n    \"\"\"\n    Represents a hash derived from a public key.\n    \"\"\"\n\n    def __init__(self, type_: str, hash_: bytes):\n        self.type = type_\n        self.hash = hash_\n\n    def to_dict(self) -&gt; dict:\n        return {\"type\": self.type, \"hash\": self.hash.hex()}\n\n    def __repr__(self):\n        return f\"&lt;PublicKeyHash type={self.type}, hash={self.hash.hex()}&gt;\"\n\n    def get_type(self) -&gt; str:\n        \"\"\"Return the type of the public key hash.\"\"\"\n        return self.type\n\n    def get_public_key_hash(self) -&gt; bytes:\n        \"\"\"Return the hash of the public key.\"\"\"\n        return self.hash\n\n    def __str__(self):\n        \"\"\"String representation of the address.\"\"\"\n        return f\"{self.type}:{self.hash.hex()}\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKeyHash.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the address.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def __str__(self):\n    \"\"\"String representation of the address.\"\"\"\n    return f\"{self.type}:{self.hash.hex()}\"\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKeyHash.get_public_key_hash","title":"<code>get_public_key_hash()</code>","text":"<p>Return the hash of the public key.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_public_key_hash(self) -&gt; bytes:\n    \"\"\"Return the hash of the public key.\"\"\"\n    return self.hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.PublicKeyHash.get_type","title":"<code>get_type()</code>","text":"<p>Return the type of the public key hash.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def get_type(self) -&gt; str:\n    \"\"\"Return the type of the public key hash.\"\"\"\n    return self.type\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.RCD1Signature","title":"<code>RCD1Signature</code>","text":"<p>               Bases: <code>Signature</code></p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class RCD1Signature(Signature):\n    def __init__(self, signer: URL, public_key: bytes, signature: bytes, timestamp: int):\n        super().__init__('RCD1', signer)\n        self.public_key = public_key\n        self.signature = signature\n        self.timestamp = timestamp\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Calculate RCD1-specific hash.\"\"\"\n        return do_sha256(self.public_key, str(self.timestamp).encode())\n\n    def verify(self, msg: bytes) -&gt; bool:\n        \"\"\"Verify the signature using ED25519.\"\"\"\n        try:\n            vk = VerifyingKey.from_string(self.public_key, curve=SECP256k1)\n            return vk.verify(self.signature, msg)\n        except Exception:\n            return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.RCD1Signature.hash","title":"<code>hash()</code>","text":"<p>Calculate RCD1-specific hash.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Calculate RCD1-specific hash.\"\"\"\n    return do_sha256(self.public_key, str(self.timestamp).encode())\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.RCD1Signature.verify","title":"<code>verify(msg)</code>","text":"<p>Verify the signature using ED25519.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def verify(self, msg: bytes) -&gt; bool:\n    \"\"\"Verify the signature using ED25519.\"\"\"\n    try:\n        vk = VerifyingKey.from_string(self.public_key, curve=SECP256k1)\n        return vk.verify(self.signature, msg)\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Signature","title":"<code>Signature</code>","text":"<p>Base class for managing all signature types.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class Signature:\n    \"\"\"Base class for managing all signature types.\"\"\"\n    def __init__(self, signature_type: str, signer: Optional[URL] = None, version: int = 1):\n        self.signature_type = signature_type\n        self.signer = signer\n        self.version = version\n        self.signature = None\n\n    def get_url(self) -&gt; Optional[URL]:\n        return self.signer\n\n    def get_version(self) -&gt; int:\n        return self.version\n\n    def get_signature(self) -&gt; Optional[bytes]:\n        return self.signature\n\n    def hash(self, message: bytes) -&gt; bytes:\n        \"\"\"Follow JS hashing structure: First hash signature metadata, then concatenate and hash with message.\"\"\"\n        sig_md_hash = hashlib.sha256(self.encode()).digest()\n        final_hash = hashlib.sha256(sig_md_hash + message).digest()\n        return final_hash\n\n    def encode(self) -&gt; bytes:\n        \"\"\"Serialize signature metadata for consistent hashing.\"\"\"\n        signer_bytes = str(self.signer).encode() if self.signer else b\"\"\n        return self.signature_type.encode() + signer_bytes + str(self.version).encode()\n\n\n    def verify(self, msg: bytes) -&gt; bool:\n        raise NotImplementedError(\"Subclasses should implement this method.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Signature.encode","title":"<code>encode()</code>","text":"<p>Serialize signature metadata for consistent hashing.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def encode(self) -&gt; bytes:\n    \"\"\"Serialize signature metadata for consistent hashing.\"\"\"\n    signer_bytes = str(self.signer).encode() if self.signer else b\"\"\n    return self.signature_type.encode() + signer_bytes + str(self.version).encode()\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.Signature.hash","title":"<code>hash(message)</code>","text":"<p>Follow JS hashing structure: First hash signature metadata, then concatenate and hash with message.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self, message: bytes) -&gt; bytes:\n    \"\"\"Follow JS hashing structure: First hash signature metadata, then concatenate and hash with message.\"\"\"\n    sig_md_hash = hashlib.sha256(self.encode()).digest()\n    final_hash = hashlib.sha256(sig_md_hash + message).digest()\n    return final_hash\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.SignatureFactory","title":"<code>SignatureFactory</code>","text":"<p>Factory to create signatures based on type.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class SignatureFactory:\n    \"\"\"Factory to create signatures based on type.\"\"\"\n    @staticmethod\n    def create_signature(sig_type: str, **kwargs) -&gt; Optional[Signature]:\n        if sig_type == \"LegacyED25519\":\n            # Pass only the required arguments\n            required_args = {k: kwargs[k] for k in [\"signer\", \"public_key\", \"signature\", \"timestamp\"] if k in kwargs}\n            return LegacyED25519Signature(**required_args)\n        elif sig_type == \"TypedData\":\n            required_args = {k: kwargs[k] for k in [\"signer\", \"public_key\", \"signature\", \"chain_id\", \"memo\", \"data\"] if k in kwargs}\n            return TypedDataSignature(**required_args)\n        elif sig_type == \"RCD1\":\n            required_args = {k: kwargs[k] for k in [\"signer\", \"public_key\", \"signature\", \"timestamp\"] if k in kwargs}\n            return RCD1Signature(**required_args)\n        elif sig_type == \"BTC\":\n            required_args = {k: kwargs[k] for k in [\"signer\", \"public_key\", \"signature\"] if k in kwargs}\n            return BTCSignature(**required_args)\n        elif sig_type == \"DelegatedSignature\":\n            required_args = {k: kwargs[k] for k in [\"signature\", \"delegator\"] if k in kwargs}\n            return DelegatedSignature(**required_args)\n        elif sig_type == \"AuthoritySignature\":\n            required_args = {k: kwargs[k] for k in [\"origin\", \"authority\", \"vote\", \"txid\"] if k in kwargs}\n            return AuthoritySignature(**required_args)\n        else:\n            raise ValueError(f\"Unsupported signature type: {sig_type}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.TypedDataSignature","title":"<code>TypedDataSignature</code>","text":"<p>               Bases: <code>Signature</code></p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>class TypedDataSignature(Signature):\n    def __init__(\n        self,\n        signer: Optional[URL],\n        public_key: bytes,\n        signature: bytes,\n        chain_id: int,\n        memo: Optional[str] = None,\n        data: Optional[bytes] = None,\n    ):\n        super().__init__('TypedData', signer)\n        self.public_key = public_key\n        self.signature = signature\n        self.chain_id = chain_id\n        self.memo = memo\n        self.data = data\n\n    def hash(self, data: Dict[str, Any]) -&gt; bytes:\n        \"\"\"Generate EIP-712 compliant hash.\"\"\"\n        encoded_data = self._encode_typed_data(data)\n        return hashlib.sha256(encoded_data).digest()\n\n    def verify(self, data: Dict[str, Any]) -&gt; bool:\n        try: #\n            message_hash = self.hash(data)\n            eth_key = keys.PublicKey(self.public_key)\n            return eth_key.verify_msg_hash(message_hash, keys.Signature(self.signature))\n        except Exception:\n            return False\n\n    @staticmethod\n    def _encode_typed_data(data: Dict[str, Any]) -&gt; bytes:\n        \"\"\"Encode EIP-712 typed data.\"\"\"\n        return b\"\".join(f\"{key}:{value}\".encode() for key, value in data.items())\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.TypedDataSignature._encode_typed_data","title":"<code>_encode_typed_data(data)</code>  <code>staticmethod</code>","text":"<p>Encode EIP-712 typed data.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>@staticmethod\ndef _encode_typed_data(data: Dict[str, Any]) -&gt; bytes:\n    \"\"\"Encode EIP-712 typed data.\"\"\"\n    return b\"\".join(f\"{key}:{value}\".encode() for key, value in data.items())\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.TypedDataSignature.hash","title":"<code>hash(data)</code>","text":"<p>Generate EIP-712 compliant hash.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def hash(self, data: Dict[str, Any]) -&gt; bytes:\n    \"\"\"Generate EIP-712 compliant hash.\"\"\"\n    encoded_data = self._encode_typed_data(data)\n    return hashlib.sha256(encoded_data).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.do_btc_hash","title":"<code>do_btc_hash(pub_key)</code>","text":"<p>Calculate the Bitcoin hash (RIPEMD160(SHA256(pub_key))).</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def do_btc_hash(pub_key: bytes) -&gt; bytes:\n    \"\"\"Calculate the Bitcoin hash (RIPEMD160(SHA256(pub_key))).\"\"\"\n    sha256_hash = hashlib.sha256(pub_key).digest()\n    ripemd160 = hashlib.new('ripemd160')\n    ripemd160.update(sha256_hash)\n    return ripemd160.digest() \n</code></pre>"},{"location":"api_reference/#accumulate.models.signatures.do_eth_hash","title":"<code>do_eth_hash(pub_key)</code>","text":"<p>Calculate the Ethereum address hash.</p> Source code in <code>accumulate\\models\\signatures.py</code> <pre><code>def do_eth_hash(pub_key: bytes) -&gt; bytes:\n    \"\"\"Calculate the Ethereum address hash.\"\"\"\n    from eth_utils import keccak\n    return keccak(pub_key)[-20:]\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results","title":"<code>transaction_results</code>","text":""},{"location":"api_reference/#accumulate.models.transaction_results.AddCreditsResult","title":"<code>AddCreditsResult</code>","text":"<p>               Bases: <code>TransactionResult</code></p> <p>Represents the result of an Add Credits transaction.</p> <p>:param amount: The amount of tokens added. :param credits: The number of credits added. :param oracle: The oracle rate used for conversion.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>class AddCreditsResult(TransactionResult):\n    \"\"\"\n    Represents the result of an Add Credits transaction.\n\n    :param amount: The amount of tokens added.\n    :param credits: The number of credits added.\n    :param oracle: The oracle rate used for conversion.\n    \"\"\"\n    def __init__(self, amount: int = 0, credits: int = 0, oracle: int = 0):\n        if amount &lt; 0 or credits &lt; 0 or oracle &lt; 0:\n            raise ValueError(\"Amount, credits, and oracle must be non-negative integers.\")\n        self.amount = amount\n        self.credits = credits\n        self.oracle = oracle\n\n    def copy(self) -&gt; \"AddCreditsResult\":\n        return AddCreditsResult(self.amount, self.credits, self.oracle)\n\n    def equal(self, other: \"AddCreditsResult\") -&gt; bool:\n        return (\n            isinstance(other, AddCreditsResult) and\n            self.amount == other.amount and\n            self.credits == other.credits and\n            self.oracle == other.oracle\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.EmptyResult","title":"<code>EmptyResult</code>","text":"<p>               Bases: <code>TransactionResult</code></p> <p>Represents an empty transaction result.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>class EmptyResult(TransactionResult):\n    \"\"\"\n    Represents an empty transaction result.\n    \"\"\"\n    def copy(self) -&gt; \"EmptyResult\":\n        return EmptyResult()\n\n    def equal(self, other: \"EmptyResult\") -&gt; bool:\n        return isinstance(other, EmptyResult)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.TransactionResult","title":"<code>TransactionResult</code>","text":"<p>Base class for transaction results.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>class TransactionResult:\n    \"\"\"\n    Base class for transaction results.\n    \"\"\"\n    def copy(self) -&gt; \"TransactionResult\":\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def equal(self, other: \"TransactionResult\") -&gt; bool:\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.WriteDataResult","title":"<code>WriteDataResult</code>","text":"<p>               Bases: <code>TransactionResult</code></p> <p>Represents the result of a Write Data transaction.</p> <p>:param entry_hash: The hash of the data entry. :param account_url: The URL of the account associated with the entry. :param account_id: The ID of the account associated with the entry.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>class WriteDataResult(TransactionResult):\n    \"\"\"\n    Represents the result of a Write Data transaction.\n\n    :param entry_hash: The hash of the data entry.\n    :param account_url: The URL of the account associated with the entry.\n    :param account_id: The ID of the account associated with the entry.\n    \"\"\"\n    def __init__(\n        self,\n        entry_hash: bytes = b\"\",\n        account_url: Optional[URL] = None,\n        account_id: Optional[bytes] = None,\n    ):\n        self.entry_hash = entry_hash\n        self.account_url = account_url\n        self.account_id = account_id\n\n    def copy(self) -&gt; \"WriteDataResult\":\n        return WriteDataResult(self.entry_hash, self.account_url, self.account_id)\n\n    def equal(self, other: \"WriteDataResult\") -&gt; bool:\n        return (\n            isinstance(other, WriteDataResult) and\n            self.entry_hash == other.entry_hash and\n            self.account_url == other.account_url and\n            self.account_id == other.account_id\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.copy_transaction_result","title":"<code>copy_transaction_result(result)</code>","text":"<p>Create a copy of the transaction result.</p> <p>:param result: The transaction result to copy. :return: A copy of the transaction result.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>def copy_transaction_result(result: TransactionResult) -&gt; TransactionResult:\n    \"\"\"\n    Create a copy of the transaction result.\n\n    :param result: The transaction result to copy.\n    :return: A copy of the transaction result.\n    \"\"\"\n    return result.copy()\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.deserialize_json","title":"<code>deserialize_json(data)</code>","text":"<p>Deserialize JSON bytes into a dictionary.</p> <p>:param data: JSON bytes. :return: A dictionary representation of the JSON data.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>def deserialize_json(data: bytes) -&gt; Dict[str, Any]:\n    \"\"\"\n    Deserialize JSON bytes into a dictionary.\n\n    :param data: JSON bytes.\n    :return: A dictionary representation of the JSON data.\n    \"\"\"\n    import json\n    return json.loads(data)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.equal_transaction_result","title":"<code>equal_transaction_result(a, b)</code>","text":"<p>Compare two transaction results for equality.</p> <p>:param a: The first transaction result. :param b: The second transaction result. :return: True if they are equal, False otherwise.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>def equal_transaction_result(a: TransactionResult, b: TransactionResult) -&gt; bool:\n    \"\"\"\n    Compare two transaction results for equality.\n\n    :param a: The first transaction result.\n    :param b: The second transaction result.\n    :return: True if they are equal, False otherwise.\n    \"\"\"\n    return a.equal(b)\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.new_transaction_result","title":"<code>new_transaction_result(typ)</code>","text":"<p>Factory method to create a new transaction result based on the type.</p> <p>:param typ: The transaction type. :return: A new instance of the appropriate TransactionResult subclass.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>def new_transaction_result(typ: str) -&gt; TransactionResult:\n    \"\"\"\n    Factory method to create a new transaction result based on the type.\n\n    :param typ: The transaction type.\n    :return: A new instance of the appropriate TransactionResult subclass.\n    \"\"\"\n    if typ == \"WriteDataResult\":\n        return WriteDataResult()\n    elif typ == \"AddCreditsResult\":\n        return AddCreditsResult()\n    elif typ == \"EmptyResult\":\n        return EmptyResult()\n    raise ValueError(f\"Unknown transaction result type: {typ}\")\n</code></pre>"},{"location":"api_reference/#accumulate.models.transaction_results.unmarshal_transaction_result","title":"<code>unmarshal_transaction_result(data)</code>","text":"<p>Deserialize a transaction result from raw data or JSON.</p> <p>:param data: Raw bytes or JSON object containing the transaction result. :return: The deserialized TransactionResult.</p> Source code in <code>accumulate\\models\\transaction_results.py</code> <pre><code>def unmarshal_transaction_result(data: Union[bytes, Dict[str, Any]]) -&gt; TransactionResult:\n    \"\"\"\n    Deserialize a transaction result from raw data or JSON.\n\n    :param data: Raw bytes or JSON object containing the transaction result.\n    :return: The deserialized TransactionResult.\n    \"\"\"\n    if isinstance(data, bytes):\n        data = deserialize_json(data)\n\n    result_type = data.get(\"Type\")\n    if not result_type:\n        raise ValueError(\"Missing transaction result type in data\")\n\n    result = new_transaction_result(result_type)\n\n    # Deserialize fields and handle bytes explicitly\n    for key, value in data.items():\n        if key.lower() == \"entry_hash\" or key.lower() == \"account_id\":\n            # Convert hex strings back to bytes\n            setattr(result, key.lower(), bytes.fromhex(value) if isinstance(value, str) else value)\n        elif key.lower() == \"account_url\" and isinstance(value, str):\n            # Convert string to URL object\n            setattr(result, key.lower(), URL.parse(value))\n        else:\n            setattr(result, key.lower(), value)\n\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid","title":"<code>txid</code>","text":""},{"location":"api_reference/#accumulate.models.txid.TxID","title":"<code>TxID</code>","text":"<p>Represents a transaction ID.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>class TxID:\n    \"\"\"Represents a transaction ID.\"\"\"\n\n    def __init__(self, url: URL, tx_hash: bytes):\n        if not isinstance(url, URL):\n            raise ValueError(\"TxID must be initialized with a URL instance.\")\n        if not isinstance(tx_hash, bytes) or len(tx_hash) != 32:\n            raise ValueError(\"Transaction hash must be a 32-byte value.\")\n        self.url = url\n        self.tx_hash = tx_hash\n        self._str_cache = None\n\n    @staticmethod\n    def parse(txid_str: str) -&gt; \"TxID\":\n        \"\"\"\n        Parse a TxID string into a TxID object.\n        \"\"\"\n        print(f\"Parsing TxID string: {txid_str}\")  # Debugging input\n        url = URL.parse(txid_str)\n\n        # Validate that '@' is present in the original string\n        if \"@\" not in txid_str:\n            raise ValueError(f\"Invalid TxID structure: '{txid_str}'. Must contain '@' separating hash and authority.\")\n\n        # Validate presence of user_info (TxHash)\n        if not url.user_info:\n            raise MissingHashError(f\"TxID missing hash: {txid_str}\")\n\n        try:\n            tx_hash = bytes.fromhex(url.user_info)\n            if len(tx_hash) != 32:\n                raise InvalidHashError(f\"Transaction hash must be 32 bytes: {url.user_info}\")\n        except ValueError as e:\n            raise InvalidHashError(f\"Invalid transaction hash format: {url.user_info}. Error: {e}\")\n\n        # Clean URL (remove TxHash from user_info)\n        clean_url = url.with_user_info(\"\")\n        return TxID(clean_url, tx_hash)\n\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return the string representation of the TxID.\n        \"\"\"\n        if self._str_cache is None:\n            # Combine URL and hash as required\n            self._str_cache = f\"{str(self.url)}@{self.tx_hash.hex()}\"\n        print(f\"String representation of TxID: {self._str_cache}\")  # Debugging\n        return self._str_cache\n\n    def compare(self, other: \"TxID\") -&gt; int:\n        print(f\"Comparing TxIDs: {self} vs {other}\")  # Debugging\n        if not isinstance(other, TxID):\n            raise ValueError(\"Comparison must be between two TxIDs\")\n        if self.tx_hash != other.tx_hash:\n            return (self.tx_hash &gt; other.tx_hash) - (self.tx_hash &lt; other.tx_hash)\n        return (str(self.url) &gt; str(other.url)) - (str(self.url) &lt; str(other.url))  # Updated comparison\n\n\n    def as_url(self) -&gt; URL:\n        \"\"\"\n        Construct a URL representation of the TxID.\n        \"\"\"\n        return self.url.with_user_info(self.tx_hash.hex())\n\n    def account(self) -&gt; URL:\n        \"\"\"Get the account URL associated with the TxID.\"\"\"\n        return self.url\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Equality operator.\"\"\"\n        return isinstance(other, TxID) and self.tx_hash == other.tx_hash and self.url == other.url\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Hash operator.\"\"\"\n        return hash((str(self.url), self.tx_hash))\n\n    def json(self) -&gt; str:\n        \"\"\"\n        Serialize the TxID to a JSON string.\n        \"\"\"\n        return json.dumps({\"url\": str(self.url), \"hash\": self.tx_hash.hex()})\n\n    @classmethod\n    def from_json(cls, json_str: str) -&gt; \"TxID\":\n        \"\"\"\n        Deserialize a JSON string into a TxID instance.\n        \"\"\"\n        data = json.loads(json_str)\n        url = URL.parse(data[\"url\"])\n        tx_hash = bytes.fromhex(data[\"hash\"])\n        return cls(url, tx_hash)\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality operator.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Equality operator.\"\"\"\n    return isinstance(other, TxID) and self.tx_hash == other.tx_hash and self.url == other.url\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash operator.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Hash operator.\"\"\"\n    return hash((str(self.url), self.tx_hash))\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.__str__","title":"<code>__str__()</code>","text":"<p>Return the string representation of the TxID.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return the string representation of the TxID.\n    \"\"\"\n    if self._str_cache is None:\n        # Combine URL and hash as required\n        self._str_cache = f\"{str(self.url)}@{self.tx_hash.hex()}\"\n    print(f\"String representation of TxID: {self._str_cache}\")  # Debugging\n    return self._str_cache\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.account","title":"<code>account()</code>","text":"<p>Get the account URL associated with the TxID.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>def account(self) -&gt; URL:\n    \"\"\"Get the account URL associated with the TxID.\"\"\"\n    return self.url\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.as_url","title":"<code>as_url()</code>","text":"<p>Construct a URL representation of the TxID.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>def as_url(self) -&gt; URL:\n    \"\"\"\n    Construct a URL representation of the TxID.\n    \"\"\"\n    return self.url.with_user_info(self.tx_hash.hex())\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.from_json","title":"<code>from_json(json_str)</code>  <code>classmethod</code>","text":"<p>Deserialize a JSON string into a TxID instance.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>@classmethod\ndef from_json(cls, json_str: str) -&gt; \"TxID\":\n    \"\"\"\n    Deserialize a JSON string into a TxID instance.\n    \"\"\"\n    data = json.loads(json_str)\n    url = URL.parse(data[\"url\"])\n    tx_hash = bytes.fromhex(data[\"hash\"])\n    return cls(url, tx_hash)\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.json","title":"<code>json()</code>","text":"<p>Serialize the TxID to a JSON string.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>def json(self) -&gt; str:\n    \"\"\"\n    Serialize the TxID to a JSON string.\n    \"\"\"\n    return json.dumps({\"url\": str(self.url), \"hash\": self.tx_hash.hex()})\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid.TxID.parse","title":"<code>parse(txid_str)</code>  <code>staticmethod</code>","text":"<p>Parse a TxID string into a TxID object.</p> Source code in <code>accumulate\\models\\txid.py</code> <pre><code>@staticmethod\ndef parse(txid_str: str) -&gt; \"TxID\":\n    \"\"\"\n    Parse a TxID string into a TxID object.\n    \"\"\"\n    print(f\"Parsing TxID string: {txid_str}\")  # Debugging input\n    url = URL.parse(txid_str)\n\n    # Validate that '@' is present in the original string\n    if \"@\" not in txid_str:\n        raise ValueError(f\"Invalid TxID structure: '{txid_str}'. Must contain '@' separating hash and authority.\")\n\n    # Validate presence of user_info (TxHash)\n    if not url.user_info:\n        raise MissingHashError(f\"TxID missing hash: {txid_str}\")\n\n    try:\n        tx_hash = bytes.fromhex(url.user_info)\n        if len(tx_hash) != 32:\n            raise InvalidHashError(f\"Transaction hash must be 32 bytes: {url.user_info}\")\n    except ValueError as e:\n        raise InvalidHashError(f\"Invalid transaction hash format: {url.user_info}. Error: {e}\")\n\n    # Clean URL (remove TxHash from user_info)\n    clean_url = url.with_user_info(\"\")\n    return TxID(clean_url, tx_hash)\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid_set","title":"<code>txid_set</code>","text":""},{"location":"api_reference/#accumulate.models.txid_set.TxIdSet","title":"<code>TxIdSet</code>","text":"Source code in <code>accumulate\\models\\txid_set.py</code> <pre><code>class TxIdSet:\n    def __init__(self):\n        self.entries: List[TxID] = []\n\n    def add(self, txid: TxID):\n        \"\"\"\n        Add a transaction ID to the set using a sorted insertion.\n        \"\"\"\n        for i, entry in enumerate(self.entries):\n            comparison = txid.compare(entry)\n            if comparison == 0:  # Already exists\n                return\n            elif comparison &lt; 0:  # Insert before\n                self.entries.insert(i, txid)\n                return\n        # Add to the end if no earlier position was found\n        self.entries.append(txid)\n\n    def remove(self, txid: TxID):\n        \"\"\"\n        Remove a transaction ID from the set if it exists.\n        \"\"\"\n        for i, entry in enumerate(self.entries):\n            if txid.compare(entry) == 0:\n                del self.entries[i]\n                return\n\n    def contains_hash(self, hash_: bytes) -&gt; bool:\n        \"\"\"\n        Check if a transaction ID with the given hash exists in the set.\n        \"\"\"\n        for entry in self.entries:\n            if entry.tx_hash == hash_:  # Compare directly with the tx_hash attribute\n                return True\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid_set.TxIdSet.add","title":"<code>add(txid)</code>","text":"<p>Add a transaction ID to the set using a sorted insertion.</p> Source code in <code>accumulate\\models\\txid_set.py</code> <pre><code>def add(self, txid: TxID):\n    \"\"\"\n    Add a transaction ID to the set using a sorted insertion.\n    \"\"\"\n    for i, entry in enumerate(self.entries):\n        comparison = txid.compare(entry)\n        if comparison == 0:  # Already exists\n            return\n        elif comparison &lt; 0:  # Insert before\n            self.entries.insert(i, txid)\n            return\n    # Add to the end if no earlier position was found\n    self.entries.append(txid)\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid_set.TxIdSet.contains_hash","title":"<code>contains_hash(hash_)</code>","text":"<p>Check if a transaction ID with the given hash exists in the set.</p> Source code in <code>accumulate\\models\\txid_set.py</code> <pre><code>def contains_hash(self, hash_: bytes) -&gt; bool:\n    \"\"\"\n    Check if a transaction ID with the given hash exists in the set.\n    \"\"\"\n    for entry in self.entries:\n        if entry.tx_hash == hash_:  # Compare directly with the tx_hash attribute\n            return True\n    return False\n</code></pre>"},{"location":"api_reference/#accumulate.models.txid_set.TxIdSet.remove","title":"<code>remove(txid)</code>","text":"<p>Remove a transaction ID from the set if it exists.</p> Source code in <code>accumulate\\models\\txid_set.py</code> <pre><code>def remove(self, txid: TxID):\n    \"\"\"\n    Remove a transaction ID from the set if it exists.\n    \"\"\"\n    for i, entry in enumerate(self.entries):\n        if txid.compare(entry) == 0:\n            del self.entries[i]\n            return\n</code></pre>"},{"location":"api_reference/#accumulate.models.types","title":"<code>types</code>","text":""},{"location":"api_reference/#accumulate.models.types.AtomicSlice","title":"<code>AtomicSlice</code>","text":"<p>Thread-safe list management.</p> Source code in <code>accumulate\\models\\types.py</code> <pre><code>class AtomicSlice:\n    \"\"\"Thread-safe list management.\"\"\"\n    def __init__(self):\n        self.items = []\n\n    def add(self, item: Any):\n        self.items.append(item)\n\n    def compare(self, other: List[Any]) -&gt; bool:\n        \"\"\"Compare the items with another list.\"\"\"\n        return self.items == other\n</code></pre>"},{"location":"api_reference/#accumulate.models.types.AtomicSlice.compare","title":"<code>compare(other)</code>","text":"<p>Compare the items with another list.</p> Source code in <code>accumulate\\models\\types.py</code> <pre><code>def compare(self, other: List[Any]) -&gt; bool:\n    \"\"\"Compare the items with another list.\"\"\"\n    return self.items == other\n</code></pre>"},{"location":"api_reference/#accumulate.models.types.AtomicUint","title":"<code>AtomicUint</code>","text":"<p>Thread-safe atomic counter.</p> Source code in <code>accumulate\\models\\types.py</code> <pre><code>class AtomicUint:\n    \"\"\"Thread-safe atomic counter.\"\"\"\n    def __init__(self, value: int = 0):\n        self.value = value\n\n    def increment(self):\n        self.value += 1\n\n    def store(self, value: int):\n        self.value = value\n\n    def load(self) -&gt; int:\n        return self.value\n</code></pre>"},{"location":"api_reference/#utils","title":"Utils","text":""},{"location":"api_reference/#accumulate.utils.conversion","title":"<code>conversion</code>","text":""},{"location":"api_reference/#accumulate.utils.conversion.camel_to_snake","title":"<code>camel_to_snake(name)</code>","text":"<p>Converts camelCase to snake_case.</p> Source code in <code>accumulate\\utils\\conversion.py</code> <pre><code>def camel_to_snake(name: str) -&gt; str:\n    \"\"\"Converts camelCase to snake_case.\"\"\"\n    return re.sub(r'(?&lt;!^)(?=[A-Z])', '_', name).lower()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from","title":"<code>address_from</code>","text":""},{"location":"api_reference/#accumulate.utils.address_from.from_ecdsa_private_key","title":"<code>from_ecdsa_private_key(key)</code>","text":"<p>Create a PrivateKey instance from an ECDSA private key.</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_ecdsa_private_key(key: ec.EllipticCurvePrivateKey) -&gt; PrivateKey:\n    \"\"\"Create a PrivateKey instance from an ECDSA private key.\"\"\"\n    private_key_bytes = key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n    public_key = from_ecdsa_public_key(key.public_key())\n    return PrivateKey(type_=SignatureType.ECDSA_SHA256, key=private_key_bytes, public_key=public_key.key)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_ecdsa_public_key","title":"<code>from_ecdsa_public_key(key)</code>","text":"<p>Create a PublicKey instance from an ECDSA public key.</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_ecdsa_public_key(key: ec.EllipticCurvePublicKey) -&gt; PublicKey:\n    \"\"\"Create a PublicKey instance from an ECDSA public key.\"\"\"\n    key_bytes = key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    )\n    return PublicKey(type_=SignatureType.ECDSA_SHA256, key=key_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_ed25519_private_key","title":"<code>from_ed25519_private_key(key)</code>","text":"<p>Create a PrivateKey instance from an Ed25519 private key (must be 64 bytes).</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_ed25519_private_key(key: bytes) -&gt; PrivateKey:\n    \"\"\"Create a PrivateKey instance from an Ed25519 private key (must be 64 bytes).\"\"\"\n    if len(key) == 32:\n        private_key_bytes = key\n    elif len(key) == 64:\n        private_key_bytes = key[:32]  # Extract first 32 bytes as the actual private key\n    else:\n        raise ValueError(\"Invalid Ed25519 private key length (must be 32 or 64 bytes).\")\n\n    # Generate the public key from the extracted private key\n    private_key = Ed25519PrivateKey.from_private_bytes(private_key_bytes)\n    public_key_bytes = private_key.public_key().public_bytes(\n        encoding=serialization.Encoding.Raw,\n        format=serialization.PublicFormat.Raw\n    )\n\n    return PrivateKey(type_=SignatureType.ED25519, key=private_key_bytes, public_key=public_key_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_ed25519_public_key","title":"<code>from_ed25519_public_key(key)</code>","text":"<p>Create a PublicKey instance from an Ed25519 public key (must be 32 bytes).</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_ed25519_public_key(key: bytes) -&gt; PublicKey:\n    \"\"\"Create a PublicKey instance from an Ed25519 public key (must be 32 bytes).\"\"\"\n    if len(key) != 32:\n        raise ValueError(\"Invalid Ed25519 public key length (must be 32 bytes).\")\n    return PublicKey(type_=SignatureType.ED25519, key=key)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_eth_private_key","title":"<code>from_eth_private_key(key)</code>","text":"<p>Create a PrivateKey instance from an Ethereum private key.</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_eth_private_key(key: bytes) -&gt; PrivateKey:\n    \"\"\"Create a PrivateKey instance from an Ethereum private key.\"\"\"\n    eth_key = eth_keys.PrivateKey(key)\n    public_key_bytes = eth_key.public_key.to_bytes()\n    return PrivateKey(type_=SignatureType.ECDSA_SHA256, key=key, public_key=public_key_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_private_key_bytes","title":"<code>from_private_key_bytes(key, signature_type)</code>","text":"<p>Create a PrivateKey instance from raw private key bytes.</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_private_key_bytes(key: bytes, signature_type: SignatureType) -&gt; PrivateKey:\n    \"\"\"Create a PrivateKey instance from raw private key bytes.\"\"\"\n    if signature_type == SignatureType.ED25519:\n        if len(key) not in {32, 64}:\n            raise ValueError(\"Ed25519 key must be 32 or 64 bytes.\")\n        return from_ed25519_private_key(key)\n\n    elif signature_type == SignatureType.RSA_SHA256:\n        private_key = serialization.load_pem_private_key(key, password=None)\n        if not isinstance(private_key, rsa.RSAPrivateKey):\n            raise ValueError(\"Provided key is not an RSA private key.\")\n        return from_rsa_private_key(private_key)\n\n    elif signature_type == SignatureType.ECDSA_SHA256:\n        private_key = serialization.load_pem_private_key(key, password=None)\n        if not isinstance(private_key, ec.EllipticCurvePrivateKey):\n            raise ValueError(\"Provided key is not an ECDSA private key.\")\n        return from_ecdsa_private_key(private_key)\n\n    elif signature_type in {SignatureType.BTC, SignatureType.ETH, SignatureType.BTC_LEGACY}:\n        return from_eth_private_key(key)\n\n    else:\n        raise ValueError(f\"Unsupported signature type: {signature_type}\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_rsa_private_key","title":"<code>from_rsa_private_key(key)</code>","text":"<p>Create a PrivateKey instance from an RSA private key.</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_rsa_private_key(key: rsa.RSAPrivateKey) -&gt; PrivateKey:\n    \"\"\"Create a PrivateKey instance from an RSA private key.\"\"\"\n    private_key_bytes = key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.PKCS8,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n    public_key = from_rsa_public_key(key.public_key())\n    return PrivateKey(type_=SignatureType.RSA_SHA256, key=private_key_bytes, public_key=public_key.key)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.from_rsa_public_key","title":"<code>from_rsa_public_key(key)</code>","text":"<p>Create a PublicKey instance from an RSA public key.</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def from_rsa_public_key(key: rsa.RSAPublicKey) -&gt; PublicKey:\n    \"\"\"Create a PublicKey instance from an RSA public key.\"\"\"\n    key_bytes = key.public_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PublicFormat.SubjectPublicKeyInfo\n    )\n    return PublicKey(type_=SignatureType.RSA_SHA256, key=key_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_from.generate_ed25519_keypair","title":"<code>generate_ed25519_keypair()</code>","text":"<p>Generate an Ed25519 keypair that matches TweetNaCl (64-byte private key, 32-byte public key).</p> Source code in <code>accumulate\\utils\\address_from.py</code> <pre><code>def generate_ed25519_keypair():\n    \"\"\"Generate an Ed25519 keypair that matches TweetNaCl (64-byte private key, 32-byte public key).\"\"\"\n    private_key = Ed25519PrivateKey.generate()\n\n    # Extract private key bytes (32 bytes)\n    private_key_bytes = private_key.private_bytes(\n        encoding=serialization.Encoding.Raw,\n        format=serialization.PrivateFormat.Raw,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n\n    # Extract public key bytes (32 bytes)\n    public_key_bytes = private_key.public_key().public_bytes(\n        encoding=serialization.Encoding.Raw,\n        format=serialization.PublicFormat.Raw\n    )\n\n    # Concatenate private key + public key to create a 64-byte private key\n    private_key_64 = private_key_bytes + public_key_bytes\n\n    return private_key_64, public_key_bytes\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding","title":"<code>encoding</code>","text":""},{"location":"api_reference/#accumulate.utils.encoding.consume","title":"<code>consume(target, consumer)</code>","text":"<p>Extracts fields from an object and applies the consumer function to each field Mirrors the JS <code>consume()</code> function</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def consume(target: dict, consumer: callable):\n    \"\"\"\n    Extracts fields from an object and applies the consumer function to each field\n    Mirrors the JS `consume()` function\n    \"\"\"\n    if not isinstance(target, dict):\n        raise TypeError(\"consume() expects a dictionary as input\")\n\n    for field_num, (key, value) in enumerate(target.items(), start=1):\n        consumer(field_num, value)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.decode_uvarint","title":"<code>decode_uvarint(buf)</code>","text":"<p>Decodes an unsigned integer from a bytes object using varint encoding</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def decode_uvarint(buf: bytes) -&gt; tuple[int, int]:\n    \"\"\"Decodes an unsigned integer from a bytes object using varint encoding\"\"\"\n    x = 0\n    shift = 0\n    for i, b in enumerate(buf):\n        x |= (b &amp; 0x7F) &lt;&lt; shift\n        if b &lt; 0x80:\n            return x, i + 1\n        shift += 7\n    return 0, 0\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.encode","title":"<code>encode(target)</code>","text":"<p>Python equivalent of the JS encode() function Encodes an object into a binary format using uvarint encoding.</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def encode(target: dict) -&gt; bytes:\n    \"\"\"\n    Python equivalent of the JS encode() function\n    Encodes an object into a binary format using uvarint encoding.\n    \"\"\"\n    if not isinstance(target, dict):\n        raise TypeError(\"encode() expects a dictionary as input\")\n\n    parts = bytearray()\n\n    # Iterate through fields and encode each one\n    for field_num, (key, value) in enumerate(target.items(), start=1):\n        field_number_encoded = encode_uvarint(field_num)\n        value_encoded = encode_value(value)\n\n        parts.extend(field_number_encoded)  # Field number\n        parts.extend(value_encoded)         # Encoded value\n\n    return bytes(parts)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.encode_compact_int","title":"<code>encode_compact_int(value)</code>","text":"<p>Encodes an integer in compact form: a one\u2011byte length followed by the big\u2011endian bytes</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def encode_compact_int(value: int) -&gt; bytes:\n    \"\"\"Encodes an integer in compact form: a one\u2011byte length followed by the big\u2011endian bytes\"\"\"\n    if value == 0:\n        return b'\\x00'\n    num_bytes = (value.bit_length() + 7) // 8\n    result = bytes([num_bytes]) + value.to_bytes(num_bytes, byteorder='big')\n    logger.debug(f\"encode_compact_int: {result.hex()}\")\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.encode_uvarint","title":"<code>encode_uvarint(x)</code>","text":"<p>Encodes an unsigned integer using varint encoding.</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def encode_uvarint(x: int) -&gt; bytes:\n    \"\"\"Encodes an unsigned integer using varint encoding.\"\"\"\n    if x &lt; 0:\n        raise ValueError(\"Cannot encode negative value as unsigned varint\")\n    buf = []\n    while x &gt; 0x7F:\n        buf.append((x &amp; 0x7F) | 0x80)\n        x &gt;&gt;= 7\n    buf.append(x &amp; 0x7F)\n    result = bytes(buf)\n    logger.debug(f\"encode_uvarint: {result.hex()}\")\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.encode_value","title":"<code>encode_value(value)</code>","text":"<p>Encodes a single value based on its type Mirrors the encoding rules from the JavaScript library</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def encode_value(value: Any) -&gt; bytes:\n    \"\"\"\n    Encodes a single value based on its type\n    Mirrors the encoding rules from the JavaScript library\n    \"\"\"\n    if isinstance(value, int):\n        return encode_uvarint(value)  # Variable-length encoding for numbers\n    elif isinstance(value, str):\n        value_bytes = value.encode(\"utf-8\")\n        return encode_uvarint(len(value_bytes)) + value_bytes\n    elif isinstance(value, bytes):\n        return encode_uvarint(len(value)) + value\n    elif isinstance(value, dict):\n        return encode(value)  # Recursive encoding for nested objects\n    elif isinstance(value, list):\n        encoded_list = bytearray()\n        for item in value:\n            encoded_list.extend(encode_value(item))\n        return encoded_list\n    else:\n        raise TypeError(f\"Unsupported data type: {type(value)}\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.field_marshal_binary","title":"<code>field_marshal_binary(field, val)</code>","text":"<p>Encodes a field by writing its field number as one byte, then appending the provided value (which itself may already be length\u2011prefixed)</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def field_marshal_binary(field: int, val: bytes) -&gt; bytes:\n    \"\"\"\n    Encodes a field by writing its field number as one byte,\n    then appending the provided value (which itself may already be length\u2011prefixed)\n    \"\"\"\n    if field &lt; 1 or field &gt; 32:\n        raise ValueOutOfRangeException(field)\n    result = struct.pack(\"B\", field) + val\n    logger.debug(f\"field_marshal_binary (field {field}): {result.hex()}\")\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.utils.encoding.read_uvarint","title":"<code>read_uvarint(reader)</code>","text":"<p>Reads an unsigned varint from a byte stream</p> Source code in <code>accumulate\\utils\\encoding.py</code> <pre><code>def read_uvarint(reader: io.BytesIO) -&gt; int:\n    \"\"\"Reads an unsigned varint from a byte stream\"\"\"\n    x = 0\n    shift = 0\n    while True:\n        b = reader.read(1)\n        if len(b) == 0:\n            raise EOFError(\"Unexpected end of stream while reading uvarint\")\n        b_val = b[0]\n        x |= (b_val &amp; 0x7F) &lt;&lt; shift\n        if b_val &lt; 0x80:\n            break\n        shift += 7\n    return x\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions","title":"<code>hash_functions</code>","text":""},{"location":"api_reference/#accumulate.utils.hash_functions.LiteAuthorityForHash","title":"<code>LiteAuthorityForHash(key_hash)</code>","text":"<p>Generate a Lite Token Account suffix from a key hash</p> <p>:param key_hash: The SHA-256 first 20 bytes :return: A valid Lite Token Account suffix</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def LiteAuthorityForHash(key_hash: bytes) -&gt; str:\n    \"\"\"\n    Generate a Lite Token Account suffix from a key hash\n\n    :param key_hash: The SHA-256 first 20 bytes\n    :return: A valid Lite Token Account suffix\n    \"\"\"\n    first20 = key_hash[:20]  # Extract the first 20 bytes\n    first20_hex = first20.hex()  # Convert first 20 bytes to a hex string\n    checksum_full = hashlib.sha256(first20_hex.encode()).digest()  # Hash the hex string\n    checksum = checksum_full[-4:]  # Extract the last 4 bytes as checksum\n    return f\"{(first20 + checksum).hex()}\"  # Append checksum and return\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions.LiteAuthorityForKey","title":"<code>LiteAuthorityForKey(pub_key, signature_type)</code>","text":"<p>Generate a Lite Token Account (LTA) URL from a public key</p> <p>:param pub_key: The public key in bytes :param signature_type: The signature type (e.g., \"ED25519\") :return: A valid Lite Token Account (LTA) URL</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def LiteAuthorityForKey(pub_key: bytes, signature_type: str) -&gt; str:\n    \"\"\"\n    Generate a Lite Token Account (LTA) URL from a public key\n\n    :param pub_key: The public key in bytes\n    :param signature_type: The signature type (e.g., \"ED25519\")\n    :return: A valid Lite Token Account (LTA) URL\n    \"\"\"\n    key_hash = hashlib.sha256(pub_key).digest()  # SHA-256 Hash\n    lite_account = f\"acc://{LiteAuthorityForHash(key_hash)}\"\n    return lite_account\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions.btc_address","title":"<code>btc_address(public_key)</code>","text":"<p>Generate a BTC address from a public key</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def btc_address(public_key: bytes) -&gt; str:\n    \"\"\"\n    Generate a BTC address from a public key\n    \"\"\"\n    if len(public_key) not in {33, 65}:\n        raise ValueError(\"Invalid public key length for BTC\")\n    pub_hash = public_key_hash(public_key, SignatureType.BTC)\n    versioned_payload = b\"\\x00\" + pub_hash\n    checksum = hash_data(hash_data(versioned_payload))[:4]\n    return base58.b58encode(versioned_payload + checksum).decode()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions.compute_hash","title":"<code>compute_hash(obj)</code>","text":"<p>Compute a SHA-256 hash for an object implementing a <code>marshal_binary()</code> method. If raw bytes are provided, hash them directly.</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def compute_hash(obj: Any) -&gt; bytes:\n    \"\"\"\n    Compute a SHA-256 hash for an object implementing a `marshal_binary()` method.\n    If raw bytes are provided, hash them directly.\n    \"\"\"\n    if isinstance(obj, bytes):  #  Allow raw bytes\n        return hashlib.sha256(obj).digest()\n\n    if not hasattr(obj, \"marshal_binary\") or not callable(obj.marshal_binary):\n        raise EncodingError(\"Object must implement a `marshal_binary` method\")\n\n    try:\n        binary_data = obj.marshal_binary()\n    except Exception as e:\n        raise EncodingError(\"Failed to marshal object for hashing\") from e\n\n    return hashlib.sha256(binary_data).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions.eth_address","title":"<code>eth_address(public_key)</code>","text":"<p>Generate an ETH address from a public key</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def eth_address(public_key: bytes) -&gt; str:\n    \"\"\"\n    Generate an ETH address from a public key\n    \"\"\"\n    if len(public_key) == 65:  # Uncompressed key\n        public_key = public_key[1:]  # Remove the prefix\n    if len(public_key) != 64:\n        raise ValueError(\"Invalid public key length for ETH\")\n    pub_hash = public_key_hash(public_key, SignatureType.ETH)\n    return \"0x\" + pub_hash.hex()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions.hash_data","title":"<code>hash_data(data)</code>","text":"<p>Computes the SHA-256 hash of the given data</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def hash_data(data: bytes) -&gt; bytes:\n    \"\"\"\n    Computes the SHA-256 hash of the given data\n    \"\"\"\n    if not isinstance(data, bytes):\n        raise ValueError(\"Input must be of type bytes\")\n    return hashlib.sha256(data).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.hash_functions.public_key_hash","title":"<code>public_key_hash(public_key, signature_type)</code>","text":"<p>Calculate the public key hash based on the signature type</p> Source code in <code>accumulate\\utils\\hash_functions.py</code> <pre><code>def public_key_hash(public_key: bytes, signature_type: SignatureType) -&gt; bytes:\n    \"\"\"\n    Calculate the public key hash based on the signature type\n    \"\"\"\n    if signature_type in [\n        SignatureType.ED25519,\n        SignatureType.LEGACY_ED25519,\n        SignatureType.RSA_SHA256,\n        SignatureType.ECDSA_SHA256,\n    ]:\n        return hashlib.sha256(public_key).digest()\n    elif signature_type == SignatureType.RCD1:\n        return hashlib.sha256(b\"RCD\" + public_key).digest()\n    elif signature_type in [SignatureType.BTC, SignatureType.BTC_LEGACY]:\n        sha256_hash = hashlib.sha256(public_key).digest()\n        ripemd160 = hashlib.new(\"ripemd160\")\n        ripemd160.update(sha256_hash)\n        return ripemd160.digest()\n    elif signature_type == SignatureType.ETH:\n        return keccak(public_key)[-20:]\n    else:\n        raise ValueError(f\"Unsupported signature type for public key hash: {signature_type}\")\n</code></pre>"},{"location":"api_reference/#additional-utils","title":"Additional Utils","text":""},{"location":"api_reference/#accumulate.utils.address_parse","title":"<code>address_parse</code>","text":""},{"location":"api_reference/#accumulate.utils.address_parse.is_wif_key","title":"<code>is_wif_key(wif)</code>","text":"<p>Check if a string is a valid WIF (Wallet Import Format) key.</p> <p>:param wif: The WIF key string. :return: True if valid, False otherwise.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def is_wif_key(wif: str) -&gt; bool:\n    \"\"\"\n    Check if a string is a valid WIF (Wallet Import Format) key.\n\n    :param wif: The WIF key string.\n    :return: True if valid, False otherwise.\n    \"\"\"\n    if not wif.startswith((\"5\", \"K\", \"L\")) or len(wif) not in (51, 52):\n        return False\n    try:\n        decoded = base58.b58decode(wif)\n        if len(decoded) not in (37, 38):  # 32 bytes private key + 4 bytes checksum (+1 byte for compression flag)\n            return False #\n        checksum = decoded[-4:]\n        expected_checksum = hashlib.sha256(hashlib.sha256(decoded[:-4]).digest()).digest()[:4]\n        return checksum == expected_checksum\n    except Exception: #\n        return False #\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_ac_address","title":"<code>parse_ac_address(address)</code>","text":"<p>Parse an Accumulate public key (AC) address.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_ac_address(address: str) -&gt; PublicKeyHash:\n    \"\"\"Parse an Accumulate public key (AC) address.\"\"\"\n    prefix = address[:3]  # Extract prefix (e.g., \"AC1\")\n    version = address[2:3]  # Extract version (e.g., \"1\" from \"AC1\")\n    prefix_map = {\"1\": \"AC1\", \"2\": \"AC2\", \"3\": \"AC3\"}\n    type_map = {\"1\": \"ED25519\", \"2\": \"EcdsaSha256\", \"3\": \"RsaSha256\"}\n\n    if version not in prefix_map or prefix != prefix_map[version]:\n        raise ValidationError(f\"Invalid AC address type: {address}\")\n\n    # Validate the rest of the address\n    hash_bytes = parse_with_prefix(address, 32, prefix_map[version])\n    return PublicKeyHash(type_map[version], hash_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_as_address","title":"<code>parse_as_address(address)</code>","text":"<p>Parse an Accumulate private key (AS) address.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_as_address(address: str) -&gt; PrivateKey:\n    \"\"\"Parse an Accumulate private key (AS) address.\"\"\"\n    prefix = address[:3]  # Extract prefix (e.g., \"AS1\")\n    version = address[2:3]  # Extract version (e.g., \"1\" from \"AS1\")\n    prefix_map = {\"1\": \"AS1\", \"2\": \"AS2\", \"3\": \"AS3\"}\n    type_map = {\"1\": \"ED25519\", \"2\": \"EcdsaSha256\", \"3\": \"RsaSha256\"}\n\n    if version not in prefix_map or prefix != prefix_map[version]:\n        raise ValidationError(f\"Invalid AS address type: {address}\")\n\n    # Validate the rest of the address\n    private_key_bytes = parse_with_prefix(address, 32, prefix_map[version])\n    return PrivateKey(private_key_bytes, type_map[version])\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_btc_address","title":"<code>parse_btc_address(address)</code>","text":"<p>Parse a Bitcoin public key (BT) address.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_btc_address(address: str) -&gt; PublicKeyHash:\n    \"\"\"Parse a Bitcoin public key (BT) address.\"\"\"\n    hash_bytes = parse_with_checksum(address[2:], 20, b\"\\x00\")\n    return PublicKeyHash(\"BTC\", hash_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_eth_address","title":"<code>parse_eth_address(address)</code>","text":"<p>Parse an Ethereum address.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_eth_address(address: str) -&gt; PublicKeyHash:\n    \"\"\"Parse an Ethereum address.\"\"\"\n    if not address.startswith(\"0x\"):\n        raise ValidationError(\"Unknown address format\")  # Standardized message\n\n    try:\n        hash_bytes = bytes.fromhex(address[2:])\n    except ValueError:\n        raise ValidationError(\"Unknown address format\")  # Standardized message\n\n    if len(hash_bytes) != 20:\n        raise ValidationError(\"Unknown address format\")  # Standardized message #\n\n    return PublicKeyHash(\"ETH\", hash_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_fa_address","title":"<code>parse_fa_address(address)</code>","text":"<p>Parse a Factom public key (FA) address.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_fa_address(address: str) -&gt; PublicKeyHash:\n    \"\"\"Parse a Factom public key (FA) address.\"\"\"\n    # Strip the readable prefix before decoding\n    if not address.startswith(\"FA\"):  # This condition ensures the prefix validation\n        raise ValidationError(\"Invalid FA address prefix\")\n    encoded_payload = address[2:]  # Remove the \"FA\" prefix\n    hash_bytes = parse_with_checksum(encoded_payload, 32, b\"\\x5f\\xb1\")\n    return PublicKeyHash(\"RCD1\", hash_bytes)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_fs_address","title":"<code>parse_fs_address(address)</code>","text":"<p>Parse a Factom private key (Fs) address.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_fs_address(address: str) -&gt; PrivateKey:\n    \"\"\"Parse a Factom private key (Fs) address.\"\"\"\n    # Strip the readable prefix before decoding\n    if not address.startswith(\"Fs\"):\n        raise ValidationError(\"Invalid Fs address prefix\") #\n    encoded_payload = address[2:]  # Remove the \"Fs\" prefix\n    private_key_bytes = parse_with_checksum(encoded_payload, 32, b\"\\x64\\x78\")\n    return PrivateKey(private_key_bytes, \"RCD1\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_mh_address","title":"<code>parse_mh_address(address)</code>","text":"<p>Parse an unknown hash (as a multihash).</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_mh_address(address: str) -&gt; PublicKeyHash:\n    \"\"\"Parse an unknown hash (as a multihash).\"\"\"\n    if not address.startswith(\"MH\"):\n        raise ValidationError(\"Invalid MH address: bad prefix\")\n    try:\n        decoded = base58.b58decode(address[2:])\n    except ValueError: #\n        raise ValidationError(\"Invalid MH address: decoding failed\") #\n    return PublicKeyHash(\"Multihash\", decoded)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_wif","title":"<code>parse_wif(wif)</code>","text":"<p>Parse a WIF (Wallet Import Format) encoded key.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_wif(wif: str) -&gt; PrivateKey:\n    \"\"\"Parse a WIF (Wallet Import Format) encoded key.\"\"\"\n    try:\n        decoded = base58.b58decode(wif)\n    except ValueError:\n        raise ValidationError(\"Invalid WIF encoding\")\n\n    if len(decoded) not in (37, 38):\n        raise ValidationError(\"Invalid WIF length\") #\n    key = decoded[1:33]\n    compressed = len(decoded) == 38\n    return PrivateKey(key if not compressed else key[:32], \"BTC\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_with_checksum","title":"<code>parse_with_checksum(address, length, prefix)</code>","text":"<p>Parse an address with a binary prefix and checksum.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_with_checksum(address: str, length: int, prefix: bytes) -&gt; bytes:\n    \"\"\"Parse an address with a binary prefix and checksum.\"\"\"\n    decoded = base58.b58decode(address)\n    if len(decoded) != len(prefix) + length + 4:\n        raise ValidationError(\"Invalid length\")\n    if not decoded.startswith(prefix):\n        raise ValidationError(\"Invalid prefix\")\n    checksum = decoded[-4:]\n    data = decoded[len(prefix):-4]\n    verify_checksum(decoded[:-4], checksum)\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.parse_with_prefix","title":"<code>parse_with_prefix(address, length, prefix)</code>","text":"<p>Parse an address with a specific prefix and length.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def parse_with_prefix(address: str, length: int, prefix: str) -&gt; bytes:\n    \"\"\"Parse an address with a specific prefix and length.\"\"\"\n    if not address.startswith(prefix):\n        raise ValidationError(f\"Invalid prefix for {prefix}\") #\n    decoded = base58.b58decode(address[len(prefix):])\n    if len(decoded) != length + 4:\n        raise ValidationError(f\"Invalid length for {prefix} address\") #\n    checksum = decoded[-4:]\n    data = decoded[:-4]\n    verify_checksum(data, checksum)\n    return data\n</code></pre>"},{"location":"api_reference/#accumulate.utils.address_parse.verify_checksum","title":"<code>verify_checksum(data, checksum)</code>","text":"<p>Verify a double SHA-256 checksum.</p> Source code in <code>accumulate\\utils\\address_parse.py</code> <pre><code>def verify_checksum(data: bytes, checksum: bytes):\n    \"\"\"Verify a double SHA-256 checksum.\"\"\"\n    calculated = hashlib.sha256(hashlib.sha256(data).digest()).digest()[:4]\n    if calculated != checksum:\n        raise ValidationError(\"Invalid checksum\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.config","title":"<code>config</code>","text":""},{"location":"api_reference/#accumulate.utils.config.Config","title":"<code>Config</code>","text":"<p>Configuration utility for managing environment-specific settings.</p> Source code in <code>accumulate\\utils\\config.py</code> <pre><code>class Config:\n    \"\"\"\n    Configuration utility for managing environment-specific settings.\n    \"\"\"\n    @staticmethod\n    def is_testnet() -&gt; bool:\n        \"\"\"\n        Dynamically get the testnet status based on the environment variable.\n        \"\"\"\n        return os.getenv(\"ACCUMULATE_IS_TESTNET\", \"false\").lower() == \"true\"\n\n    @staticmethod\n    def initial_acme_oracle() -&gt; float:\n        \"\"\"\n        Dynamically get the initial ACME oracle value based on the network type.\n        \"\"\"\n        return 5000 if Config.is_testnet() else 0.50\n\n    @staticmethod\n    def get_network_type() -&gt; str:\n        \"\"\"\n        Get the current network type.\n        :return: 'testnet' or 'mainnet'\n        \"\"\"\n        return \"testnet\" if Config.is_testnet() else \"mainnet\"\n\n    @staticmethod\n    def get_initial_oracle_value() -&gt; float:\n        \"\"\"\n        Get the initial ACME oracle value for the configured network.\n        :return: The oracle value as a float.\n        \"\"\"\n        return Config.initial_acme_oracle()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.config.Config.get_initial_oracle_value","title":"<code>get_initial_oracle_value()</code>  <code>staticmethod</code>","text":"<p>Get the initial ACME oracle value for the configured network. :return: The oracle value as a float.</p> Source code in <code>accumulate\\utils\\config.py</code> <pre><code>@staticmethod\ndef get_initial_oracle_value() -&gt; float:\n    \"\"\"\n    Get the initial ACME oracle value for the configured network.\n    :return: The oracle value as a float.\n    \"\"\"\n    return Config.initial_acme_oracle()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.config.Config.get_network_type","title":"<code>get_network_type()</code>  <code>staticmethod</code>","text":"<p>Get the current network type. :return: 'testnet' or 'mainnet'</p> Source code in <code>accumulate\\utils\\config.py</code> <pre><code>@staticmethod\ndef get_network_type() -&gt; str:\n    \"\"\"\n    Get the current network type.\n    :return: 'testnet' or 'mainnet'\n    \"\"\"\n    return \"testnet\" if Config.is_testnet() else \"mainnet\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.config.Config.initial_acme_oracle","title":"<code>initial_acme_oracle()</code>  <code>staticmethod</code>","text":"<p>Dynamically get the initial ACME oracle value based on the network type.</p> Source code in <code>accumulate\\utils\\config.py</code> <pre><code>@staticmethod\ndef initial_acme_oracle() -&gt; float:\n    \"\"\"\n    Dynamically get the initial ACME oracle value based on the network type.\n    \"\"\"\n    return 5000 if Config.is_testnet() else 0.50\n</code></pre>"},{"location":"api_reference/#accumulate.utils.config.Config.is_testnet","title":"<code>is_testnet()</code>  <code>staticmethod</code>","text":"<p>Dynamically get the testnet status based on the environment variable.</p> Source code in <code>accumulate\\utils\\config.py</code> <pre><code>@staticmethod\ndef is_testnet() -&gt; bool:\n    \"\"\"\n    Dynamically get the testnet status based on the environment variable.\n    \"\"\"\n    return os.getenv(\"ACCUMULATE_IS_TESTNET\", \"false\").lower() == \"true\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.eip712","title":"<code>eip712</code>","text":""},{"location":"api_reference/#accumulate.utils.eip712.eth_chain_id","title":"<code>eth_chain_id(network_name)</code>","text":"<p>Returns the Ethereum chain ID for an Accumulate network name</p> <p>:param network_name: The name of the network (e.g., \"mainnet\") :return: The Ethereum chain ID</p> Source code in <code>accumulate\\utils\\eip712.py</code> <pre><code>def eth_chain_id(network_name: str) -&gt; int:\n    \"\"\"\n    Returns the Ethereum chain ID for an Accumulate network name\n\n    :param network_name: The name of the network (e.g., \"mainnet\")\n    :return: The Ethereum chain ID\n    \"\"\"\n    if network_name.lower() == \"mainnet\":\n        return 281  # 0x119\n\n    network_name = network_name.lower()\n    network_hash = hashlib.sha256(network_name.encode()).digest()\n    network_id = int.from_bytes(network_hash[-2:], \"big\")\n    return 281 | (network_id &lt;&lt; 16)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.eip712.hash_eip712","title":"<code>hash_eip712(transaction, signature)</code>","text":"<p>Hashes an EIP-712 transaction and signature</p> <p>:param transaction: The transaction object :param signature: The signature object :return: SHA-256 hash of the EIP-712 message</p> Source code in <code>accumulate\\utils\\eip712.py</code> <pre><code>def hash_eip712(transaction: Dict[str, Any], signature: Dict[str, Any]) -&gt; bytes:\n    \"\"\"\n    Hashes an EIP-712 transaction and signature\n\n    :param transaction: The transaction object\n    :param signature: The signature object\n    :return: SHA-256 hash of the EIP-712 message\n    \"\"\"\n    eip712_message = marshal_eip712(transaction, signature)\n    eip712_json = json.dumps(eip712_message, separators=(',', ':')).encode()\n    return hashlib.sha256(eip712_json).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.eip712.marshal_eip712","title":"<code>marshal_eip712(transaction, signature)</code>","text":"<p>Creates the EIP-712 JSON message for a transaction and signature</p> <p>:param transaction: The transaction object :param signature: The signature object :return: Serialized EIP-712 JSON message</p> Source code in <code>accumulate\\utils\\eip712.py</code> <pre><code>def marshal_eip712(transaction: Dict[str, Any], signature: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Creates the EIP-712 JSON message for a transaction and signature\n\n    :param transaction: The transaction object\n    :param signature: The signature object\n    :return: Serialized EIP-712 JSON message\n    \"\"\"\n    serialized_tx = {\n        \"header\": transaction.get(\"header\", {}),\n        \"signature\": signature.get(\"metadata\", {}),\n    }\n\n    body = transaction.get(\"body\", {})\n    body_type = transaction.get(\"type\")\n    if body and body_type:\n        serialized_tx[body_type] = body\n\n    return serialized_tx\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields","title":"<code>fields</code>","text":""},{"location":"api_reference/#accumulate.utils.fields.BoolField","title":"<code>BoolField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field for boolean values</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class BoolField(Field):\n    \"\"\"Field for boolean values\"\"\"\n\n    def to_json(self, value: bool) -&gt; Optional[bool]:\n        if self.omit_empty and value is False:\n            return None\n        return value\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.DateTimeField","title":"<code>DateTimeField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field for datetime values</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class DateTimeField(Field):\n    \"\"\"Field for datetime values\"\"\"\n\n    def to_json(self, value: datetime) -&gt; Optional[str]:\n        if self.omit_empty and value is None:\n            return None\n        return value.isoformat() if isinstance(value, datetime) else None\n\n    def from_json(self, data: dict, instance: Any) -&gt; None:\n        if self.name in data:\n            try:\n                setattr(instance, self.name, datetime.fromisoformat(data[self.name]))\n            except ValueError:\n                raise ValueError(f\"Invalid datetime format for field {self.name}: {data[self.name]}\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.DurationField","title":"<code>DurationField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field for timedelta (duration) values.</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class DurationField(Field):\n    \"\"\"Field for timedelta (duration) values.\"\"\"\n\n    def to_json(self, value: timedelta) -&gt; Optional[dict]:\n        \"\"\"Convert a timedelta to a JSON-compatible dictionary\"\"\"\n        if self.omit_empty and value == timedelta(0):\n            return None\n        seconds = value.seconds + value.days * 86400  # Total seconds including days\n        nanoseconds = value.microseconds * 1000  # Convert microseconds to nanoseconds\n        return {\"seconds\": seconds, \"nanoseconds\": nanoseconds}\n\n    def from_json(self, data: dict, instance: Any) -&gt; None:\n        \"\"\"Convert a JSON-compatible dictionary back to a timedelta\"\"\"\n        if self.name in data:\n            fields = data[self.name]\n            seconds = fields.get(\"seconds\", 0)\n            nanoseconds = fields.get(\"nanoseconds\", 0)\n            setattr(\n                instance,\n                self.name,\n                timedelta(seconds=seconds, microseconds=nanoseconds / 1000),\n            )\n\n    def is_empty(self, value: timedelta) -&gt; bool:\n        \"\"\"Check if the timedelta is empty (default value)\"\"\"\n        return value == timedelta(0)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.DurationField.from_json","title":"<code>from_json(data, instance)</code>","text":"<p>Convert a JSON-compatible dictionary back to a timedelta</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def from_json(self, data: dict, instance: Any) -&gt; None:\n    \"\"\"Convert a JSON-compatible dictionary back to a timedelta\"\"\"\n    if self.name in data:\n        fields = data[self.name]\n        seconds = fields.get(\"seconds\", 0)\n        nanoseconds = fields.get(\"nanoseconds\", 0)\n        setattr(\n            instance,\n            self.name,\n            timedelta(seconds=seconds, microseconds=nanoseconds / 1000),\n        )\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.DurationField.is_empty","title":"<code>is_empty(value)</code>","text":"<p>Check if the timedelta is empty (default value)</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def is_empty(self, value: timedelta) -&gt; bool:\n    \"\"\"Check if the timedelta is empty (default value)\"\"\"\n    return value == timedelta(0)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.DurationField.to_json","title":"<code>to_json(value)</code>","text":"<p>Convert a timedelta to a JSON-compatible dictionary</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def to_json(self, value: timedelta) -&gt; Optional[dict]:\n    \"\"\"Convert a timedelta to a JSON-compatible dictionary\"\"\"\n    if self.omit_empty and value == timedelta(0):\n        return None\n    seconds = value.seconds + value.days * 86400  # Total seconds including days\n    nanoseconds = value.microseconds * 1000  # Convert microseconds to nanoseconds\n    return {\"seconds\": seconds, \"nanoseconds\": nanoseconds}\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.Field","title":"<code>Field</code>","text":"<p>Base class for field access and validation</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class Field:\n    \"\"\"Base class for field access and validation\"\"\"\n\n    def __init__(self, name: str, required: bool = False, omit_empty: bool = False):\n        self.name = name\n        self.required = required\n        self.omit_empty = omit_empty\n\n    def is_empty(self, value: Any) -&gt; bool:\n        \"\"\"Check if a field value is empty\"\"\"\n        return value is None or (isinstance(value, (str, list, dict)) and len(value) == 0)\n\n    def to_json(self, value: Any) -&gt; Optional[Any]:\n        \"\"\"Serialize the field to JSON\"\"\"\n        if self.omit_empty and self.is_empty(value):\n            return None\n        return value\n\n    def from_json(self, data: dict, instance: Any) -&gt; None:\n        \"\"\"Deserialize the field from JSON\"\"\"\n        if self.name in data:\n            setattr(instance, self.name, data[self.name])\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.Field.from_json","title":"<code>from_json(data, instance)</code>","text":"<p>Deserialize the field from JSON</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def from_json(self, data: dict, instance: Any) -&gt; None:\n    \"\"\"Deserialize the field from JSON\"\"\"\n    if self.name in data:\n        setattr(instance, self.name, data[self.name])\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.Field.is_empty","title":"<code>is_empty(value)</code>","text":"<p>Check if a field value is empty</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def is_empty(self, value: Any) -&gt; bool:\n    \"\"\"Check if a field value is empty\"\"\"\n    return value is None or (isinstance(value, (str, list, dict)) and len(value) == 0)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.Field.to_json","title":"<code>to_json(value)</code>","text":"<p>Serialize the field to JSON</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def to_json(self, value: Any) -&gt; Optional[Any]:\n    \"\"\"Serialize the field to JSON\"\"\"\n    if self.omit_empty and self.is_empty(value):\n        return None\n    return value\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.FloatField","title":"<code>FloatField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field for float values</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class FloatField(Field):\n    \"\"\"Field for float values\"\"\"\n\n    def to_json(self, value: float) -&gt; Optional[float]:\n        if self.omit_empty and value == 0.0:\n            return None\n        return value\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.IntField","title":"<code>IntField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field for integer values</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class IntField(Field):\n    \"\"\"Field for integer values\"\"\"\n\n    def to_json(self, value: int) -&gt; Optional[int]:\n        if self.omit_empty and value == 0:\n            return None\n        return value\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor","title":"<code>ReadOnlyAccessor</code>","text":"<p>Read-only accessor for managing field serialization and equality checks</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class ReadOnlyAccessor:\n    \"\"\"Read-only accessor for managing field serialization and equality checks\"\"\"\n\n    def __init__(self, accessor: Callable[[Any], Any]):\n        \"\"\"\n        Initialize with a callable that provides access to the field value\n        :param accessor: A callable that takes a parent object and returns the field value\n        \"\"\"\n        self._accessor = accessor\n\n    def is_empty(self, obj: Any) -&gt; bool:\n        \"\"\"Check if the field is empty\"\"\"\n        value = self._accessor(obj)\n        return value is None or value == \"\" or value == 0\n\n    def equal(self, obj1: Any, obj2: Any) -&gt; bool:\n        \"\"\"Check if two objects have equal field values\"\"\"\n        return self._accessor(obj1) == self._accessor(obj2)\n\n    def to_json(self, obj: Any) -&gt; Any:\n        \"\"\"Convert the field value to a JSON-compatible format\"\"\"\n        value = self._accessor(obj)\n        if isinstance(value, (int, float, str, dict, list)):\n            return value\n        if hasattr(value, \"to_dict\"):\n            return value.to_dict()\n        if hasattr(value, \"__dict__\"):\n            return value.__dict__\n        raise ValueError(f\"Cannot serialize value of type {type(value).__name__}\")\n\n    def write_to(self, obj: Any) -&gt; bytes:\n        \"\"\"\n        Serialize the field value into binary\n        For demonstration, this simply converts the value to bytes if possible\n        \"\"\"\n        value = self._accessor(obj)\n        if isinstance(value, (int, float)):\n            return str(value).encode()\n        if isinstance(value, str):\n            return value.encode()\n        if isinstance(value, bytes):\n            return value\n        raise ValueError(f\"Cannot write value of type {type(value).__name__} to binary\")\n\n    # Prevent modifications\n    def copy_to(self, dst: Any, src: Any):\n        \"\"\"Read-only accessor does not support copying\"\"\"\n        raise NotImplementedError(\"ReadOnlyAccessor does not support copying values\")\n\n    def read_from(self, data: bytes, obj: Any):\n        \"\"\"Read-only accessor does not support deserialization\"\"\"\n        raise NotImplementedError(\"ReadOnlyAccessor does not support deserialization\")\n\n    def from_json(self, json_data: Any, obj: Any):\n        \"\"\"Read-only accessor does not support deserialization from JSON\"\"\"\n        raise NotImplementedError(\"ReadOnlyAccessor does not support deserialization from JSON\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.__init__","title":"<code>__init__(accessor)</code>","text":"<p>Initialize with a callable that provides access to the field value :param accessor: A callable that takes a parent object and returns the field value</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def __init__(self, accessor: Callable[[Any], Any]):\n    \"\"\"\n    Initialize with a callable that provides access to the field value\n    :param accessor: A callable that takes a parent object and returns the field value\n    \"\"\"\n    self._accessor = accessor\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.copy_to","title":"<code>copy_to(dst, src)</code>","text":"<p>Read-only accessor does not support copying</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def copy_to(self, dst: Any, src: Any):\n    \"\"\"Read-only accessor does not support copying\"\"\"\n    raise NotImplementedError(\"ReadOnlyAccessor does not support copying values\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.equal","title":"<code>equal(obj1, obj2)</code>","text":"<p>Check if two objects have equal field values</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def equal(self, obj1: Any, obj2: Any) -&gt; bool:\n    \"\"\"Check if two objects have equal field values\"\"\"\n    return self._accessor(obj1) == self._accessor(obj2)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.from_json","title":"<code>from_json(json_data, obj)</code>","text":"<p>Read-only accessor does not support deserialization from JSON</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def from_json(self, json_data: Any, obj: Any):\n    \"\"\"Read-only accessor does not support deserialization from JSON\"\"\"\n    raise NotImplementedError(\"ReadOnlyAccessor does not support deserialization from JSON\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.is_empty","title":"<code>is_empty(obj)</code>","text":"<p>Check if the field is empty</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def is_empty(self, obj: Any) -&gt; bool:\n    \"\"\"Check if the field is empty\"\"\"\n    value = self._accessor(obj)\n    return value is None or value == \"\" or value == 0\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.read_from","title":"<code>read_from(data, obj)</code>","text":"<p>Read-only accessor does not support deserialization</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def read_from(self, data: bytes, obj: Any):\n    \"\"\"Read-only accessor does not support deserialization\"\"\"\n    raise NotImplementedError(\"ReadOnlyAccessor does not support deserialization\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.to_json","title":"<code>to_json(obj)</code>","text":"<p>Convert the field value to a JSON-compatible format</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def to_json(self, obj: Any) -&gt; Any:\n    \"\"\"Convert the field value to a JSON-compatible format\"\"\"\n    value = self._accessor(obj)\n    if isinstance(value, (int, float, str, dict, list)):\n        return value\n    if hasattr(value, \"to_dict\"):\n        return value.to_dict()\n    if hasattr(value, \"__dict__\"):\n        return value.__dict__\n    raise ValueError(f\"Cannot serialize value of type {type(value).__name__}\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.ReadOnlyAccessor.write_to","title":"<code>write_to(obj)</code>","text":"<p>Serialize the field value into binary For demonstration, this simply converts the value to bytes if possible</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def write_to(self, obj: Any) -&gt; bytes:\n    \"\"\"\n    Serialize the field value into binary\n    For demonstration, this simply converts the value to bytes if possible\n    \"\"\"\n    value = self._accessor(obj)\n    if isinstance(value, (int, float)):\n        return str(value).encode()\n    if isinstance(value, str):\n        return value.encode()\n    if isinstance(value, bytes):\n        return value\n    raise ValueError(f\"Cannot write value of type {type(value).__name__} to binary\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.StringField","title":"<code>StringField</code>","text":"<p>               Bases: <code>Field</code></p> <p>Field for string values</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class StringField(Field):\n    \"\"\"Field for string values\"\"\"\n\n    def to_json(self, value: str) -&gt; Optional[str]:\n        if self.omit_empty and not value:\n            return None\n        return value\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.TimeAccessor","title":"<code>TimeAccessor</code>","text":"<p>               Bases: <code>ReadOnlyAccessor</code></p> <p>Accessor for managing datetime fields</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>class TimeAccessor(ReadOnlyAccessor):\n    \"\"\"Accessor for managing datetime fields\"\"\"\n\n    def __init__(self, accessor: Callable[[Any], datetime]):\n        super().__init__(accessor)\n\n    def to_json(self, obj: Any) -&gt; Optional[str]:\n        \"\"\"Convert a datetime field to JSON-compatible ISO format\"\"\"\n        value = self._accessor(obj)\n        return None if value is None else value.isoformat()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.fields.TimeAccessor.to_json","title":"<code>to_json(obj)</code>","text":"<p>Convert a datetime field to JSON-compatible ISO format</p> Source code in <code>accumulate\\utils\\fields.py</code> <pre><code>def to_json(self, obj: Any) -&gt; Optional[str]:\n    \"\"\"Convert a datetime field to JSON-compatible ISO format\"\"\"\n    value = self._accessor(obj)\n    return None if value is None else value.isoformat()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting","title":"<code>formatting</code>","text":""},{"location":"api_reference/#accumulate.utils.formatting._calculate_checksum","title":"<code>_calculate_checksum(data)</code>","text":"<p>Calculates a double SHA-256 checksum</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def _calculate_checksum(data: bytes) -&gt; bytes:\n    \"\"\"Calculates a double SHA-256 checksum\"\"\"\n    checksum = hashlib.sha256(data).digest()\n    return hashlib.sha256(checksum).digest()[:4]\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting._format_with_checksum","title":"<code>_format_with_checksum(hash_bytes, prefix)</code>","text":"<p>Formats the address with a checksum</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def _format_with_checksum(hash_bytes: bytes, prefix: bytes) -&gt; str:\n    \"\"\"Formats the address with a checksum\"\"\"\n    if not hash_bytes:\n        raise ValueError(\"Hash bytes cannot be empty\") #\n\n    address = prefix + hash_bytes\n    checksum = _calculate_checksum(address)\n    address += checksum\n    return base58.b58encode(address).decode()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting._format_with_prefix","title":"<code>_format_with_prefix(hash_bytes, prefix)</code>","text":"<p>Formats the address with a prefix and checksum</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def _format_with_prefix(hash_bytes: bytes, prefix: str) -&gt; str:\n    \"\"\"Formats the address with a prefix and checksum\"\"\"\n    if not hash_bytes:\n        raise ValueError(\"Hash bytes cannot be empty\") #\n\n    address = prefix.encode() + hash_bytes\n    checksum = _calculate_checksum(address)\n    address += checksum\n    return prefix + base58.b58encode(address[len(prefix):]).decode()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting._hash_with_algorithm","title":"<code>_hash_with_algorithm(data, algorithm)</code>","text":"<p>Hashes data using the specified algorithm</p> <p>:param data: Data to hash :param algorithm: Hashing algorithm (e.g., 'sha256', 'sha512'). :return: Hashed bytes</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def _hash_with_algorithm(data: bytes, algorithm: str) -&gt; bytes:\n    \"\"\"\n    Hashes data using the specified algorithm\n\n    :param data: Data to hash\n    :param algorithm: Hashing algorithm (e.g., 'sha256', 'sha512').\n    :return: Hashed bytes\n    \"\"\"\n    algorithms = {\n        \"sha256\": hashes.SHA256,\n        \"sha512\": hashes.SHA512,\n    }\n    if algorithm not in algorithms:\n        raise ValueError(f\"Unsupported hash algorithm: {algorithm}\")\n\n    digest = hashes.Hash(algorithms[algorithm](), backend=default_backend())\n    digest.update(data)\n    return digest.finalize()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_ac1","title":"<code>format_ac1(hash_bytes)</code>","text":"<p>Formats an Accumulate AC1 (ed25519) public key hash</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_ac1(hash_bytes: bytes) -&gt; str:\n    \"\"\"Formats an Accumulate AC1 (ed25519) public key hash\"\"\"\n    return _format_with_prefix(hash_bytes, \"AC1\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_ac2","title":"<code>format_ac2(hash_bytes)</code>","text":"<p>Formats an Accumulate AC2 (ecdsa) public key hash</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_ac2(hash_bytes: bytes) -&gt; str:\n    \"\"\"Formats an Accumulate AC2 (ecdsa) public key hash\"\"\"\n    return _format_with_prefix(hash_bytes, \"AC2\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_ac3","title":"<code>format_ac3(hash_bytes)</code>","text":"<p>Formats an Accumulate AC3 (rsa) public key hash</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_ac3(hash_bytes: bytes) -&gt; str:\n    \"\"\"Formats an Accumulate AC3 (rsa) public key hash\"\"\"\n    return _format_with_prefix(hash_bytes, \"AC3\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_as1","title":"<code>format_as1(seed)</code>","text":"<p>Formats an Accumulate AS1 (ed25519) private key</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_as1(seed: bytes) -&gt; str:\n    \"\"\"Formats an Accumulate AS1 (ed25519) private key\"\"\"\n    return _format_with_prefix(seed, \"AS1\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_as2","title":"<code>format_as2(seed)</code>","text":"<p>Formats an Accumulate AS2 (ecdsa) private key</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_as2(seed: bytes) -&gt; str:\n    \"\"\"Formats an Accumulate AS2 (ecdsa) private key\"\"\"\n    return _format_with_prefix(seed, \"AS2\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_as3","title":"<code>format_as3(seed)</code>","text":"<p>Formats an Accumulate AS3 (rsa) private key</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_as3(seed: bytes) -&gt; str:\n    \"\"\"Formats an Accumulate AS3 (rsa) private key\"\"\"\n    return _format_with_prefix(seed, \"AS3\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_btc","title":"<code>format_btc(hash_bytes)</code>","text":"<p>Formats a Bitcoin P2PKH address prefixed with 'BT'</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_btc(hash_bytes: bytes) -&gt; str:\n    \"\"\"Formats a Bitcoin P2PKH address prefixed with 'BT'\"\"\"\n    return \"BT\" + _format_with_checksum(hash_bytes, b'\\x00')\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_eth","title":"<code>format_eth(hash_bytes)</code>","text":"<p>Formats an Ethereum address</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_eth(hash_bytes: bytes) -&gt; str:\n    \"\"\"Formats an Ethereum address\"\"\"\n    # Ensure the hash is exactly 20 bytes long by truncating or padding with zeros\n    if len(hash_bytes) &gt; 20:\n        hash_bytes = hash_bytes[-20:]  # Take the last 20 bytes #\n    elif len(hash_bytes) &lt; 20:\n        hash_bytes = hash_bytes.rjust(20, b'\\x00')  # Pad with leading zeros\n\n    # Convert to hex and prepend the '0x' prefix\n    return \"0x\" + hash_bytes.hex()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_fa","title":"<code>format_fa(hash_bytes)</code>","text":"<p>Formats a Factom FA public key hash</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_fa(hash_bytes: bytes) -&gt; str:\n    \"\"\"Formats a Factom FA public key hash\"\"\"\n    return _format_with_checksum(hash_bytes, b'\\x5f\\xb1')\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_fs","title":"<code>format_fs(seed)</code>","text":"<p>Formats a Factom Fs private key</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_fs(seed: bytes) -&gt; str:\n    \"\"\"Formats a Factom Fs private key\"\"\"\n    return _format_with_checksum(seed, b'\\x64\\x78')\n</code></pre>"},{"location":"api_reference/#accumulate.utils.formatting.format_mh","title":"<code>format_mh(hash_bytes, code='sha256')</code>","text":"<p>Formats a hash using a specified hashing algorithm and appends a checksum</p> <p>:param hash_bytes: Input data to be hashed :param code: Hashing algorithm (e.g., 'sha256', 'sha512') :return: Multihash-formatted string</p> Source code in <code>accumulate\\utils\\formatting.py</code> <pre><code>def format_mh(hash_bytes: bytes, code: Optional[str] = \"sha256\") -&gt; str:\n    \"\"\"\n    Formats a hash using a specified hashing algorithm and appends a checksum\n\n    :param hash_bytes: Input data to be hashed\n    :param code: Hashing algorithm (e.g., 'sha256', 'sha512')\n    :return: Multihash-formatted string\n    \"\"\"\n    if not hash_bytes:\n        raise ValueError(\"Hash bytes cannot be empty\")\n\n    # Hash the input using the specified algorithm\n    hashed_data = _hash_with_algorithm(hash_bytes, code)\n\n    # Add checksum\n    checksum = _calculate_checksum(b\"MH\" + hashed_data)\n    hashed_data += checksum\n\n    # Encode with base58 and add 'MH' prefix\n    return \"MH\" + base58.b58encode(hashed_data).decode()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.import_helpers","title":"<code>import_helpers</code>","text":""},{"location":"api_reference/#accumulate.utils.import_helpers.get_signer","title":"<code>get_signer()</code>","text":"<p>Dynamically import <code>Signer</code> to prevent circular imports.</p> Source code in <code>accumulate\\utils\\import_helpers.py</code> <pre><code>def get_signer():\n    \"\"\"Dynamically import `Signer` to prevent circular imports.\"\"\"\n    from accumulate.signing.signer import Signer\n    return Signer\n</code></pre>"},{"location":"api_reference/#accumulate.utils.import_helpers.is_lite_account_lazy","title":"<code>is_lite_account_lazy(url)</code>","text":"<p>Lazy-load <code>is_lite_account()</code> to prevent circular imports.</p> Source code in <code>accumulate\\utils\\import_helpers.py</code> <pre><code>def is_lite_account_lazy(url: URL) -&gt; bool:\n    \"\"\"Lazy-load `is_lite_account()` to prevent circular imports.\"\"\"\n    from accumulate.utils.validation import is_lite_account\n    return is_lite_account(url)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.import_helpers.query_signer_version","title":"<code>query_signer_version(account_url, client=None)</code>  <code>async</code>","text":"<p>Fetch the signer version from the network API using AccumulateClient.</p> Source code in <code>accumulate\\utils\\import_helpers.py</code> <pre><code>async def query_signer_version(account_url: URL, client: Optional[\"AccumulateClient\"] = None) -&gt; Optional[int]:\n    \"\"\"Fetch the signer version from the network API using AccumulateClient.\"\"\"\n\n    if client is None:\n        from accumulate.api.client import AccumulateClient  \n        from accumulate.config import get_accumulate_rpc_url  \n        client = AccumulateClient(get_accumulate_rpc_url())\n\n    try:\n        logger.info(f\" Querying signer version for {account_url}...\")\n\n        query_type = \"liteIdentity\" if is_lite_account_lazy(account_url, client) else \"default\"\n\n        params = {\"scope\": str(account_url), \"query\": {\"queryType\": query_type}}\n        response = await client.json_rpc_request(\"query\", params)\n\n        signer_version = response.get(\"result\", {}).get(\"account\", {}).get(\"signerVersion\", 1)\n\n        logger.info(f\" Signer version for {account_url}: {signer_version}\")\n        return signer_version\n\n    except Exception as e:\n        logger.error(f\" Failed to fetch signer version for {account_url}: {e}\")\n        return None  # Return None instead of 1 to indicate an error\n\n    finally:\n        await client.close()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols","title":"<code>protocols</code>","text":""},{"location":"api_reference/#accumulate.utils.protocols.BinaryValue","title":"<code>BinaryValue</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects supporting binary serialization and deserialization.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>@runtime_checkable\nclass BinaryValue(Protocol):\n    \"\"\"Protocol for objects supporting binary serialization and deserialization.\"\"\"\n    def marshal_binary(self) -&gt; bytes:\n        \"\"\"Serialize to binary format.\"\"\"\n        raise NotImplementedError(\"marshal_binary must be implemented\")\n\n    def unmarshal_binary(self, data: bytes) -&gt; None:\n        \"\"\"Deserialize from binary format.\"\"\"\n        raise NotImplementedError(\"unmarshal_binary must be implemented\")\n\n    def copy_as_interface(self) -&gt; Any:\n        \"\"\"Create a copy of the instance.\"\"\"\n        raise NotImplementedError(\"copy_as_interface must be implemented\")\n\n    def unmarshal_binary_from(self, reader: BinaryIO) -&gt; None:\n        \"\"\"Unmarshal binary data from a stream.\"\"\"\n        raise NotImplementedError(\"unmarshal_binary_from must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols.BinaryValue.copy_as_interface","title":"<code>copy_as_interface()</code>","text":"<p>Create a copy of the instance.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>def copy_as_interface(self) -&gt; Any:\n    \"\"\"Create a copy of the instance.\"\"\"\n    raise NotImplementedError(\"copy_as_interface must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols.BinaryValue.marshal_binary","title":"<code>marshal_binary()</code>","text":"<p>Serialize to binary format.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>def marshal_binary(self) -&gt; bytes:\n    \"\"\"Serialize to binary format.\"\"\"\n    raise NotImplementedError(\"marshal_binary must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols.BinaryValue.unmarshal_binary","title":"<code>unmarshal_binary(data)</code>","text":"<p>Deserialize from binary format.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>def unmarshal_binary(self, data: bytes) -&gt; None:\n    \"\"\"Deserialize from binary format.\"\"\"\n    raise NotImplementedError(\"unmarshal_binary must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols.BinaryValue.unmarshal_binary_from","title":"<code>unmarshal_binary_from(reader)</code>","text":"<p>Unmarshal binary data from a stream.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>def unmarshal_binary_from(self, reader: BinaryIO) -&gt; None:\n    \"\"\"Unmarshal binary data from a stream.\"\"\"\n    raise NotImplementedError(\"unmarshal_binary_from must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols.UnionValue","title":"<code>UnionValue</code>","text":"<p>               Bases: <code>BinaryValue</code>, <code>Protocol</code></p> <p>Protocol for objects supporting field unmarshaling.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>@runtime_checkable\nclass UnionValue(BinaryValue, Protocol):\n    \"\"\"Protocol for objects supporting field unmarshaling.\"\"\"\n    def unmarshal_fields_from(self, reader: BinaryIO) -&gt; None:\n        \"\"\"Unmarshal fields from a binary stream.\"\"\"\n        raise NotImplementedError(\"unmarshal_fields_from must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.protocols.UnionValue.unmarshal_fields_from","title":"<code>unmarshal_fields_from(reader)</code>","text":"<p>Unmarshal fields from a binary stream.</p> Source code in <code>accumulate\\utils\\protocols.py</code> <pre><code>def unmarshal_fields_from(self, reader: BinaryIO) -&gt; None:\n    \"\"\"Unmarshal fields from a binary stream.\"\"\"\n    raise NotImplementedError(\"unmarshal_fields_from must be implemented\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.rational","title":"<code>rational</code>","text":""},{"location":"api_reference/#accumulate.utils.rational.Rational","title":"<code>Rational</code>","text":"Source code in <code>accumulate\\utils\\rational.py</code> <pre><code>class Rational:\n    def __init__(self, numerator: Union[int, float], denominator: Union[int, float]):\n        if denominator == 0:\n            raise ValueError(\"Denominator cannot be zero\")\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def set(self, numerator: Union[int, float], denominator: Union[int, float]):\n        \"\"\"Set the numerator and denominator of the rational value\"\"\"\n        if denominator == 0:\n            raise ValueError(\"Denominator cannot be zero\")\n        self.numerator = numerator\n        self.denominator = denominator\n\n    def threshold(self, key_count: int) -&gt; int:\n        \"\"\"\n        Calculate the threshold based on the ratio and key count\n        Equivalent to keyCount * numerator / denominator, rounded up\n        \"\"\"\n        if key_count &lt; 0:\n            raise ValueError(\"Key count cannot be negative\")\n        value = key_count * self.numerator / self.denominator\n        return math.ceil(value)\n\n    def __repr__(self):\n        return f\"Rational({self.numerator}, {self.denominator})\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.rational.Rational.set","title":"<code>set(numerator, denominator)</code>","text":"<p>Set the numerator and denominator of the rational value</p> Source code in <code>accumulate\\utils\\rational.py</code> <pre><code>def set(self, numerator: Union[int, float], denominator: Union[int, float]):\n    \"\"\"Set the numerator and denominator of the rational value\"\"\"\n    if denominator == 0:\n        raise ValueError(\"Denominator cannot be zero\")\n    self.numerator = numerator\n    self.denominator = denominator\n</code></pre>"},{"location":"api_reference/#accumulate.utils.rational.Rational.threshold","title":"<code>threshold(key_count)</code>","text":"<p>Calculate the threshold based on the ratio and key count Equivalent to keyCount * numerator / denominator, rounded up</p> Source code in <code>accumulate\\utils\\rational.py</code> <pre><code>def threshold(self, key_count: int) -&gt; int:\n    \"\"\"\n    Calculate the threshold based on the ratio and key count\n    Equivalent to keyCount * numerator / denominator, rounded up\n    \"\"\"\n    if key_count &lt; 0:\n        raise ValueError(\"Key count cannot be negative\")\n    value = key_count * self.numerator / self.denominator\n    return math.ceil(value)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union","title":"<code>union</code>","text":""},{"location":"api_reference/#accumulate.utils.union.UnionValue","title":"<code>UnionValue</code>","text":"<p>A Pythonic implementation for managing values with multiple representations, inspired by Go's UnionValue interface</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>class UnionValue:\n    \"\"\"\n    A Pythonic implementation for managing values with multiple representations,\n    inspired by Go's UnionValue interface\n    \"\"\"\n\n    def __init__(self, value: Union[bytes, str, int, float, None] = None):\n        self.value = value\n\n    def marshal_binary(self) -&gt; bytes:\n        \"\"\"Convert the value to its binary representation\"\"\"\n        if isinstance(self.value, bytes):\n            return self.value\n        elif isinstance(self.value, str):\n            return self.value.encode(\"utf-8\")\n        elif isinstance(self.value, (int, float)):\n            return str(self.value).encode(\"utf-8\")\n        else:\n            raise ValueError(\"Cannot marshal value to binary\")\n\n    def unmarshal_binary(self, data: bytes):\n        \"\"\"Set the value from its binary representation\"\"\"\n        self.value = data\n\n    def marshal_json(self) -&gt; str:\n        \"\"\"Convert the value to its JSON representation\"\"\"\n        try:\n            return json.dumps(self.value)\n        except TypeError:\n            raise ValueError(\"Value cannot be converted to JSON\")\n\n    def unmarshal_json(self, data: str):\n        \"\"\"Set the value from its JSON representation\"\"\"\n        try:\n            self.value = json.loads(data)\n        except json.JSONDecodeError:\n            raise ValueError(\"Invalid JSON representation\")\n\n    def copy(self) -&gt; \"UnionValue\":\n        \"\"\"Create a copy of the current UnionValue\"\"\"\n        return UnionValue(self.value)\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Check equality between two UnionValue instances\"\"\"\n        if not isinstance(other, UnionValue):\n            return False\n        return self.value == other.value\n\n    def __hash__(self):\n        \"\"\"Allow the UnionValue to be used in hashable collections\"\"\"\n        return hash(self.value)\n\n    def __repr__(self):\n        \"\"\"Human-readable representation\"\"\"\n        return f\"UnionValue(value={repr(self.value)})\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check equality between two UnionValue instances</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Check equality between two UnionValue instances\"\"\"\n    if not isinstance(other, UnionValue):\n        return False\n    return self.value == other.value\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.__hash__","title":"<code>__hash__()</code>","text":"<p>Allow the UnionValue to be used in hashable collections</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def __hash__(self):\n    \"\"\"Allow the UnionValue to be used in hashable collections\"\"\"\n    return hash(self.value)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.__repr__","title":"<code>__repr__()</code>","text":"<p>Human-readable representation</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def __repr__(self):\n    \"\"\"Human-readable representation\"\"\"\n    return f\"UnionValue(value={repr(self.value)})\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.copy","title":"<code>copy()</code>","text":"<p>Create a copy of the current UnionValue</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def copy(self) -&gt; \"UnionValue\":\n    \"\"\"Create a copy of the current UnionValue\"\"\"\n    return UnionValue(self.value)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.marshal_binary","title":"<code>marshal_binary()</code>","text":"<p>Convert the value to its binary representation</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def marshal_binary(self) -&gt; bytes:\n    \"\"\"Convert the value to its binary representation\"\"\"\n    if isinstance(self.value, bytes):\n        return self.value\n    elif isinstance(self.value, str):\n        return self.value.encode(\"utf-8\")\n    elif isinstance(self.value, (int, float)):\n        return str(self.value).encode(\"utf-8\")\n    else:\n        raise ValueError(\"Cannot marshal value to binary\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.marshal_json","title":"<code>marshal_json()</code>","text":"<p>Convert the value to its JSON representation</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def marshal_json(self) -&gt; str:\n    \"\"\"Convert the value to its JSON representation\"\"\"\n    try:\n        return json.dumps(self.value)\n    except TypeError:\n        raise ValueError(\"Value cannot be converted to JSON\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.unmarshal_binary","title":"<code>unmarshal_binary(data)</code>","text":"<p>Set the value from its binary representation</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def unmarshal_binary(self, data: bytes):\n    \"\"\"Set the value from its binary representation\"\"\"\n    self.value = data\n</code></pre>"},{"location":"api_reference/#accumulate.utils.union.UnionValue.unmarshal_json","title":"<code>unmarshal_json(data)</code>","text":"<p>Set the value from its JSON representation</p> Source code in <code>accumulate\\utils\\union.py</code> <pre><code>def unmarshal_json(self, data: str):\n    \"\"\"Set the value from its JSON representation\"\"\"\n    try:\n        self.value = json.loads(data)\n    except json.JSONDecodeError:\n        raise ValueError(\"Invalid JSON representation\")\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url","title":"<code>url</code>","text":""},{"location":"api_reference/#accumulate.utils.url.InvalidHashError","title":"<code>InvalidHashError</code>","text":"<p>               Bases: <code>URLParseError</code></p> <p>Raised when a transaction ID includes an invalid hash</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>class InvalidHashError(URLParseError):\n    \"\"\"Raised when a transaction ID includes an invalid hash\"\"\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.MissingHashError","title":"<code>MissingHashError</code>","text":"<p>               Bases: <code>URLParseError</code></p> <p>Raised when a transaction ID does not include a hash</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>class MissingHashError(URLParseError):\n    \"\"\"Raised when a transaction ID does not include a hash\"\"\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.MissingHostError","title":"<code>MissingHostError</code>","text":"<p>               Bases: <code>URLParseError</code></p> <p>Raised when a URL does not include a hostname</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>class MissingHostError(URLParseError):\n    \"\"\"Raised when a URL does not include a hostname\"\"\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL","title":"<code>URL</code>","text":"Source code in <code>accumulate\\utils\\url.py</code> <pre><code>class URL:\n    def __init__(self, user_info: str = \"\", authority: Optional[str] = None, path: Optional[str] = \"\", query: str = \"\", fragment: str = \"\"):\n        self.user_info = user_info\n        self.authority = authority or \"\"\n        self.path = self._normalize_path(path or \"\") \n        self.query = query\n        self.fragment = fragment\n\n        # Memoized values\n        self._str_cache = None\n        self._hash_cache = None\n        self._account_id_cache = None\n        self._identity_id_cache = None\n        self._lock = Lock()\n\n\n    @staticmethod\n    def _normalize_path(path: str) -&gt; str:\n        \"\"\"Normalize a path to ensure it is clean and starts with a '/'.\"\"\"\n        path = path.strip(\"/\")\n        return f\"/{path}\" if path else \"\"\n\n\n\n    @staticmethod\n    def parse(url_str: str) -&gt; \"URL\":\n        \"\"\"Parse a string into an Accumulate URL\"\"\"\n        print(f\"DEBUG: Starting parse method with URL string: {url_str}\")\n\n        # Validate input\n        if not url_str:\n            print(f\"ERROR: Received empty URL string\")\n            raise ValueError(\"URL string cannot be empty\")\n\n        # Ensure correct scheme\n        if not url_str.startswith(\"acc://\"):\n            print(f\"ERROR: Invalid scheme detected. URL must start with 'acc://', got: {url_str}\")\n            raise wrong_scheme(url_str)\n\n        # Normalize URL by removing redundant prefixes\n        original_url_str = url_str\n        while url_str.startswith(\"acc://acc://\"):\n            url_str = url_str.replace(\"acc://acc://\", \"acc://\")\n        if url_str != original_url_str:\n            print(f\"DEBUG: Normalized URL by removing redundant prefixes. Before: {original_url_str}, After: {url_str}\")\n        else:\n            print(f\"DEBUG: No redundant prefixes detected in URL string: {url_str}\")\n\n        # Prevent URLs from ending with '@'\n        if url_str.endswith(\"@\"):\n            print(f\"WARNING: URL ends with '@'. Cleaning it up: {url_str}\")\n            url_str = url_str.rstrip(\"@\")\n\n        # Parse components using urllib\n        print(f\"DEBUG: Parsing URL components using urllib.parse: {url_str}\")\n        parsed = urllib.parse.urlparse(url_str)\n        print(f\"DEBUG: Parsed URL result: {parsed}\")\n\n        # Verify scheme consistency\n        if parsed.scheme != \"acc\":\n            raise wrong_scheme(url_str)\n\n        # Ensure a valid netloc (authority)\n        if not parsed.netloc:\n            print(f\"ERROR: Parsed URL missing authority component. URL: {url_str}, netloc: {parsed.netloc}\")\n            raise ValueError(\"Invalid URL: Authority cannot be empty\")\n\n        # Validate and handle user_info and authority\n        user_info, authority = \"\", parsed.netloc\n        print(f\"DEBUG: Initial netloc value: {parsed.netloc}\")\n\n        if \"@\" in parsed.netloc:\n            print(f\"DEBUG: '@' character found in netloc. Splitting into user_info and authority.\")\n            parts = parsed.netloc.split(\"@\", 1)\n            if len(parts) != 2 or not parts[0] or not parts[1]:\n                print(f\"ERROR: Invalid '@' usage in netloc. Netloc: {parsed.netloc}\")\n                raise ValueError(\"Invalid URL: '@' must separate valid user info and authority.\")\n            user_info, authority = parts\n            print(f\"DEBUG: Extracted user_info: {user_info}, authority: {authority}\")\n        else:\n            print(f\"DEBUG: No user_info detected in netloc. Authority: {authority}\")\n\n        # Ensure the authority is not empty\n        if not authority:\n            raise ValueError(\"Invalid URL: Authority cannot be empty.\")\n\n        # Reject .com domains in the authority\n        if authority.endswith(\".com\"):\n            print(f\"ERROR: Authority ends with '.com', which is not allowed: {authority}\")\n            raise ValueError(f\"Invalid authority domain: {authority}. Domains ending with '.com' are not allowed.\")\n\n        #  Carefully ensure the authority **ALWAYS** starts with `acc://` but **DO NOT** duplicate it\n        if not authority.startswith(\"acc://\"):\n            authority = f\"acc://{authority}\"\n\n        print(f\"DEBUG: Finalized components - user_info: {user_info}, authority: {authority}, path: {parsed.path}, query: {parsed.query}, fragment: {parsed.fragment}\")\n\n        return URL(\n            user_info=user_info,\n            authority=authority,  #  Always ensures \"acc://\" is part of authority\n            path=parsed.path,\n            query=parsed.query,\n            fragment=parsed.fragment,\n        )\n\n\n    def marshal(self) -&gt; bytes:\n        url_str = f\"acc://{self.user_info + '@' if self.user_info else ''}{self.authority}{self.path or ''}\"\n        print(f\"DEBUG: Marshaling URL to string: {url_str}\")\n        return url_str.encode('utf-8')\n\n\n    @staticmethod\n    def unmarshal(data: bytes) -&gt; \"URL\":\n        url_str = data.decode('utf-8')\n        print(f\"DEBUG: Unmarshaling URL from string: {url_str}\")\n        return URL.parse(url_str)\n\n    def __str__(self) -&gt; str:\n        if self._str_cache is None:\n            components = []\n\n            #  Preserve user_info if present\n            if self.user_info:\n                components.append(self.user_info + \"@\")\n\n            #  Ensure authority **always** starts with \"acc://\", but avoid duplication\n            authority = self.authority\n            if not authority.startswith(\"acc://\"):\n                authority = f\"acc://{authority}\"\n\n            components.append(authority)\n\n            #  Append path if present\n            if self.path:\n                components.append(self.path)\n\n            #  Append query if present\n            if self.query:\n                components.append(f\"?{self.query}\")\n\n            #  Append fragment if present\n            if self.fragment:\n                components.append(f\"#{self.fragment}\")\n\n            #  Construct final URL string and cache it\n            self._str_cache = \"\".join(components)\n\n        return self._str_cache\n\n\n\n    def is_key_page_url(self) -&gt; bool:\n        \"\"\"Check if the URL represents a valid key page.\"\"\"\n        path_parts = self.path.strip(\"/\").split(\"/\") #\n        if len(path_parts) == 3 and path_parts[-1].isdigit(): #\n            return True #\n        return False #\n\n\n    def __eq__(self, other: Any) -&gt; bool:\n        \"\"\"Equality operator for URLs (case-insensitive).\"\"\"\n        return isinstance(other, URL) and str(self).lower() == str(other).lower()\n\n    def __lt__(self, other: \"URL\") -&gt; bool:\n        \"\"\"Comparison operator for URLs.\"\"\"\n        return str(self).lower() &lt; str(other).lower()\n\n    def with_user_info(self, user_info: str) -&gt; \"URL\":\n        \"\"\"Return a new URL with modified user info.\"\"\"\n        return URL(user_info=user_info, authority=self.authority, path=self.path, query=self.query, fragment=self.fragment)\n\n    def with_path(self, path: str) -&gt; \"URL\":\n        \"\"\"Return a new URL with modified path.\"\"\"\n        return URL(user_info=self.user_info, authority=self.authority, path=path, query=self.query, fragment=self.fragment)\n\n    def with_query(self, query: str) -&gt; \"URL\":\n        \"\"\"Return a new URL with modified query.\"\"\"\n        return URL(user_info=self.user_info, authority=self.authority, path=self.path, query=query, fragment=self.fragment)\n\n    def strip_extras(self) -&gt; \"URL\":\n        \"\"\"Return a URL with only the authority and path.\"\"\"\n        return URL(authority=self.authority, path=self.path)\n\n    def root_identity(self) -&gt; \"URL\":\n        \"\"\"Return the root identity (authority only).\"\"\"\n        return URL(authority=self.authority) #\n\n    def identity(self) -&gt; \"URL\":\n        \"\"\"Return the Accumulate Digital Identity (ADI), which is the root authority.\"\"\"\n        print(f\"DEBUG: Original path: {self.path}\")\n\n        # The ADI is just the authority, no path.\n        result = URL(authority=self.authority, path=\"\")\n\n        print(f\"DEBUG: Returning identity URL: {result.authority} with path: {result.path}\")\n        return result\n\n    def account_id(self) -&gt; bytes:\n        \"\"\"Generate the Account ID hash.\"\"\"\n        if not self._account_id_cache:\n            normalized = f\"{self.authority}{self.path}\".lower()\n            self._account_id_cache = hashlib.sha256(normalized.encode()).digest()\n        return self._account_id_cache\n\n    def identity_id(self) -&gt; bytes:\n        \"\"\"Generate the Identity ID hash.\"\"\"\n        if not self._identity_id_cache:\n            normalized = self.authority.split(\":\")[0].lower()\n            self._identity_id_cache = hashlib.sha256(normalized.encode()).digest()\n        return self._identity_id_cache\n\n    def hash(self) -&gt; bytes:\n        \"\"\"Generate a hash of the entire URL.\"\"\"\n        if not self._hash_cache:\n            account_hash = self.account_id()\n            query_hash = hashlib.sha256(self.query.encode()).digest() if self.query else b\"\"\n            fragment_hash = hashlib.sha256(self.fragment.encode()).digest() if self.fragment else b\"\"\n            self._hash_cache = hashlib.sha256(account_hash + query_hash + fragment_hash).digest()\n        return self._hash_cache\n\n    def valid_utf8(self) -&gt; bool:\n        \"\"\"Validate that all components are UTF-8.\"\"\"\n        components = [self.user_info, self.authority, self.path, self.query, self.fragment]\n\n        try:\n            for comp in components:\n                if comp:\n                    comp.encode(\"utf-8\", \"strict\")\n            return True\n        except UnicodeEncodeError:\n            return False\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Equality operator for URLs (case-insensitive).</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def __eq__(self, other: Any) -&gt; bool:\n    \"\"\"Equality operator for URLs (case-insensitive).\"\"\"\n    return isinstance(other, URL) and str(self).lower() == str(other).lower()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Comparison operator for URLs.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def __lt__(self, other: \"URL\") -&gt; bool:\n    \"\"\"Comparison operator for URLs.\"\"\"\n    return str(self).lower() &lt; str(other).lower()\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL._normalize_path","title":"<code>_normalize_path(path)</code>  <code>staticmethod</code>","text":"<p>Normalize a path to ensure it is clean and starts with a '/'.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>@staticmethod\ndef _normalize_path(path: str) -&gt; str:\n    \"\"\"Normalize a path to ensure it is clean and starts with a '/'.\"\"\"\n    path = path.strip(\"/\")\n    return f\"/{path}\" if path else \"\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.account_id","title":"<code>account_id()</code>","text":"<p>Generate the Account ID hash.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def account_id(self) -&gt; bytes:\n    \"\"\"Generate the Account ID hash.\"\"\"\n    if not self._account_id_cache:\n        normalized = f\"{self.authority}{self.path}\".lower()\n        self._account_id_cache = hashlib.sha256(normalized.encode()).digest()\n    return self._account_id_cache\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.hash","title":"<code>hash()</code>","text":"<p>Generate a hash of the entire URL.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def hash(self) -&gt; bytes:\n    \"\"\"Generate a hash of the entire URL.\"\"\"\n    if not self._hash_cache:\n        account_hash = self.account_id()\n        query_hash = hashlib.sha256(self.query.encode()).digest() if self.query else b\"\"\n        fragment_hash = hashlib.sha256(self.fragment.encode()).digest() if self.fragment else b\"\"\n        self._hash_cache = hashlib.sha256(account_hash + query_hash + fragment_hash).digest()\n    return self._hash_cache\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.identity","title":"<code>identity()</code>","text":"<p>Return the Accumulate Digital Identity (ADI), which is the root authority.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def identity(self) -&gt; \"URL\":\n    \"\"\"Return the Accumulate Digital Identity (ADI), which is the root authority.\"\"\"\n    print(f\"DEBUG: Original path: {self.path}\")\n\n    # The ADI is just the authority, no path.\n    result = URL(authority=self.authority, path=\"\")\n\n    print(f\"DEBUG: Returning identity URL: {result.authority} with path: {result.path}\")\n    return result\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.identity_id","title":"<code>identity_id()</code>","text":"<p>Generate the Identity ID hash.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def identity_id(self) -&gt; bytes:\n    \"\"\"Generate the Identity ID hash.\"\"\"\n    if not self._identity_id_cache:\n        normalized = self.authority.split(\":\")[0].lower()\n        self._identity_id_cache = hashlib.sha256(normalized.encode()).digest()\n    return self._identity_id_cache\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.is_key_page_url","title":"<code>is_key_page_url()</code>","text":"<p>Check if the URL represents a valid key page.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def is_key_page_url(self) -&gt; bool:\n    \"\"\"Check if the URL represents a valid key page.\"\"\"\n    path_parts = self.path.strip(\"/\").split(\"/\") #\n    if len(path_parts) == 3 and path_parts[-1].isdigit(): #\n        return True #\n    return False #\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.parse","title":"<code>parse(url_str)</code>  <code>staticmethod</code>","text":"<p>Parse a string into an Accumulate URL</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>@staticmethod\ndef parse(url_str: str) -&gt; \"URL\":\n    \"\"\"Parse a string into an Accumulate URL\"\"\"\n    print(f\"DEBUG: Starting parse method with URL string: {url_str}\")\n\n    # Validate input\n    if not url_str:\n        print(f\"ERROR: Received empty URL string\")\n        raise ValueError(\"URL string cannot be empty\")\n\n    # Ensure correct scheme\n    if not url_str.startswith(\"acc://\"):\n        print(f\"ERROR: Invalid scheme detected. URL must start with 'acc://', got: {url_str}\")\n        raise wrong_scheme(url_str)\n\n    # Normalize URL by removing redundant prefixes\n    original_url_str = url_str\n    while url_str.startswith(\"acc://acc://\"):\n        url_str = url_str.replace(\"acc://acc://\", \"acc://\")\n    if url_str != original_url_str:\n        print(f\"DEBUG: Normalized URL by removing redundant prefixes. Before: {original_url_str}, After: {url_str}\")\n    else:\n        print(f\"DEBUG: No redundant prefixes detected in URL string: {url_str}\")\n\n    # Prevent URLs from ending with '@'\n    if url_str.endswith(\"@\"):\n        print(f\"WARNING: URL ends with '@'. Cleaning it up: {url_str}\")\n        url_str = url_str.rstrip(\"@\")\n\n    # Parse components using urllib\n    print(f\"DEBUG: Parsing URL components using urllib.parse: {url_str}\")\n    parsed = urllib.parse.urlparse(url_str)\n    print(f\"DEBUG: Parsed URL result: {parsed}\")\n\n    # Verify scheme consistency\n    if parsed.scheme != \"acc\":\n        raise wrong_scheme(url_str)\n\n    # Ensure a valid netloc (authority)\n    if not parsed.netloc:\n        print(f\"ERROR: Parsed URL missing authority component. URL: {url_str}, netloc: {parsed.netloc}\")\n        raise ValueError(\"Invalid URL: Authority cannot be empty\")\n\n    # Validate and handle user_info and authority\n    user_info, authority = \"\", parsed.netloc\n    print(f\"DEBUG: Initial netloc value: {parsed.netloc}\")\n\n    if \"@\" in parsed.netloc:\n        print(f\"DEBUG: '@' character found in netloc. Splitting into user_info and authority.\")\n        parts = parsed.netloc.split(\"@\", 1)\n        if len(parts) != 2 or not parts[0] or not parts[1]:\n            print(f\"ERROR: Invalid '@' usage in netloc. Netloc: {parsed.netloc}\")\n            raise ValueError(\"Invalid URL: '@' must separate valid user info and authority.\")\n        user_info, authority = parts\n        print(f\"DEBUG: Extracted user_info: {user_info}, authority: {authority}\")\n    else:\n        print(f\"DEBUG: No user_info detected in netloc. Authority: {authority}\")\n\n    # Ensure the authority is not empty\n    if not authority:\n        raise ValueError(\"Invalid URL: Authority cannot be empty.\")\n\n    # Reject .com domains in the authority\n    if authority.endswith(\".com\"):\n        print(f\"ERROR: Authority ends with '.com', which is not allowed: {authority}\")\n        raise ValueError(f\"Invalid authority domain: {authority}. Domains ending with '.com' are not allowed.\")\n\n    #  Carefully ensure the authority **ALWAYS** starts with `acc://` but **DO NOT** duplicate it\n    if not authority.startswith(\"acc://\"):\n        authority = f\"acc://{authority}\"\n\n    print(f\"DEBUG: Finalized components - user_info: {user_info}, authority: {authority}, path: {parsed.path}, query: {parsed.query}, fragment: {parsed.fragment}\")\n\n    return URL(\n        user_info=user_info,\n        authority=authority,  #  Always ensures \"acc://\" is part of authority\n        path=parsed.path,\n        query=parsed.query,\n        fragment=parsed.fragment,\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.root_identity","title":"<code>root_identity()</code>","text":"<p>Return the root identity (authority only).</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def root_identity(self) -&gt; \"URL\":\n    \"\"\"Return the root identity (authority only).\"\"\"\n    return URL(authority=self.authority) #\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.strip_extras","title":"<code>strip_extras()</code>","text":"<p>Return a URL with only the authority and path.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def strip_extras(self) -&gt; \"URL\":\n    \"\"\"Return a URL with only the authority and path.\"\"\"\n    return URL(authority=self.authority, path=self.path)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.valid_utf8","title":"<code>valid_utf8()</code>","text":"<p>Validate that all components are UTF-8.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def valid_utf8(self) -&gt; bool:\n    \"\"\"Validate that all components are UTF-8.\"\"\"\n    components = [self.user_info, self.authority, self.path, self.query, self.fragment]\n\n    try:\n        for comp in components:\n            if comp:\n                comp.encode(\"utf-8\", \"strict\")\n        return True\n    except UnicodeEncodeError:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.with_path","title":"<code>with_path(path)</code>","text":"<p>Return a new URL with modified path.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def with_path(self, path: str) -&gt; \"URL\":\n    \"\"\"Return a new URL with modified path.\"\"\"\n    return URL(user_info=self.user_info, authority=self.authority, path=path, query=self.query, fragment=self.fragment)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.with_query","title":"<code>with_query(query)</code>","text":"<p>Return a new URL with modified query.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def with_query(self, query: str) -&gt; \"URL\":\n    \"\"\"Return a new URL with modified query.\"\"\"\n    return URL(user_info=self.user_info, authority=self.authority, path=self.path, query=query, fragment=self.fragment)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URL.with_user_info","title":"<code>with_user_info(user_info)</code>","text":"<p>Return a new URL with modified user info.</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>def with_user_info(self, user_info: str) -&gt; \"URL\":\n    \"\"\"Return a new URL with modified user info.\"\"\"\n    return URL(user_info=user_info, authority=self.authority, path=self.path, query=self.query, fragment=self.fragment)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.URLParseError","title":"<code>URLParseError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for URL parsing errors</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>class URLParseError(Exception):\n    \"\"\"Base class for URL parsing errors\"\"\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.url.WrongSchemeError","title":"<code>WrongSchemeError</code>","text":"<p>               Bases: <code>URLParseError</code></p> <p>Raised when a URL includes an invalid scheme</p> Source code in <code>accumulate\\utils\\url.py</code> <pre><code>class WrongSchemeError(URLParseError):\n    \"\"\"Raised when a URL includes an invalid scheme\"\"\"\n</code></pre>"},{"location":"api_reference/#accumulate.utils.validation","title":"<code>validation</code>","text":""},{"location":"api_reference/#accumulate.utils.validation.is_lite_account","title":"<code>is_lite_account(account_type)</code>","text":"<p>Returns True if the account type is a Lite Account.</p> Source code in <code>accumulate\\utils\\validation.py</code> <pre><code>def is_lite_account(account_type: str) -&gt; bool:\n    \"\"\"Returns True if the account type is a Lite Account.\"\"\"\n    return account_type.lower() in [\"liteidentity\", \"litetokenaccount\"]\n</code></pre>"},{"location":"api_reference/#accumulate.utils.validation.is_reserved_url","title":"<code>is_reserved_url(url)</code>","text":"<p>Checks if a URL object or string is reserved.</p> Source code in <code>accumulate\\utils\\validation.py</code> <pre><code>def is_reserved_url(url: URL | str) -&gt; bool:\n    \"\"\"Checks if a URL object or string is reserved.\"\"\"\n    try:\n        if isinstance(url, str):\n            if not url.startswith(\"acc://\"):\n                authority = url.split(\".\")[0].lower()\n            else:\n                url = URL.parse(url)\n                authority = url.authority.lower()\n        else:\n            authority = url.authority.lower()\n    except ValueError:\n        return False\n\n    # Strip the scheme prefix if present\n    if authority.startswith(\"acc://\"):\n        authority = authority[len(\"acc://\"):]\n\n    reserved_keywords = {\"unknown\", \"dn\", \"bvn-\"}\n    return any(authority.startswith(keyword) for keyword in reserved_keywords)\n</code></pre>"},{"location":"api_reference/#accumulate.utils.validation.is_valid_adi_url","title":"<code>is_valid_adi_url(url, allow_reserved=False)</code>","text":"<p>Validates an ADI URL according to protocol rules.</p> Source code in <code>accumulate\\utils\\validation.py</code> <pre><code>def is_valid_adi_url(url: str, allow_reserved=False) -&gt; bool:\n    \"\"\"Validates an ADI URL according to protocol rules.\"\"\"\n    if not url or len(url) &gt; 500:  # Max length\n        return False\n\n    # Check reserved URLs\n    if is_reserved_url(url) and not allow_reserved:\n        return False\n\n    # Ensure it ends with '.acme'\n    tld = \".acme\"\n    if not url.endswith(tld):\n        return False\n\n    authority = url[:-len(tld)]\n    if not authority or re.fullmatch(r\"\\d+\", authority):\n        # Must not be empty or all digits\n        return False\n\n    if len(authority) == 48 and re.fullmatch(r\"[a-fA-F0-9]{48}\", authority):\n        # Must not be exactly 48 hexadecimal characters\n        return False\n\n    if \".\" in authority:\n        # Subdomains are not allowed\n        return False\n\n    # Must contain only valid characters\n    valid_chars = set(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_\")\n    if not set(authority).issubset(valid_chars):\n        return False\n\n    return True\n</code></pre>"},{"location":"api_reference/#accumulate.utils.validation.process_signer_url","title":"<code>process_signer_url(url, client=None)</code>  <code>async</code>","text":"<p>Determines if a signer is a Lite Identity, Key Page, or ADI and fetches signer version</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>{ \"url\": str (Processed signer URL), \"signer_type\": str (\"liteIdentity\", \"keyPage\", \"adi\"), \"signer_version\": int (1 for Lite, actual version for Key Page)</p> <code>dict</code> <p>}</p> Source code in <code>accumulate\\utils\\validation.py</code> <pre><code>async def process_signer_url(url: URL, client: Optional[\"AccumulateClient\"] = None) -&gt; dict:\n    \"\"\"\n    Determines if a signer is a Lite Identity, Key Page, or ADI and fetches signer version\n\n    Returns:\n        dict: {\n            \"url\": str (Processed signer URL),\n            \"signer_type\": str (\"liteIdentity\", \"keyPage\", \"adi\"),\n            \"signer_version\": int (1 for Lite, actual version for Key Page)\n        }\n    \"\"\"\n\n    if client is None:\n        from accumulate.api.client import AccumulateClient  \n        from accumulate.config import get_accumulate_rpc_url  \n        client = AccumulateClient(get_accumulate_rpc_url())\n\n    logger.info(f\" Querying Accumulate API for signer account type and version: {url}\")\n\n    try:\n        #  Query the Accumulate API\n        query = Query(query_type=QueryType.DEFAULT)\n        response = await client.query(str(url), query)\n\n        if not isinstance(response, AccountRecord) or \"account\" not in response.__dict__:\n            logger.warning(f\" Unexpected response format for {url}: {response}\")\n            return {\"url\": str(url), \"signer_type\": \"unknown\", \"signer_version\": 1}\n\n        #  Extract account type from response\n        account_type = response.account.get(\"type\", \"unknown\").strip().lower()\n        logger.info(f\" Retrieved Account Type: {account_type} for {url}\")\n\n        #  Handle Lite Identity (Always version 1)\n        if account_type == \"liteidentity\":\n            return {\"url\": str(url), \"signer_type\": \"liteIdentity\", \"signer_version\": 1}\n\n        #  Handle Lite Token Accounts (Also version 1)\n        elif account_type == \"litetokenaccount\":\n            processed_url = str(url).rsplit(\"/ACME\", 1)[0]\n            return {\"url\": processed_url, \"signer_type\": \"liteTokenAccount\", \"signer_version\": 1}\n\n        #  Handle Key Pages (Extract version from response)\n        elif account_type == \"keypage\":\n            signer_version = response.account.get(\"version\", 1)  #  Extract signer version\n            logger.info(f\" Using Key Page signer. Version: {signer_version}\")\n            return {\"url\": str(url), \"signer_type\": \"keyPage\", \"signer_version\": signer_version}\n\n        #  Handle ADI (Assume version 1)\n        elif account_type.endswith(\".acme\"):\n            return {\"url\": str(url), \"signer_type\": \"adi\", \"signer_version\": 1}\n\n        else:\n            logger.error(f\" Unknown signer type for {url}: {account_type}\")\n            return {\"url\": str(url), \"signer_type\": \"unknown\", \"signer_version\": 1}\n\n    except Exception as e:\n        logger.error(f\" Error processing signer URL for {url}: {e}\")\n        return {\"url\": str(url), \"signer_type\": \"unknown\", \"signer_version\": 1}\n</code></pre>"},{"location":"api_reference/#accumulate.utils.validation.validate_accumulate_url","title":"<code>validate_accumulate_url(url)</code>","text":"<p>Validate if a URL object or string is a valid Accumulate URL.</p> Source code in <code>accumulate\\utils\\validation.py</code> <pre><code>def validate_accumulate_url(url: URL | str) -&gt; bool:\n    \"\"\"Validate if a URL object or string is a valid Accumulate URL.\"\"\"\n    if isinstance(url, str):\n        if not url.startswith(\"acc://\"):\n            return False  # Reject URLs that don't start with 'acc://'\n        try:\n            url = URL.parse(url)\n        except ValueError:\n            return False\n    # Validate the URL object\n    if not url.authority:\n        return False\n    return True\n</code></pre>"},{"location":"api_reference/#signing","title":"Signing","text":""},{"location":"api_reference/#accumulate.signing.builder","title":"<code>builder</code>","text":""},{"location":"api_reference/#accumulate.signing.builder.Builder","title":"<code>Builder</code>","text":"Source code in <code>accumulate\\signing\\builder.py</code> <pre><code>class Builder:\n    def __init__(self):\n        self.init_mode: str = InitHashMode.INIT_WITH_SIMPLE_HASH\n        self.type: SignatureType = SignatureType.UNKNOWN\n        self.url: Optional[URL] = None\n        self.delegators: List[URL] = []\n        self.signer: Optional[object] = None\n        self.version: int = 1  # Set signer version to 1 by default\n        self.timestamp = timestamp_generator.get()\n        self.memo: str = \"\"\n        self.data: bytes = b\"\"\n        self.ignore_64_byte: bool = False\n\n    def set_type(self, signature_type: SignatureType) -&gt; \"Builder\":\n        self.type = signature_type\n        return self\n\n    def get_type(self) -&gt; str:\n        return self.type.to_rpc_format()\n\n    def set_url(self, url: URL) -&gt; \"Builder\":\n        if is_reserved_url(url):\n            raise ValueError(\"Reserved URL cannot be used as a signer URL\")\n        if not validate_accumulate_url(url):\n            raise ValueError(\"Invalid Accumulate URL\")\n        self.url = url\n        return self\n\n    def set_signer(self, signer: Optional[object]) -&gt; \"Builder\":\n        \"\"\"Sets the signer and assigns it to the builder.\"\"\"\n        Signer = get_signer()  # Dynamically import Signer\n        if not isinstance(signer, Signer):\n            raise TypeError(\"Expected an instance of Signer\")\n\n        self.signer = signer\n        return self\n\n    def set_version(self, version: int) -&gt; \"Builder\":\n        self.version = version\n        return self\n\n    def set_timestamp(self, timestamp: int) -&gt; \"Builder\":\n        self.timestamp = timestamp\n        return self\n\n    def set_timestamp_to_now(self) -&gt; \"Builder\":\n        self.timestamp = timestamp_generator.get()  # Ensure consistent timestamping\n        return self\n\n    def set_memo(self, memo: str) -&gt; \"Builder\":\n        self.memo = memo\n        return self\n\n    def set_data(self, data: bytes) -&gt; \"Builder\":\n        self.data = data\n        return self\n\n    def add_delegator(self, delegator: URL) -&gt; \"Builder\":\n        if not validate_accumulate_url(delegator):\n            raise ValueError(\"Invalid delegator URL\")\n        self.delegators.append(delegator)\n        return self\n\n    def _validate_signature_requirements(self, init: bool):\n        if not self.url:\n            raise ValueError(\"Missing signer URL\")\n        if not self.signer:\n            raise ValueError(\"Missing signer\")\n        if init and not self.version:\n            raise ValueError(\"Missing version\")\n        if init and self.timestamp is None:\n            raise ValueError(\"Missing timestamp\")\n\n    def _create_signature(self, transaction_data: bytes) -&gt; Signature:\n        \"\"\"Create a signature object based on the specified type.\"\"\"\n        signature_map = {\n            SignatureType.ED25519: ED25519Signature,\n            SignatureType.LEGACY_ED25519: LegacyED25519Signature,\n            SignatureType.RCD1: RCD1Signature,\n            SignatureType.BTC: BTCSignature,\n            SignatureType.ETH: ETHSignature,\n            SignatureType.RSA_SHA256: RSASignature,\n            SignatureType.ECDSA_SHA256: ECDSA_SHA256Signature,\n        }\n        sig_class = signature_map.get(self.type)\n        if not sig_class:\n            raise ValueError(f\"Unsupported signature type: {self.type}\")\n\n        signature = sig_class(\n            signer=self.url,\n            publicKey=self.signer.get_public_key() if self.signer else None, \n            signature=None,  # Placeholder; set after signing\n            transaction_data=transaction_data\n        )\n        signature.memo = self.memo\n        signature.data = self.data\n        signature.type = self.get_type().lower()  # Ensure lowercase\n        signature.timestamp = self.timestamp\n        signature.signerVersion = self.version\n        return signature\n\n    def prepare(self, init: bool, transaction_data: bytes) -&gt; Signature:\n        \"\"\"Prepare a signature ensuring transaction data is included.\"\"\"\n        self._validate_signature_requirements(init)\n        if self.type == SignatureType.UNKNOWN:\n            self.type = SignatureType.ED25519\n        return self._create_signature(transaction_data)\n\n    async def sign(self, message: bytes) -&gt; dict:\n        \"\"\"Sign the provided message and return a dictionary.\"\"\"\n        transaction_data = message  # Use the message as transaction data\n        signature = self.prepare(init=False, transaction_data=transaction_data)\n\n        for delegator in self.delegators:\n            signature = DelegatedSignature(\n                delegator=delegator,\n                metadata_hash=None,\n                signature=signature,\n            )\n\n        # Use consistent camelCase for the field name\n        signature.transactionHash = hash_data(transaction_data).hex()\n        signature_data = await self.signer.sign_transaction(self.type, transaction_data)\n\n        if isinstance(signature_data[\"signature\"], bytes):\n            signature_data[\"signature\"] = signature_data[\"signature\"].hex()\n\n        logger.info(f\"Debug: Signature Created - {signature_data['signature']}\")\n\n        return dict(signature_data)\n\n    async def initiate(self, txn: Transaction) -&gt; Signature:\n        \"\"\"Initiate a transaction and prepare the signature.\"\"\"\n        txn_hash = txn.get_hash()\n        logger.info(f\"Transaction Hash from txn.get_hash(): {txn_hash.hex()}\")\n\n        # Prepare the signature using the txn_hash as the signing data\n        signature = self.prepare(init=True, transaction_data=txn_hash)\n\n        for delegator in self.delegators:\n            signature = DelegatedSignature(\n                delegator=delegator,\n                metadata_hash=None,\n                signature=signature,\n            )\n\n        if self.init_mode == InitHashMode.INIT_WITH_SIMPLE_HASH:\n            txn.header.initiator = txn_hash\n        else:\n            txn.header.initiator = self.calculate_merkle_hash(txn_hash)\n\n        signature.transactionHash = txn_hash\n\n        # Log the value of txn_hash being passed to the signer\n        logger.info(f\"Passing Transaction Hash to signer.sign_transaction(): {txn_hash.hex()}\")\n\n        signature_data = await self.signer.sign_transaction(self.type, txn_hash)\n        signature.signature = signature_data[\"signature\"]\n        signature.signerVersion = signature_data[\"signerVersion\"]\n\n        return signature\n</code></pre>"},{"location":"api_reference/#accumulate.signing.builder.Builder._create_signature","title":"<code>_create_signature(transaction_data)</code>","text":"<p>Create a signature object based on the specified type.</p> Source code in <code>accumulate\\signing\\builder.py</code> <pre><code>def _create_signature(self, transaction_data: bytes) -&gt; Signature:\n    \"\"\"Create a signature object based on the specified type.\"\"\"\n    signature_map = {\n        SignatureType.ED25519: ED25519Signature,\n        SignatureType.LEGACY_ED25519: LegacyED25519Signature,\n        SignatureType.RCD1: RCD1Signature,\n        SignatureType.BTC: BTCSignature,\n        SignatureType.ETH: ETHSignature,\n        SignatureType.RSA_SHA256: RSASignature,\n        SignatureType.ECDSA_SHA256: ECDSA_SHA256Signature,\n    }\n    sig_class = signature_map.get(self.type)\n    if not sig_class:\n        raise ValueError(f\"Unsupported signature type: {self.type}\")\n\n    signature = sig_class(\n        signer=self.url,\n        publicKey=self.signer.get_public_key() if self.signer else None, \n        signature=None,  # Placeholder; set after signing\n        transaction_data=transaction_data\n    )\n    signature.memo = self.memo\n    signature.data = self.data\n    signature.type = self.get_type().lower()  # Ensure lowercase\n    signature.timestamp = self.timestamp\n    signature.signerVersion = self.version\n    return signature\n</code></pre>"},{"location":"api_reference/#accumulate.signing.builder.Builder.initiate","title":"<code>initiate(txn)</code>  <code>async</code>","text":"<p>Initiate a transaction and prepare the signature.</p> Source code in <code>accumulate\\signing\\builder.py</code> <pre><code>async def initiate(self, txn: Transaction) -&gt; Signature:\n    \"\"\"Initiate a transaction and prepare the signature.\"\"\"\n    txn_hash = txn.get_hash()\n    logger.info(f\"Transaction Hash from txn.get_hash(): {txn_hash.hex()}\")\n\n    # Prepare the signature using the txn_hash as the signing data\n    signature = self.prepare(init=True, transaction_data=txn_hash)\n\n    for delegator in self.delegators:\n        signature = DelegatedSignature(\n            delegator=delegator,\n            metadata_hash=None,\n            signature=signature,\n        )\n\n    if self.init_mode == InitHashMode.INIT_WITH_SIMPLE_HASH:\n        txn.header.initiator = txn_hash\n    else:\n        txn.header.initiator = self.calculate_merkle_hash(txn_hash)\n\n    signature.transactionHash = txn_hash\n\n    # Log the value of txn_hash being passed to the signer\n    logger.info(f\"Passing Transaction Hash to signer.sign_transaction(): {txn_hash.hex()}\")\n\n    signature_data = await self.signer.sign_transaction(self.type, txn_hash)\n    signature.signature = signature_data[\"signature\"]\n    signature.signerVersion = signature_data[\"signerVersion\"]\n\n    return signature\n</code></pre>"},{"location":"api_reference/#accumulate.signing.builder.Builder.prepare","title":"<code>prepare(init, transaction_data)</code>","text":"<p>Prepare a signature ensuring transaction data is included.</p> Source code in <code>accumulate\\signing\\builder.py</code> <pre><code>def prepare(self, init: bool, transaction_data: bytes) -&gt; Signature:\n    \"\"\"Prepare a signature ensuring transaction data is included.\"\"\"\n    self._validate_signature_requirements(init)\n    if self.type == SignatureType.UNKNOWN:\n        self.type = SignatureType.ED25519\n    return self._create_signature(transaction_data)\n</code></pre>"},{"location":"api_reference/#accumulate.signing.builder.Builder.set_signer","title":"<code>set_signer(signer)</code>","text":"<p>Sets the signer and assigns it to the builder.</p> Source code in <code>accumulate\\signing\\builder.py</code> <pre><code>def set_signer(self, signer: Optional[object]) -&gt; \"Builder\":\n    \"\"\"Sets the signer and assigns it to the builder.\"\"\"\n    Signer = get_signer()  # Dynamically import Signer\n    if not isinstance(signer, Signer):\n        raise TypeError(\"Expected an instance of Signer\")\n\n    self.signer = signer\n    return self\n</code></pre>"},{"location":"api_reference/#accumulate.signing.builder.Builder.sign","title":"<code>sign(message)</code>  <code>async</code>","text":"<p>Sign the provided message and return a dictionary.</p> Source code in <code>accumulate\\signing\\builder.py</code> <pre><code>async def sign(self, message: bytes) -&gt; dict:\n    \"\"\"Sign the provided message and return a dictionary.\"\"\"\n    transaction_data = message  # Use the message as transaction data\n    signature = self.prepare(init=False, transaction_data=transaction_data)\n\n    for delegator in self.delegators:\n        signature = DelegatedSignature(\n            delegator=delegator,\n            metadata_hash=None,\n            signature=signature,\n        )\n\n    # Use consistent camelCase for the field name\n    signature.transactionHash = hash_data(transaction_data).hex()\n    signature_data = await self.signer.sign_transaction(self.type, transaction_data)\n\n    if isinstance(signature_data[\"signature\"], bytes):\n        signature_data[\"signature\"] = signature_data[\"signature\"].hex()\n\n    logger.info(f\"Debug: Signature Created - {signature_data['signature']}\")\n\n    return dict(signature_data)\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler","title":"<code>signature_handler</code>","text":""},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler","title":"<code>SignatureHandler</code>","text":"Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>class SignatureHandler:\n    @staticmethod\n    def btc_address(public_key: bytes) -&gt; str:\n        \"\"\"Generate a BTC address from a public key\"\"\"\n        return btc_address(public_key)\n\n    @staticmethod\n    def eth_address(public_key: bytes) -&gt; str:\n        \"\"\"Generate an ETH address from a public key\"\"\"\n        return eth_address(public_key)\n\n    @staticmethod\n    def verify_merkle_hash(metadata_hash: bytes, txn_hash: bytes, signature: Signature) -&gt; bool:\n        \"\"\"Verify if a Merkle hash is valid.\"\"\"\n        try:\n            calculated_merkle_hash = hashlib.sha256(metadata_hash + txn_hash).digest()\n            return calculated_merkle_hash == signature.transactionHash\n        except Exception:\n            return False\n\n    @staticmethod\n    def create_authority_signature(origin: URL, authority: URL, vote: Optional[str], txid: Optional[str]) -&gt; bytes:\n        \"\"\"Create a signature for an authority.\"\"\"\n        data = str(origin).encode() + str(authority).encode()\n        if vote:\n            data += vote.encode()\n        if txid:\n            data += txid.encode()\n        return hashlib.sha256(data).digest()\n\n    @staticmethod\n    def verify_authority_signature(authority_signature: bytes, origin: URL, authority: URL, vote: Optional[str], txid: Optional[str]) -&gt; bool:\n        \"\"\"Verify an authority signature.\"\"\"\n        expected_hash = SignatureHandler.create_authority_signature(origin, authority, vote, txid)\n        return expected_hash == authority_signature\n\n    # ========== ED25519 ==========\n    @staticmethod\n    def sign_ed25519(private_key: bytes, message: bytes) -&gt; bytes:\n        \"\"\"Sign a message using ED25519.\"\"\"\n        private_key_obj = ed25519.Ed25519PrivateKey.from_private_bytes(private_key)\n        return private_key_obj.sign(message)\n\n    @staticmethod\n    def verify_ed25519(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n        \"\"\"Verify an ED25519 signature.\"\"\"\n        try:\n            vk = ed25519.Ed25519PublicKey.from_public_bytes(public_key)\n            vk.verify(signature, message)\n            return True\n        except Exception:\n            return False\n\n    # ========== BTC (ECDSA SECP256k1) ==========\n    @staticmethod\n    def sign_btc(private_key: bytes, message: bytes) -&gt; bytes:\n        \"\"\"Sign a message using Bitcoin ECDSA SECP256k1\"\"\"\n        private_key_obj = ec.derive_private_key(int.from_bytes(private_key, \"big\"), ec.SECP256K1())\n        return private_key_obj.sign(message, ec.ECDSA(SHA256()))\n\n    @staticmethod\n    def verify_btc(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n        \"\"\"Verify a BTC (ECDSA SECP256k1) signature\"\"\"\n        try:\n            vk = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), public_key)\n            vk.verify(signature, message, ec.ECDSA(SHA256()))\n            return True\n        except Exception:\n            return False\n\n    # ========== ETH (EIP-712) ==========\n    @staticmethod\n    def sign_eth(private_key: bytes, message_hash: bytes) -&gt; bytes:\n        \"\"\"Sign an Ethereum message\"\"\"\n        try:\n            eth_key = eth_keys.PrivateKey(private_key)\n            return eth_key.sign_msg_hash(message_hash).to_bytes()\n        except Exception:\n            raise ValueError(\"Failed to sign Ethereum message\")\n\n    @staticmethod\n    def verify_eth(public_key: bytes, message_hash: bytes, signature: bytes) -&gt; bool:\n        \"\"\"Verify an Ethereum (EIP-712) signature\"\"\"\n        try:\n            eth_key = eth_keys.PublicKey(public_key)\n            eth_signature = eth_keys.Signature(signature)\n            return eth_key.verify_msg_hash(message_hash, eth_signature)\n        except (ValidationError, BadSignature):\n            return False\n\n    # ========== RSA SHA256 ==========\n    @staticmethod\n    def sign_rsa_sha256(private_key: bytes, message: bytes) -&gt; bytes:\n        \"\"\"Sign a message with RSA SHA-256\"\"\"\n        private_key_obj = serialization.load_pem_private_key(\n            private_key, password=None, backend=default_backend()\n        )\n        return private_key_obj.sign(\n            message,\n            PKCS1v15(),\n            SHA256(),\n        )\n\n    @staticmethod\n    def verify_rsa_sha256(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n        \"\"\"Verify an RSA SHA-256 signature\"\"\"\n        try:\n            public_key_obj = serialization.load_pem_public_key(\n                public_key, backend=default_backend()\n            )\n            public_key_obj.verify(\n                signature,\n                message,\n                PKCS1v15(),\n                SHA256(),\n            )\n            return True\n        except Exception:\n            return False\n\n    # ========== ECDSA SHA256 ==========\n    @staticmethod\n    def sign_ecdsa_sha256(private_key: bytes, message: bytes) -&gt; bytes:\n        \"\"\"Sign a message using ECDSA SHA256\"\"\"\n        private_key_obj = ec.derive_private_key(int.from_bytes(private_key, \"big\"), ec.SECP256K1())\n        return private_key_obj.sign(message, ec.ECDSA(SHA256()))\n\n    @staticmethod\n    def verify_ecdsa_sha256(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n        \"\"\"Verify an ECDSA SHA256 signature\"\"\"\n        try:\n            public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), public_key)\n            public_key_obj.verify(signature, message, ec.ECDSA(SHA256()))\n            return True\n        except Exception:\n            return False\n\n    # ========== TypedData (EIP-712 Compliant) ==========\n    @staticmethod\n    def sign_typed_data(private_key: bytes, message_hash: bytes) -&gt; bytes:\n        \"\"\"Sign an Ethereum message using EIP-712 Typed Data\"\"\"\n        return SignatureHandler.sign_eth(private_key, message_hash)\n\n    # ========== Delegated Signature ==========\n    @staticmethod\n    def sign_delegated_signature(inner_signature: bytes, delegator: URL) -&gt; bytes:\n        \"\"\"Create a delegated signature\"\"\"\n        return hashlib.sha256(inner_signature + str(delegator).encode()).digest()\n\n    @staticmethod\n    def verify_delegated_signature(delegated_signature: bytes, inner_signature: bytes, delegator: URL) -&gt; bool:\n        \"\"\"Verify a delegated signature.\"\"\"\n        expected_hash = hashlib.sha256(inner_signature + str(delegator).encode()).digest()\n        return expected_hash == delegated_signature\n\n    # ========== General Signature Verification ==========\n    @staticmethod\n    def verify_signature_with_timestamp(public_key: bytes, message: bytes, signature: Signature, sig_type: SignatureType) -&gt; bool:\n        verification_methods = {\n            SignatureType.ED25519: SignatureHandler.verify_ed25519,\n            SignatureType.ECDSA_SHA256: SignatureHandler.verify_ecdsa_sha256,\n            SignatureType.BTC: SignatureHandler.verify_btc,\n            SignatureType.ETH: SignatureHandler.verify_eth,\n            SignatureType.RSA_SHA256: SignatureHandler.verify_rsa_sha256,\n        }\n\n        verify_func = verification_methods.get(sig_type)\n        if verify_func:\n            return verify_func(public_key, message, signature.signature)\n        else:\n            raise ValueError(f\"Unsupported signature type: {sig_type}\")\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.btc_address","title":"<code>btc_address(public_key)</code>  <code>staticmethod</code>","text":"<p>Generate a BTC address from a public key</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef btc_address(public_key: bytes) -&gt; str:\n    \"\"\"Generate a BTC address from a public key\"\"\"\n    return btc_address(public_key)\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.create_authority_signature","title":"<code>create_authority_signature(origin, authority, vote, txid)</code>  <code>staticmethod</code>","text":"<p>Create a signature for an authority.</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef create_authority_signature(origin: URL, authority: URL, vote: Optional[str], txid: Optional[str]) -&gt; bytes:\n    \"\"\"Create a signature for an authority.\"\"\"\n    data = str(origin).encode() + str(authority).encode()\n    if vote:\n        data += vote.encode()\n    if txid:\n        data += txid.encode()\n    return hashlib.sha256(data).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.eth_address","title":"<code>eth_address(public_key)</code>  <code>staticmethod</code>","text":"<p>Generate an ETH address from a public key</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef eth_address(public_key: bytes) -&gt; str:\n    \"\"\"Generate an ETH address from a public key\"\"\"\n    return eth_address(public_key)\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_btc","title":"<code>sign_btc(private_key, message)</code>  <code>staticmethod</code>","text":"<p>Sign a message using Bitcoin ECDSA SECP256k1</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_btc(private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using Bitcoin ECDSA SECP256k1\"\"\"\n    private_key_obj = ec.derive_private_key(int.from_bytes(private_key, \"big\"), ec.SECP256K1())\n    return private_key_obj.sign(message, ec.ECDSA(SHA256()))\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_delegated_signature","title":"<code>sign_delegated_signature(inner_signature, delegator)</code>  <code>staticmethod</code>","text":"<p>Create a delegated signature</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_delegated_signature(inner_signature: bytes, delegator: URL) -&gt; bytes:\n    \"\"\"Create a delegated signature\"\"\"\n    return hashlib.sha256(inner_signature + str(delegator).encode()).digest()\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_ecdsa_sha256","title":"<code>sign_ecdsa_sha256(private_key, message)</code>  <code>staticmethod</code>","text":"<p>Sign a message using ECDSA SHA256</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_ecdsa_sha256(private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using ECDSA SHA256\"\"\"\n    private_key_obj = ec.derive_private_key(int.from_bytes(private_key, \"big\"), ec.SECP256K1())\n    return private_key_obj.sign(message, ec.ECDSA(SHA256()))\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_ed25519","title":"<code>sign_ed25519(private_key, message)</code>  <code>staticmethod</code>","text":"<p>Sign a message using ED25519.</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_ed25519(private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message using ED25519.\"\"\"\n    private_key_obj = ed25519.Ed25519PrivateKey.from_private_bytes(private_key)\n    return private_key_obj.sign(message)\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_eth","title":"<code>sign_eth(private_key, message_hash)</code>  <code>staticmethod</code>","text":"<p>Sign an Ethereum message</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_eth(private_key: bytes, message_hash: bytes) -&gt; bytes:\n    \"\"\"Sign an Ethereum message\"\"\"\n    try:\n        eth_key = eth_keys.PrivateKey(private_key)\n        return eth_key.sign_msg_hash(message_hash).to_bytes()\n    except Exception:\n        raise ValueError(\"Failed to sign Ethereum message\")\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_rsa_sha256","title":"<code>sign_rsa_sha256(private_key, message)</code>  <code>staticmethod</code>","text":"<p>Sign a message with RSA SHA-256</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_rsa_sha256(private_key: bytes, message: bytes) -&gt; bytes:\n    \"\"\"Sign a message with RSA SHA-256\"\"\"\n    private_key_obj = serialization.load_pem_private_key(\n        private_key, password=None, backend=default_backend()\n    )\n    return private_key_obj.sign(\n        message,\n        PKCS1v15(),\n        SHA256(),\n    )\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.sign_typed_data","title":"<code>sign_typed_data(private_key, message_hash)</code>  <code>staticmethod</code>","text":"<p>Sign an Ethereum message using EIP-712 Typed Data</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef sign_typed_data(private_key: bytes, message_hash: bytes) -&gt; bytes:\n    \"\"\"Sign an Ethereum message using EIP-712 Typed Data\"\"\"\n    return SignatureHandler.sign_eth(private_key, message_hash)\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_authority_signature","title":"<code>verify_authority_signature(authority_signature, origin, authority, vote, txid)</code>  <code>staticmethod</code>","text":"<p>Verify an authority signature.</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_authority_signature(authority_signature: bytes, origin: URL, authority: URL, vote: Optional[str], txid: Optional[str]) -&gt; bool:\n    \"\"\"Verify an authority signature.\"\"\"\n    expected_hash = SignatureHandler.create_authority_signature(origin, authority, vote, txid)\n    return expected_hash == authority_signature\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_btc","title":"<code>verify_btc(public_key, message, signature)</code>  <code>staticmethod</code>","text":"<p>Verify a BTC (ECDSA SECP256k1) signature</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_btc(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify a BTC (ECDSA SECP256k1) signature\"\"\"\n    try:\n        vk = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), public_key)\n        vk.verify(signature, message, ec.ECDSA(SHA256()))\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_delegated_signature","title":"<code>verify_delegated_signature(delegated_signature, inner_signature, delegator)</code>  <code>staticmethod</code>","text":"<p>Verify a delegated signature.</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_delegated_signature(delegated_signature: bytes, inner_signature: bytes, delegator: URL) -&gt; bool:\n    \"\"\"Verify a delegated signature.\"\"\"\n    expected_hash = hashlib.sha256(inner_signature + str(delegator).encode()).digest()\n    return expected_hash == delegated_signature\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_ecdsa_sha256","title":"<code>verify_ecdsa_sha256(public_key, message, signature)</code>  <code>staticmethod</code>","text":"<p>Verify an ECDSA SHA256 signature</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_ecdsa_sha256(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify an ECDSA SHA256 signature\"\"\"\n    try:\n        public_key_obj = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256K1(), public_key)\n        public_key_obj.verify(signature, message, ec.ECDSA(SHA256()))\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_ed25519","title":"<code>verify_ed25519(public_key, message, signature)</code>  <code>staticmethod</code>","text":"<p>Verify an ED25519 signature.</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_ed25519(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify an ED25519 signature.\"\"\"\n    try:\n        vk = ed25519.Ed25519PublicKey.from_public_bytes(public_key)\n        vk.verify(signature, message)\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_eth","title":"<code>verify_eth(public_key, message_hash, signature)</code>  <code>staticmethod</code>","text":"<p>Verify an Ethereum (EIP-712) signature</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_eth(public_key: bytes, message_hash: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify an Ethereum (EIP-712) signature\"\"\"\n    try:\n        eth_key = eth_keys.PublicKey(public_key)\n        eth_signature = eth_keys.Signature(signature)\n        return eth_key.verify_msg_hash(message_hash, eth_signature)\n    except (ValidationError, BadSignature):\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_merkle_hash","title":"<code>verify_merkle_hash(metadata_hash, txn_hash, signature)</code>  <code>staticmethod</code>","text":"<p>Verify if a Merkle hash is valid.</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_merkle_hash(metadata_hash: bytes, txn_hash: bytes, signature: Signature) -&gt; bool:\n    \"\"\"Verify if a Merkle hash is valid.\"\"\"\n    try:\n        calculated_merkle_hash = hashlib.sha256(metadata_hash + txn_hash).digest()\n        return calculated_merkle_hash == signature.transactionHash\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signature_handler.SignatureHandler.verify_rsa_sha256","title":"<code>verify_rsa_sha256(public_key, message, signature)</code>  <code>staticmethod</code>","text":"<p>Verify an RSA SHA-256 signature</p> Source code in <code>accumulate\\signing\\signature_handler.py</code> <pre><code>@staticmethod\ndef verify_rsa_sha256(public_key: bytes, message: bytes, signature: bytes) -&gt; bool:\n    \"\"\"Verify an RSA SHA-256 signature\"\"\"\n    try:\n        public_key_obj = serialization.load_pem_public_key(\n            public_key, backend=default_backend()\n        )\n        public_key_obj.verify(\n            signature,\n            message,\n            PKCS1v15(),\n            SHA256(),\n        )\n        return True\n    except Exception:\n        return False\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signer","title":"<code>signer</code>","text":""},{"location":"api_reference/#accumulate.signing.signer.Signer","title":"<code>Signer</code>","text":"Source code in <code>accumulate\\signing\\signer.py</code> <pre><code>class Signer:\n    _signer_version = 1\n    _signature_type: Optional[SignatureType] = None  #  Store signature type\n\n    def __init__(self, url: Optional[URL] = None, signer_version: int = 1, signature_type: Optional[SignatureType] = None):\n        self._private_key = None\n        self._public_key = None\n        self.url = url\n        self._signer_version = signer_version\n        self._signature_type = signature_type\n\n    @staticmethod\n    async def select_signer(account_url: URL, private_key: bytes, client: Optional[\"AccumulateClient\"] = None) -&gt; \"Signer\":\n        if client is None:\n            from accumulate.api.client import AccumulateClient  \n            from accumulate.config import get_accumulate_rpc_url  \n            client = AccumulateClient(get_accumulate_rpc_url())\n\n        from accumulate.utils.validation import process_signer_url  \n        logger.info(f\"Checking signer type and version for {account_url}...\")\n\n        signer_info = await process_signer_url(account_url, client)\n\n        processed_url = signer_info[\"url\"]\n        signer_version = signer_info[\"signer_version\"]\n        signer_type = signer_info[\"signer_type\"]\n\n        #  Convert the fetched signer_type string to a SignatureType Enum\n        signature_type_enum = SignatureType[signer_type] if signer_type in SignatureType.__members__ else SignatureType.ED25519\n\n        logger.info(f\"Using {processed_url} as signer ({signer_type}), Version: {signer_version}\")\n\n        signer = Signer(URL.parse(processed_url), signer_version, signature_type_enum)\n        signer.set_keys(private_key)\n\n        return signer\n\n    async def get_signature_type(self) -&gt; SignatureType:\n        \"\"\"\n        Fetch the appropriate signature type dynamically.\n\n        - If already cached, return it.\n        - Otherwise, determine it dynamically.\n        \"\"\"\n        if self._signature_type:\n            return self._signature_type  #  Use cached signature type if available\n\n        #  Implement logic to fetch the actual signature type from signer metadata\n        # Currently defaulting to ED25519, but should be dynamically set\n        self._signature_type = SignatureType.ED25519  # Replace with dynamic lookup if needed\n\n        logger.info(f\" Determined Signature Type: {self._signature_type.name}\")\n        return self._signature_type\n\n    def set_keys(self, private_key: bytes) -&gt; None:\n        if len(private_key) == 64:\n            private_scalar = private_key[:32]\n            derived_public_key = private_key[32:]\n        elif len(private_key) == 32:\n            private_scalar = private_key\n            derived_public_key = None\n\n        self._private_key = ed25519.Ed25519PrivateKey.from_private_bytes(private_scalar)\n        computed_public_key = self._private_key.public_key().public_bytes(\n            encoding=serialization.Encoding.Raw,\n            format=serialization.PublicFormat.Raw\n        )\n\n        if derived_public_key and computed_public_key != derived_public_key:\n            raise ValueError(\"Derived public key does not match computed public key!\")\n\n        self._public_key = computed_public_key\n        logger.info(f\"Public Key Correctly Set: {self._public_key.hex()}\")\n\n    def get_public_key(self) -&gt; bytes:\n        if not self._public_key:\n            logger.warning(\"Public key missing. Regenerating from private key.\")\n            if self._private_key:\n                self._public_key = self._private_key.public_key().public_bytes(\n                    encoding=serialization.Encoding.Raw,\n                    format=serialization.PublicFormat.Raw\n                )\n            else:\n                raise ValueError(\"Public key has not been set. Call set_keys() first.\")\n        return self._public_key\n\n    def get_private_key(self) -&gt; bytes:\n        if not self._private_key:\n            raise ValueError(\"Private key has not been set. Call set_keys() first.\")\n        return self._private_key.private_bytes(\n            encoding=serialization.Encoding.Raw,\n            format=serialization.PrivateFormat.Raw,\n            encryption_algorithm=serialization.NoEncryption()\n        )\n\n    async def get_signer_version(self) -&gt; int:\n        if self.url is None:\n            raise ValueError(\"Signer URL is missing, cannot determine version.\")\n        return self._signer_version\n\n    def set_signer_version(self, version: int):\n        self._signer_version = version\n\n\n#    async def sign_transaction(self, signature_type: SignatureType, message: bytes, signer_version: Optional[int] = None) -&gt; dict:\n    async def sign_transaction(\n        self, \n        signature_type: SignatureType, \n        message: bytes, \n        txn_header: TransactionHeader,  # Use the TransactionHeader object to access timestamp\n        signer_version: Optional[int] = None\n    ) -&gt; dict:\n        \"\"\"\n        Signs the transaction using the timestamp from the TransactionHeader.\n\n        :param signature_type: The signature type (e.g., ED25519, BTC, etc.).\n        :param message: The transaction hash to sign.\n        :param txn_header: The TransactionHeader instance, containing the timestamp.\n        :param signer_version: The signer's version (if None, uses the default).\n        :return: A signed transaction dictionary.\n        \"\"\"\n        if not self._private_key:\n            raise ValueError(\"Private key not set. Call set_keys() first.\")\n        if not self._public_key:\n            raise ValueError(\"Public key not set. Call set_keys() properly.\")\n\n        if signer_version is None:\n            signer_version = self._signer_version\n\n        #  Use timestamp from the TransactionHeader\n        timestamp = txn_header.timestamp\n        if timestamp is None:\n            raise ValueError(\"Transaction header does not have a timestamp!\")\n\n        logger.info(f\" Signer Using TransactionHeader Timestamp: {timestamp}\")\n\n        # Compute metadata (initiator) hash using uvarint encoding.\n        metadata_hash = Signer.calculate_metadata_hash(\n            self.get_public_key(), timestamp, str(self.url), signer_version, signature_type.value\n        )\n\n        logger.info(f\" FROM SIGNER - Metadata (Public key) Hash: {self.get_public_key().hex()}\")\n        logger.info(f\" FROM SIGNER - Metadata (timestamp) Hash: {timestamp}\")\n        logger.info(f\" FROM SIGNER - Metadata (signer) Hash: {str(self.url)}\")\n        logger.info(f\" FROM SIGNER - Metadata (signer_version) Hash: {signer_version}\")\n        logger.info(f\" FROM SIGNER - Metadata (signature_type.vale) Hash: {signature_type.value}\")\n\n        logger.info(f\" FROM SIGNER - Metadata (initiator) Hash: {metadata_hash.hex()}\")\n\n        # Here, 'message' is expected to be the final transaction hash as computed in your transaction marshalling\n        logger.info(f\"Message passed for signing (transaction hash): {message.hex()}\")\n\n        # Compute the final signing hash as sha256(metadata_hash + message)\n        final_hash = hashlib.sha256(metadata_hash + message).digest()\n        logger.info(f\"Final Hash for Signing (sha256(metadata_hash + message)): {final_hash.hex()}\")\n\n        # Sign using the appropriate algorithm.\n        if signature_type == SignatureType.ED25519:\n            signature = self._private_key.sign(final_hash)\n        elif signature_type == SignatureType.BTC:\n            priv_key = ec.derive_private_key(int.from_bytes(self.get_private_key(), \"big\"), ec.SECP256K1())\n            signature = priv_key.sign(final_hash, ec.ECDSA(hashes.SHA256()))\n        elif signature_type == SignatureType.ETH:\n            eth_key = eth_keys.PrivateKey(self.get_private_key())\n            signature = eth_key.sign_msg_hash(final_hash).to_bytes()\n        elif signature_type == SignatureType.RSA_SHA256:\n            private_key_obj = serialization.load_pem_private_key(self.get_private_key(), password=None, backend=default_backend())\n            if isinstance(private_key_obj, rsa.RSAPrivateKey):\n                signature = private_key_obj.sign(\n                    final_hash,\n                    PKCS1v15(),\n                    hashes.SHA256(),\n                )\n            else:\n                raise ValueError(\"Invalid RSA private key\")\n        elif signature_type == SignatureType.ECDSA_SHA256:\n            priv_key = ec.derive_private_key(int.from_bytes(self.get_private_key(), \"big\"), ec.SECP256K1())\n            signature = priv_key.sign(final_hash, ec.ECDSA(hashes.SHA256()))\n        else:\n            raise ValueError(f\"Unsupported signature type: {signature_type}\")\n\n        logger.info(\"sign_transaction() called successfully!\")\n        logger.info(f\"Signature Generated: {signature.hex()}\")\n\n        signed_transaction = {\n            \"type\": signature_type.name.lower(),\n            \"publicKey\": self.get_public_key().hex(),\n            \"signature\": signature.hex(),\n            \"signer\": str(self.url),\n            \"signerVersion\": signer_version,\n            \"timestamp\": timestamp,\n            \"transactionHash\": message.hex()  # The original transaction hash passed in\n        }\n\n        logger.info(f\"Signed Transaction Data - {signed_transaction}\")\n\n        return signed_transaction\n\n    async def sign(self, message: bytes, opts: dict) -&gt; dict:\n        signature_type = opts.get(\"signatureType\", SignatureType.ED25519)\n        signer_version = opts.get(\"signerVersion\", self._signer_version)\n        return await self.sign_transaction(signature_type, message, signer_version)\n\n    @staticmethod\n    def for_lite(signer: \"Signer\") -&gt; \"Signer\":\n        if signer._public_key is None or signer._private_key is None:\n            raise ValueError(\"Signer must have keys set before calling for_lite().\")\n\n        key_str = hashlib.sha256(signer.get_public_key()).digest()[:20]\n        check_sum = hashlib.sha256(key_str).digest()[-4:]\n        lite_url = URL.parse(f\"acc://{key_str.hex()}{check_sum.hex()}\")\n\n        logger.info(f\"Created Lite Signer: {lite_url}\")\n\n        lite_signer = Signer(lite_url, signer_version=1)\n        lite_signer._public_key = signer._public_key\n        lite_signer._private_key = signer._private_key\n\n        return lite_signer\n\n    def set_public_key(self, signature: Dict, private_key: bytes) -&gt; None:\n        signature_type = signature.get(\"type\")\n        if signature_type in [SignatureType.LEGACY_ED25519, SignatureType.ED25519, SignatureType.RCD1]:\n            private_key_obj = ed25519.Ed25519PrivateKey.from_private_bytes(private_key)\n            self._public_key = private_key_obj.public_key().public_bytes(\n                encoding=serialization.Encoding.Raw,\n                format=serialization.PublicFormat.Raw\n            )  \n            signature[\"publicKey\"] = self._public_key.hex()\n        elif signature_type in [SignatureType.BTC]:\n            priv_key = ec.derive_private_key(int.from_bytes(private_key, \"big\"), ec.SECP256K1())\n            public_key = priv_key.public_key().public_bytes(\n                encoding=serialization.Encoding.X962,\n                format=serialization.PublicFormat.CompressedPoint\n            )\n            signature[\"publicKey\"] = public_key.hex()\n            signature[\"btc_address\"] = btc_address(public_key)\n        elif signature_type == SignatureType.ETH:\n            eth_key = eth_keys.PrivateKey(private_key)\n            public_key = eth_key.public_key.to_bytes()\n            signature[\"eth_address\"] = eth_address(public_key)\n        elif signature_type == SignatureType.RSA_SHA256:\n            private_key_obj = serialization.load_pem_private_key(private_key, password=None, backend=default_backend())\n            if isinstance(private_key_obj, rsa.RSAPrivateKey):\n                signature[\"publicKey\"] = private_key_obj.public_key().public_bytes(\n                    encoding=serialization.Encoding.PEM,\n                    format=serialization.PublicFormat.SubjectPublicKeyInfo\n                ).hex()\n        elif signature_type == SignatureType.ECDSA_SHA256:\n            priv_key = ec.derive_private_key(int.from_bytes(private_key, \"big\"), ec.SECP256K1())\n            signature[\"publicKey\"] = priv_key.public_key().public_bytes(\n                encoding=serialization.Encoding.PEM,\n                format=serialization.PublicFormat.SubjectPublicKeyInfo\n            ).hex()\n        else:\n            raise ValueError(f\"Cannot set the public key for {signature_type}\")\n\n    def sign_rcd1(self, private_key: bytes, message: bytes) -&gt; dict:\n        private_key_obj = ed25519.Ed25519PrivateKey.from_private_bytes(private_key)\n        hashed_message = hashlib.sha256(message).digest()\n        signature = private_key_obj.sign(hashed_message)\n        return {\"signature\": signature.hex()}\n\n    def verify_rcd1(self, public_key: bytes, signature: bytes, message: bytes) -&gt; bool:\n        try:\n            vk = ed25519.Ed25519PublicKey.from_public_bytes(public_key)\n            hashed_message = hashlib.sha256(message).digest()\n            vk.verify(signature, hashed_message)\n            return True\n        except Exception:\n            return False\n\n    @staticmethod\n    def sha256_concat(*data: bytes) -&gt; bytes:\n        return hashlib.sha256(b\"\".join(data)).digest()\n\n    @staticmethod\n    def encode_varint(value: int) -&gt; bytes:\n        if value &lt; 0:\n            raise ValueError(\"Varint encoding requires a non-negative integer.\")\n        encoded_bytes = bytearray()\n        while value &gt;= 0x80:\n            encoded_bytes.append((value &amp; 0x7F) | 0x80)\n            value &gt;&gt;= 7\n        encoded_bytes.append(value)\n        return bytes(encoded_bytes)\n\n    @staticmethod\n    def calculate_metadata_hash(public_key: bytes, timestamp: int, signer: str, version: int, signature_type: int) -&gt; bytes:\n        \"\"\"\n        Compute Accumulate's signature metadata (initiator) hash using uvarint encoding for all fields.\n        This exactly mirrors the Dart implementation.\n\n        Fields:\n        - Field 1: Signature type (varint-encoded)\n        - Field 2: Public key (varint-encoded length + raw bytes)\n        - Field 4: Signer URL (UTF-8 encoded, with varint length prefix)\n        - Field 5: Signer version (varint-encoded)\n        - Field 6: Timestamp (varint-encoded)\n        \"\"\"\n        from accumulate.utils.encoding import encode_uvarint\n\n        logger.debug(f\" calculate_metadata_hash: {public_key.hex()}\")\n        logger.debug(f\" calculate_metadata_hash: {timestamp}\")\n        logger.debug(f\" calculate_metadata_hash: {signer}\")\n        logger.debug(f\" calculate_metadata_hash: {version}\")\n        logger.debug(f\" calculate_metadata_hash: {signature_type}\")\n\n        # Encode the signer URL into bytes.\n        signer_bytes = signer.encode(\"utf-8\")\n\n        # Build the metadata binary by concatenating each field in order.\n        metadata = b\"\".join([\n            b\"\\x01\" + encode_uvarint(signature_type),                   # Field 1: Signature type\n            b\"\\x02\" + encode_uvarint(len(public_key)) + public_key,         # Field 2: Public key\n            b\"\\x04\" + encode_uvarint(len(signer_bytes)) + signer_bytes,       # Field 4: Signer URL\n            b\"\\x05\" + encode_uvarint(version),                              # Field 5: Signer version\n            b\"\\x06\" + encode_uvarint(timestamp)                             # Field 6: Timestamp\n        ])\n\n        logger.debug(f\" Final Metadata Encoding (hex): {metadata.hex()}\")\n\n        # Compute the SHA-256 hash of the concatenated metadata.\n        metadata_hash = hashlib.sha256(metadata).digest()\n        logger.debug(f\"Metadata Hash (SHA-256, hex): {metadata_hash.hex()}\")\n        return metadata_hash\n\n\n    @staticmethod\n    def calculate_signature_hash(signature) -&gt; bytes:\n        data = signature.marshal_binary()\n        return Signer.sha256_concat(data)\n\n    @staticmethod\n    def is_parent_of(parent: URL, child: URL) -&gt; bool:\n        return str(child).startswith(str(parent))\n\n\n    async def sign_and_submit_transaction(\n        self, client: \"AccumulateClient\", txn: Transaction, signature_type: SignatureType, debug: bool = False\n    ) -&gt; dict:\n        \"\"\"\n        Signs the transaction, constructs the envelope, and submits it.\n\n        :param client: AccumulateClient instance\n        :param txn: Transaction object\n        :param signature_type: Type of signature (e.g., ED25519)\n        :param debug: If True, print the exact JSON request without sending it.\n        :return: Response from the Accumulate network or printed JSON in debug mode.\n        \"\"\"\n        #  Step 1: Check if this is a Remote Transaction\n        if isinstance(txn.body, RemoteTransaction):\n            logger.info(\" RemoteTransaction detected, checking multisignature conditions...\")\n\n            #  If it does NOT support multisignature, prevent signing\n            if not txn.body.allows_multisig():\n                raise ValueError(\"Cannot sign a RemoteTransaction that does not allow multisignatures.\")\n\n            #  Otherwise, allow signing but ensure it's an additional signature\n            existing_signatures = txn.body.get_existing_signatures()\n            if self.get_public_key() in existing_signatures:\n                raise ValueError(\"This signer has already signed this RemoteTransaction.\")\n\n            logger.info(f\" Proceeding with multisignature signing for RemoteTransaction.\")\n\n        #  Step 2: Check if the signer has keys set\n        if not self._private_key or not self._public_key:\n            raise ValueError(\"Signer keys not set. Call set_keys() first.\")\n\n        logger.info(\" Computing transaction hash...\")\n        txn_hash = txn.get_hash()\n\n        logger.info(f\" Signing transaction (hash: {txn_hash.hex()})...\")\n        signature_data = await self.sign_transaction(signature_type, txn_hash, txn.header)\n\n        logger.info(f\" Constructing envelope...\")\n        envelope = {\n            \"signatures\": [signature_data],\n            \"transaction\": [txn.to_dict()]\n        }\n\n        if debug:\n            formatted_json = json.dumps(envelope, indent=4)\n            logger.info(f\" RPC Request (Not Sent):\\n{formatted_json}\")\n            return envelope  # Return the request without sending\n\n        logger.info(f\" Submitting transaction to the Accumulate network...\")\n        try:\n            json_envelope = json.dumps(envelope)\n            response = await client.submit(json.loads(json_envelope))\n            logger.info(f\" Transaction Submitted Successfully! Response: {response}\")\n            return response\n        except Exception as e:\n            logger.error(f\" Transaction Submission Failed: {e}\")\n            raise\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signer.Signer.calculate_metadata_hash","title":"<code>calculate_metadata_hash(public_key, timestamp, signer, version, signature_type)</code>  <code>staticmethod</code>","text":"<p>Compute Accumulate's signature metadata (initiator) hash using uvarint encoding for all fields. This exactly mirrors the Dart implementation.</p> <p>Fields: - Field 1: Signature type (varint-encoded) - Field 2: Public key (varint-encoded length + raw bytes) - Field 4: Signer URL (UTF-8 encoded, with varint length prefix) - Field 5: Signer version (varint-encoded) - Field 6: Timestamp (varint-encoded)</p> Source code in <code>accumulate\\signing\\signer.py</code> <pre><code>@staticmethod\ndef calculate_metadata_hash(public_key: bytes, timestamp: int, signer: str, version: int, signature_type: int) -&gt; bytes:\n    \"\"\"\n    Compute Accumulate's signature metadata (initiator) hash using uvarint encoding for all fields.\n    This exactly mirrors the Dart implementation.\n\n    Fields:\n    - Field 1: Signature type (varint-encoded)\n    - Field 2: Public key (varint-encoded length + raw bytes)\n    - Field 4: Signer URL (UTF-8 encoded, with varint length prefix)\n    - Field 5: Signer version (varint-encoded)\n    - Field 6: Timestamp (varint-encoded)\n    \"\"\"\n    from accumulate.utils.encoding import encode_uvarint\n\n    logger.debug(f\" calculate_metadata_hash: {public_key.hex()}\")\n    logger.debug(f\" calculate_metadata_hash: {timestamp}\")\n    logger.debug(f\" calculate_metadata_hash: {signer}\")\n    logger.debug(f\" calculate_metadata_hash: {version}\")\n    logger.debug(f\" calculate_metadata_hash: {signature_type}\")\n\n    # Encode the signer URL into bytes.\n    signer_bytes = signer.encode(\"utf-8\")\n\n    # Build the metadata binary by concatenating each field in order.\n    metadata = b\"\".join([\n        b\"\\x01\" + encode_uvarint(signature_type),                   # Field 1: Signature type\n        b\"\\x02\" + encode_uvarint(len(public_key)) + public_key,         # Field 2: Public key\n        b\"\\x04\" + encode_uvarint(len(signer_bytes)) + signer_bytes,       # Field 4: Signer URL\n        b\"\\x05\" + encode_uvarint(version),                              # Field 5: Signer version\n        b\"\\x06\" + encode_uvarint(timestamp)                             # Field 6: Timestamp\n    ])\n\n    logger.debug(f\" Final Metadata Encoding (hex): {metadata.hex()}\")\n\n    # Compute the SHA-256 hash of the concatenated metadata.\n    metadata_hash = hashlib.sha256(metadata).digest()\n    logger.debug(f\"Metadata Hash (SHA-256, hex): {metadata_hash.hex()}\")\n    return metadata_hash\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signer.Signer.get_signature_type","title":"<code>get_signature_type()</code>  <code>async</code>","text":"<p>Fetch the appropriate signature type dynamically.</p> <ul> <li>If already cached, return it.</li> <li>Otherwise, determine it dynamically.</li> </ul> Source code in <code>accumulate\\signing\\signer.py</code> <pre><code>async def get_signature_type(self) -&gt; SignatureType:\n    \"\"\"\n    Fetch the appropriate signature type dynamically.\n\n    - If already cached, return it.\n    - Otherwise, determine it dynamically.\n    \"\"\"\n    if self._signature_type:\n        return self._signature_type  #  Use cached signature type if available\n\n    #  Implement logic to fetch the actual signature type from signer metadata\n    # Currently defaulting to ED25519, but should be dynamically set\n    self._signature_type = SignatureType.ED25519  # Replace with dynamic lookup if needed\n\n    logger.info(f\" Determined Signature Type: {self._signature_type.name}\")\n    return self._signature_type\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signer.Signer.sign_and_submit_transaction","title":"<code>sign_and_submit_transaction(client, txn, signature_type, debug=False)</code>  <code>async</code>","text":"<p>Signs the transaction, constructs the envelope, and submits it.</p> <p>:param client: AccumulateClient instance :param txn: Transaction object :param signature_type: Type of signature (e.g., ED25519) :param debug: If True, print the exact JSON request without sending it. :return: Response from the Accumulate network or printed JSON in debug mode.</p> Source code in <code>accumulate\\signing\\signer.py</code> <pre><code>async def sign_and_submit_transaction(\n    self, client: \"AccumulateClient\", txn: Transaction, signature_type: SignatureType, debug: bool = False\n) -&gt; dict:\n    \"\"\"\n    Signs the transaction, constructs the envelope, and submits it.\n\n    :param client: AccumulateClient instance\n    :param txn: Transaction object\n    :param signature_type: Type of signature (e.g., ED25519)\n    :param debug: If True, print the exact JSON request without sending it.\n    :return: Response from the Accumulate network or printed JSON in debug mode.\n    \"\"\"\n    #  Step 1: Check if this is a Remote Transaction\n    if isinstance(txn.body, RemoteTransaction):\n        logger.info(\" RemoteTransaction detected, checking multisignature conditions...\")\n\n        #  If it does NOT support multisignature, prevent signing\n        if not txn.body.allows_multisig():\n            raise ValueError(\"Cannot sign a RemoteTransaction that does not allow multisignatures.\")\n\n        #  Otherwise, allow signing but ensure it's an additional signature\n        existing_signatures = txn.body.get_existing_signatures()\n        if self.get_public_key() in existing_signatures:\n            raise ValueError(\"This signer has already signed this RemoteTransaction.\")\n\n        logger.info(f\" Proceeding with multisignature signing for RemoteTransaction.\")\n\n    #  Step 2: Check if the signer has keys set\n    if not self._private_key or not self._public_key:\n        raise ValueError(\"Signer keys not set. Call set_keys() first.\")\n\n    logger.info(\" Computing transaction hash...\")\n    txn_hash = txn.get_hash()\n\n    logger.info(f\" Signing transaction (hash: {txn_hash.hex()})...\")\n    signature_data = await self.sign_transaction(signature_type, txn_hash, txn.header)\n\n    logger.info(f\" Constructing envelope...\")\n    envelope = {\n        \"signatures\": [signature_data],\n        \"transaction\": [txn.to_dict()]\n    }\n\n    if debug:\n        formatted_json = json.dumps(envelope, indent=4)\n        logger.info(f\" RPC Request (Not Sent):\\n{formatted_json}\")\n        return envelope  # Return the request without sending\n\n    logger.info(f\" Submitting transaction to the Accumulate network...\")\n    try:\n        json_envelope = json.dumps(envelope)\n        response = await client.submit(json.loads(json_envelope))\n        logger.info(f\" Transaction Submitted Successfully! Response: {response}\")\n        return response\n    except Exception as e:\n        logger.error(f\" Transaction Submission Failed: {e}\")\n        raise\n</code></pre>"},{"location":"api_reference/#accumulate.signing.signer.Signer.sign_transaction","title":"<code>sign_transaction(signature_type, message, txn_header, signer_version=None)</code>  <code>async</code>","text":"<p>Signs the transaction using the timestamp from the TransactionHeader.</p> <p>:param signature_type: The signature type (e.g., ED25519, BTC, etc.). :param message: The transaction hash to sign. :param txn_header: The TransactionHeader instance, containing the timestamp. :param signer_version: The signer's version (if None, uses the default). :return: A signed transaction dictionary.</p> Source code in <code>accumulate\\signing\\signer.py</code> <pre><code>async def sign_transaction(\n    self, \n    signature_type: SignatureType, \n    message: bytes, \n    txn_header: TransactionHeader,  # Use the TransactionHeader object to access timestamp\n    signer_version: Optional[int] = None\n) -&gt; dict:\n    \"\"\"\n    Signs the transaction using the timestamp from the TransactionHeader.\n\n    :param signature_type: The signature type (e.g., ED25519, BTC, etc.).\n    :param message: The transaction hash to sign.\n    :param txn_header: The TransactionHeader instance, containing the timestamp.\n    :param signer_version: The signer's version (if None, uses the default).\n    :return: A signed transaction dictionary.\n    \"\"\"\n    if not self._private_key:\n        raise ValueError(\"Private key not set. Call set_keys() first.\")\n    if not self._public_key:\n        raise ValueError(\"Public key not set. Call set_keys() properly.\")\n\n    if signer_version is None:\n        signer_version = self._signer_version\n\n    #  Use timestamp from the TransactionHeader\n    timestamp = txn_header.timestamp\n    if timestamp is None:\n        raise ValueError(\"Transaction header does not have a timestamp!\")\n\n    logger.info(f\" Signer Using TransactionHeader Timestamp: {timestamp}\")\n\n    # Compute metadata (initiator) hash using uvarint encoding.\n    metadata_hash = Signer.calculate_metadata_hash(\n        self.get_public_key(), timestamp, str(self.url), signer_version, signature_type.value\n    )\n\n    logger.info(f\" FROM SIGNER - Metadata (Public key) Hash: {self.get_public_key().hex()}\")\n    logger.info(f\" FROM SIGNER - Metadata (timestamp) Hash: {timestamp}\")\n    logger.info(f\" FROM SIGNER - Metadata (signer) Hash: {str(self.url)}\")\n    logger.info(f\" FROM SIGNER - Metadata (signer_version) Hash: {signer_version}\")\n    logger.info(f\" FROM SIGNER - Metadata (signature_type.vale) Hash: {signature_type.value}\")\n\n    logger.info(f\" FROM SIGNER - Metadata (initiator) Hash: {metadata_hash.hex()}\")\n\n    # Here, 'message' is expected to be the final transaction hash as computed in your transaction marshalling\n    logger.info(f\"Message passed for signing (transaction hash): {message.hex()}\")\n\n    # Compute the final signing hash as sha256(metadata_hash + message)\n    final_hash = hashlib.sha256(metadata_hash + message).digest()\n    logger.info(f\"Final Hash for Signing (sha256(metadata_hash + message)): {final_hash.hex()}\")\n\n    # Sign using the appropriate algorithm.\n    if signature_type == SignatureType.ED25519:\n        signature = self._private_key.sign(final_hash)\n    elif signature_type == SignatureType.BTC:\n        priv_key = ec.derive_private_key(int.from_bytes(self.get_private_key(), \"big\"), ec.SECP256K1())\n        signature = priv_key.sign(final_hash, ec.ECDSA(hashes.SHA256()))\n    elif signature_type == SignatureType.ETH:\n        eth_key = eth_keys.PrivateKey(self.get_private_key())\n        signature = eth_key.sign_msg_hash(final_hash).to_bytes()\n    elif signature_type == SignatureType.RSA_SHA256:\n        private_key_obj = serialization.load_pem_private_key(self.get_private_key(), password=None, backend=default_backend())\n        if isinstance(private_key_obj, rsa.RSAPrivateKey):\n            signature = private_key_obj.sign(\n                final_hash,\n                PKCS1v15(),\n                hashes.SHA256(),\n            )\n        else:\n            raise ValueError(\"Invalid RSA private key\")\n    elif signature_type == SignatureType.ECDSA_SHA256:\n        priv_key = ec.derive_private_key(int.from_bytes(self.get_private_key(), \"big\"), ec.SECP256K1())\n        signature = priv_key.sign(final_hash, ec.ECDSA(hashes.SHA256()))\n    else:\n        raise ValueError(f\"Unsupported signature type: {signature_type}\")\n\n    logger.info(\"sign_transaction() called successfully!\")\n    logger.info(f\"Signature Generated: {signature.hex()}\")\n\n    signed_transaction = {\n        \"type\": signature_type.name.lower(),\n        \"publicKey\": self.get_public_key().hex(),\n        \"signature\": signature.hex(),\n        \"signer\": str(self.url),\n        \"signerVersion\": signer_version,\n        \"timestamp\": timestamp,\n        \"transactionHash\": message.hex()  # The original transaction hash passed in\n    }\n\n    logger.info(f\"Signed Transaction Data - {signed_transaction}\")\n\n    return signed_transaction\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp","title":"<code>timestamp</code>","text":""},{"location":"api_reference/#accumulate.signing.timestamp.Timestamp","title":"<code>Timestamp</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for timestamp implementations.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>class Timestamp(ABC):\n    \"\"\"Abstract base class for timestamp implementations.\"\"\"\n\n    @abstractmethod\n    def get(self) -&gt; int:\n        \"\"\"\n        Retrieve the current timestamp value.\n\n        Returns:\n            int: The current timestamp value.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp.Timestamp.get","title":"<code>get()</code>  <code>abstractmethod</code>","text":"<p>Retrieve the current timestamp value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The current timestamp value.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>@abstractmethod\ndef get(self) -&gt; int:\n    \"\"\"\n    Retrieve the current timestamp value.\n\n    Returns:\n        int: The current timestamp value.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp.TimestampFromValue","title":"<code>TimestampFromValue</code>","text":"<p>               Bases: <code>Timestamp</code></p> <p>Static timestamp that always returns a predefined value.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>class TimestampFromValue(Timestamp):\n    \"\"\"Static timestamp that always returns a predefined value.\"\"\"\n\n    def __init__(self, value: int):\n        if value &lt; 0:\n            raise ValueError(\"Timestamp value must be non-negative\")\n        self._value = value\n\n    def get(self) -&gt; int:\n        \"\"\"\n        Retrieve the static timestamp value.\n\n        Returns:\n            int: The predefined timestamp value.\n        \"\"\"\n        return self._value\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp.TimestampFromValue.get","title":"<code>get()</code>","text":"<p>Retrieve the static timestamp value.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The predefined timestamp value.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>def get(self) -&gt; int:\n    \"\"\"\n    Retrieve the static timestamp value.\n\n    Returns:\n        int: The predefined timestamp value.\n    \"\"\"\n    return self._value\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp.TimestampFromVariable","title":"<code>TimestampFromVariable</code>","text":"<p>               Bases: <code>Timestamp</code></p> <p>Dynamic timestamp that starts with real time (in milliseconds) and increments.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>class TimestampFromVariable(Timestamp):\n    \"\"\"Dynamic timestamp that starts with real time (in milliseconds) and increments.\"\"\"\n\n    def __init__(self, initial_value: int = None):\n        if initial_value is None:\n            initial_value = int(time.time() * 1e3)  # \u2b05\ufe0f Now using milliseconds\n        if initial_value &lt; 0:\n            raise ValueError(\"Initial timestamp value must be non-negative\")\n        self._value = initial_value\n        self._lock = threading.Lock()\n\n    def get(self) -&gt; int:\n        \"\"\"Atomically increment and retrieve the timestamp value.\"\"\"\n        with self._lock:\n            self._value += 1  # \u2b05\ufe0f Increment by 1 millisecond\n            return self._value\n\n    def reset(self, value: int = 0):\n        \"\"\"\n        Reset the timestamp to a specified value (primarily for testing).\n\n        Args:\n            value (int): The value to reset the timestamp to. Must be non-negative.\n\n        Raises:\n            ValueError: If the provided value is negative.\n        \"\"\"\n        if value &lt; 0:\n            raise ValueError(\"Reset value must be non-negative\")\n        with self._lock:\n            self._value = value\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp.TimestampFromVariable.get","title":"<code>get()</code>","text":"<p>Atomically increment and retrieve the timestamp value.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>def get(self) -&gt; int:\n    \"\"\"Atomically increment and retrieve the timestamp value.\"\"\"\n    with self._lock:\n        self._value += 1  # \u2b05\ufe0f Increment by 1 millisecond\n        return self._value\n</code></pre>"},{"location":"api_reference/#accumulate.signing.timestamp.TimestampFromVariable.reset","title":"<code>reset(value=0)</code>","text":"<p>Reset the timestamp to a specified value (primarily for testing).</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The value to reset the timestamp to. Must be non-negative.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided value is negative.</p> Source code in <code>accumulate\\signing\\timestamp.py</code> <pre><code>def reset(self, value: int = 0):\n    \"\"\"\n    Reset the timestamp to a specified value (primarily for testing).\n\n    Args:\n        value (int): The value to reset the timestamp to. Must be non-negative.\n\n    Raises:\n        ValueError: If the provided value is negative.\n    \"\"\"\n    if value &lt; 0:\n        raise ValueError(\"Reset value must be non-negative\")\n    with self._lock:\n        self._value = value\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#6-changelogmd-version-history","title":"6. <code>changelog.md</code> (Version History)","text":"<p>```markdown</p>"},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":"<ul> <li>Initial preparation for v1.0.0 release</li> <li>Improved documentation and code examples</li> <li>Added mkdocstrings auto-generated API documentation support</li> </ul>"},{"location":"changelog/#010-2025-03-25","title":"[0.1.0] - 2025-03-25","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Initial release of Accumulate Python Client</li> <li>Full API V3 client setup for interacting with Accumulate blockchain</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#5-contributingmd-contribution-guidelines","title":"5. <code>contributing.md</code> (Contribution Guidelines)","text":"<p>```markdown</p>"},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We welcome contributions to the Accumulate Python Client!</p> <p>If you'd like to help improve the library, fix bugs, or add features, follow the guidelines below.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#1-fork-the-repository","title":"1. Fork the Repository","text":"<p>Click the \"Fork\" button at the top right of the GitHub repository.</p>"},{"location":"contributing/#2-clone-your-fork","title":"2. Clone Your Fork","text":"<p>```bash git clone https://github.com/opendlt/accumulate-python-client.git 3. Install Dependencies bash Copy cd accumulate-python-client pip install -r requirements.txt Making Changes Ensure code is well-documented Write tests for any new features or bug fixes Follow PEP8 and best coding practices Submitting a Pull Request (PR) Push your branch: bash Copy git push origin your-branch Open a pull request against main Fill out the PR template and describe your changes Contact For questions or discussions, open an issue or join our community discussions</p> <p>Thank you for contributing!</p> <p>yaml Copy</p>"},{"location":"examples/","title":"Examples","text":"<p>Welcome to the Accumulate Python Client examples section! This collection demonstrates real, working examples of common operations using the library \u2014 everything from querying accounts to managing identities and sending tokens.</p> <p>Tip: All example scripts are available in the GitHub examples directory. You can run these directly to see how each feature works in a real environment.</p>"},{"location":"examples/#generate-a-lite-token-account-and-request-faucet","title":"Generate a Lite Token Account and Request Faucet","text":"<p><pre><code>from accumulate import AccumulateClient\nfrom accumulate.utils.address_from import generate_ed25519_keypair\nfrom accumulate.utils.hash_functions import LiteAuthorityForKey\n\n# Generate keypair and derive Lite Account URL\nprivate_key, public_key = generate_ed25519_keypair()\nlite_identity = LiteAuthorityForKey(public_key, \"ED25519\")\nlite_account = f\"{lite_identity}/ACME\"\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\nprint(\"Lite Account URL:\", lite_account)\n</code></pre> \u27a1 Full script: method_debug_LTA_faucet.py</p>"},{"location":"examples/#query-an-account","title":"Query an Account","text":"<p><pre><code>from accumulate import AccumulateClient\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\naccount_url = \"acc://custom-adi-name-1741948502948.acme/CTACUST\"\nresponse = client.query.get_account(account_url)\nprint(\"Account details:\", response)\n</code></pre> \u27a1 Full script: method_debug_query_simple.py</p>"},{"location":"examples/#prepare-an-addcredits-transaction-key-page-version","title":"Prepare an AddCredits Transaction (Key Page Version)","text":"<p><pre><code>from accumulate import AccumulateClient, AddCredits\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\nlite_account = \"acc://your-lite-identity/ACME\"\ntx = AddCredits(client, lite_account, 10000)\nprint(\"Prepared AddCredits transaction for\", lite_account)\n</code></pre> \u27a1 Full script: method_debug_series-addcredits_keypage.py</p>"},{"location":"examples/#prepare-a-basic-addcredits-transaction","title":"Prepare a Basic AddCredits Transaction","text":"<p><pre><code>from accumulate import AccumulateClient, AddCredits\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\naccount_url = \"acc://your-identity/ACME\"\ntx = AddCredits(client, account_url, 200)\nprint(\"AddCredits transaction ready for\", account_url)\n</code></pre> \u27a1 Full script: method_debug_series-addcredits.py</p>"},{"location":"examples/#create-a-new-identity-adi","title":"Create a New Identity (ADI)","text":"<p><pre><code>from accumulate import AccumulateClient, CreateIdentity\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\nnew_identity = \"acc://test0001python.acme\"\nkeybook_url = \"acc://test0001python.acme/Keybook\"\ntx = CreateIdentity(new_identity, b\"your_public_key\", keybook_url)\nprint(\"Identity creation transaction prepared for\", new_identity)\n</code></pre> \u27a1 Full script: method_debug_series-createIdentity.py</p>"},{"location":"examples/#create-a-custom-token-account","title":"Create a Custom Token Account","text":"<p><pre><code>from accumulate import AccumulateClient, CreateTokenAccount\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\ntoken_account = \"acc://custom-adi-name-1741948502948.acme/CTACUST\"\ntoken_issuer = \"acc://custom-adi-name-1741948502948.acme/CUST\"\ntx = CreateTokenAccount(url=token_account, token_url=token_issuer)\nprint(\"Custom Token Account transaction created for\", token_account)\n</code></pre> \u27a1 Full script: method_debug_series-createCustomTokenAccount.py</p>"},{"location":"examples/#create-a-data-account-transaction","title":"Create a Data Account Transaction","text":"<p><pre><code>from accumulate import AccumulateClient, CreateDataAccount\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\ndata_account = \"acc://custom-adi-name-1741948502948.acme/Data2\"\ntx = CreateDataAccount(url=data_account)\nprint(\"Data Account transaction ready for\", data_account)\n</code></pre> \u27a1 Full script: method_debug_series-createDataAccount.py</p>"},{"location":"examples/#write-data-to-a-data-account","title":"Write Data to a Data Account","text":"<p><pre><code>from accumulate import AccumulateClient, WriteData\nfrom accumulate.models.data_entries import DoubleHashDataEntry\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\ndata_account = \"acc://custom-adi-name-1741948502948.acme/Data\"\n\n# Define a sample data payload\npayload = b\"This is a test data entry for Accumulate 1.\"\nentry = DoubleHashDataEntry(data=[payload])\n\n# Create a WriteData transaction body\ntx = WriteData(entry=entry, scratch=False, write_to_state=True)\nprint(\"WriteData transaction prepared for\", data_account)\n</code></pre> \u27a1 Full script: new_method_debug_series-writeData.py</p>"},{"location":"examples/#create-a-custom-token","title":"Create a Custom Token","text":"<p><pre><code>from accumulate import AccumulateClient, CreateToken\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\ntoken_url = \"acc://custom-adi-name-1741948502948.acme/CUST\"\ntx = CreateToken(url=token_url, symbol=\"CUST\", precision=4, supply_limit=1000000)\nprint(\"Token creation transaction prepared for\", token_url)\n</code></pre> \u27a1 Full script: method_debug_series-createToken.py</p>"},{"location":"examples/#create-an-adi-token-account","title":"Create an ADI Token Account","text":"<p><pre><code>from accumulate import AccumulateClient, CreateTokenAccount\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\ntoken_account = \"acc://custom-adi-name-1741948502948.acme/Tokens\"\ntoken_issuer = \"acc://ACME\"\ntx = CreateTokenAccount(url=token_account, token_url=token_issuer)\nprint(\"Token Account creation transaction ready for\", token_account)\n</code></pre> \u27a1 Full script: method_debug_series-createTokenAccount.py</p>"},{"location":"examples/#issue-custom-tokens","title":"Issue Custom Tokens","text":"<p><pre><code>from accumulate import AccumulateClient, IssueTokens, TokenRecipient\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\nrecipient = TokenRecipient(\"acc://custom-adi-name-1741948502948.acme/CTACUST\", 5270000)\ntx = IssueTokens([recipient])\nprint(\"IssueTokens transaction prepared.\")\n</code></pre> \u27a1 Full script: method_debug_series-issueToken.py</p>"},{"location":"examples/#send-tokens","title":"Send Tokens","text":"<p><pre><code>from accumulate import AccumulateClient, SendTokens\n\nclient = AccumulateClient(\"https://testnet.accumulatenetwork.io\")\ntx = SendTokens()\ntx.add_recipient(\"acc://0408e2065256be92207b41e72f77ef154fc242a4dec2a3e6/ACME\", 11)\nprint(\"SendTokens transaction created.\")\n</code></pre> \u27a1 Full script: method_debug_series-sendTokens.py</p>"},{"location":"examples/#full-example-directory-structure","title":"Full Example Directory Structure","text":"<pre><code>examples/\n\u251c\u2500\u2500 method_debug_block_query.py                    # Query blocks and chain metadata\n\u251c\u2500\u2500 method_debug_LTA_faucet.py                     # Request ACME via faucet to a Lite Token Account (LTA)\n\u251c\u2500\u2500 method_debug_LTA_faucet_specify_account.py     # Faucet for a specifically defined account\n\u251c\u2500\u2500 method_debug_metrics_services.py              # Access network metrics and system services\n\u251c\u2500\u2500 method_debug_query_method_suite.py            # Comprehensive suite of query methods\n\u251c\u2500\u2500 method_debug_query_simple.py                  # Basic account query example\n\u251c\u2500\u2500 method_debug_search_method_examples.py        # Search accounts and data\n\u251c\u2500\u2500 method_debug_series-addcredits.py             # Add credits to Lite Token Account\n\u251c\u2500\u2500 method_debug_series-addcredits_keypage.py     # Add credits via a Key Page\n\u251c\u2500\u2500 method_debug_series-burnCustToken.py          # Burn custom tokens (destroy tokens)\n\u251c\u2500\u2500 method_debug_series-createCustomTokenAccount.py # Create custom token account (non-ACME tokens)\n\u251c\u2500\u2500 method_debug_series-createDataAccount.py      # Create a data account for storing on-chain data\n\u251c\u2500\u2500 method_debug_series-createIdentity.py         # Create an Accumulate Digital Identity (ADI)\n\u251c\u2500\u2500 method_debug_series-createKeyBook.py          # Create a Key Book to manage Key Pages\n\u251c\u2500\u2500 method_debug_series-createKeyPage.py          # Create a Key Page to hold keys\n\u251c\u2500\u2500 method_debug_series-createToken.py            # Create a new custom token (Issuer)\n\u251c\u2500\u2500 method_debug_series-createTokenAccount.py     # Create a Token Account (for ACME or Custom tokens)\n\u251c\u2500\u2500 method_debug_series-issueToken.py             # Issue (mint) custom tokens to a custom token account\n\u251c\u2500\u2500 method_debug_series-sendTokens.py             # Send tokens between accounts (ACME or Custom tokens)\n\u251c\u2500\u2500 method_debug_series-updateAuth.py             # Update account authorities\n\u251c\u2500\u2500 method_debug_series-updateKeyPage.py          # Udpate Key page with a key\n\u251c\u2500\u2500 method_debug_series-updateKeyPageDelegate.py  # Udpate Key page with a delegate\n\u251c\u2500\u2500 method_debug_series-update_auth_menu.py       # Interactive menu for numerous types account authorities Updates\n\u251c\u2500\u2500 method_debug_series-update_key_page_menu.py   # Interactive menu for numerous types of Key Page Updates\n\u251c\u2500\u2500 method_debug_series-writeData.py              # Write arbitrary data to a Data Account\n</code></pre> <p>Browse all examples on GitHub.</p>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<p>Explore the API Reference Check out more Getting Started Learn how to Contribute </p>"},{"location":"examples/#questions-or-issues","title":"Questions or Issues?","text":"<p>If you encounter any issues, please open an issue on GitHub, or submit a pull request with improvements!</p>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the Accumulate Python Client! Follow these steps to quickly install and start using the client for interacting with the Accumulate Protocol.</p>"},{"location":"getting_started/#installation","title":"Installation","text":""},{"location":"getting_started/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have the following installed:</p> <ul> <li>Python 3.8+</li> <li>pip (Python package manager)</li> <li>(Optional) git (for cloning the repo)</li> <li>(Optional but recommended) virtualenv (for isolated environments)</li> </ul>"},{"location":"getting_started/#option-1-install-via-pypi-recommended-for-most-users","title":"Option 1: Install via PyPI (Recommended for most users)","text":"<p>Install the library directly from PyPI:</p> <pre><code>pip install accumulate-python-client\n</code></pre>"},{"location":"getting_started/#option-2-install-from-source-for-development-or-latest-updates","title":"Option 2: Install from Source (For development or latest updates)","text":""},{"location":"getting_started/#1-clone-the-repository","title":"1. Clone the repository","text":"<pre><code>git clone https://github.com/opendlt/accumulate-python-client.git\ncd accumulate-python-client\n</code></pre>"},{"location":"getting_started/#2-recommended-create-and-activate-a-virtual-environment","title":"2. (Recommended) Create and activate a virtual environment","text":"<p>On Windows: <pre><code>python -m venv venv\nvenv\\Scripts\\activate\n</code></pre></p> <p>On macOS/Linux: <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre></p>"},{"location":"getting_started/#3-install-dependencies","title":"3. Install dependencies","text":"<pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"getting_started/#network-endpoints","title":"Network Endpoints","text":"<p>You can connect the client to either Testnet or Mainnet depending on your needs.</p> Network URL Testnet <code>https://testnet.accumulatenetwork.io/v3</code> Mainnet <code>https://mainnet.accumulatenetwork.io/v3</code>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>Check out Examples to see real working code.</li> <li>Explore the API Reference for detailed documentation on all available methods.</li> <li>Learn how to Contribute to improve and extend the library.</li> </ul>"},{"location":"getting_started/#need-help","title":"Need Help?","text":"<p>If you encounter issues or have questions, feel free to: - Open an issue - Submit a pull request with improvements</p> <p>Ready to start building on Accumulate? \ud83d\ude80 Happy coding!</p>"}]}